---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yzc.
--- DateTime: 2018/7/30 18:32
--- 这个类暂时没用 2018/9/5
---


GuideSystem = {}
GuideSystem.__index = GuideSystem
GuideSystem.Name = "GuideSystem"

function GuideSystem.getInstance()
    if not GuideSystem.instance then
        GuideSystem.instance=GuideSystem.New()
    end
    return GuideSystem.instance
end

function GuideSystem.New()
    BaseSystem.New(GuideSystem)
end

function GuideSystem.SaveGuideingMainID()
    return CS.Syetem.string.Format("{0}:guideing", CS.MyPlayerInfo.Instance.RoleID)
end

function GuideSystem.alGuideList()
    return CS.Syetem.string.Format("{0}:alGuideList_", CS.MyPlayerInfo.Instance.RoleID)
end

GuideSystem.curMainID = nil;
GuideSystem.curGuideList = List:New(CS.Teachconfig)
GuideSystem.curGuideIndex = nil;
GuideSystem.guiding = false;
--通过命令主动调用引导中
GuideSystem.forceGuiding = false;
GuideSystem.beforeTarGObject = nil;
GuideSystem.coroutine = nil
GuideSystem.lastPlayStoryID = nil;
--属性暂时没想到什么好方法去代替，，先用函数将就着
function GuideSystem.curGuideID()
    if GuideSystem.curGuideIndex < GuideSystem.curGuideList:Count() then
        return GuideSystem.curGuideList[GuideSystem.curGuideIndex].ID
    end
    return 0
end

function GuideSystem.curGuideCfg()
    if GuideSystem.curGuideIndex < GuideSystem.curGuideList:Count() then
        return GuideSystem.curGuideList[GuideSystem.curGuideIndex]
    end
    return null;
end

GuideSystem.SystemType = {
    Story = 1,
    Task = 2,
    Level = 3,
}

--已经引导过得列表
function GuideSystem.AlGuideIDs(guideID)
    local guideList = List:New(suint)
    local str = CS.PlayerPrefs.GetString(GuideSystem.alGuideList())
    str = str.."_"..guideID
    CS.PlayerPrefs.SetString(GuideSystem.alGuideList(), str);
end

--清空已经引导的列表
function GuideSystem.ClearAlGuideIDs()
    CS.PlayerPrefs.DeleteKey(GuideSystem.alGuideList());
end

--EventContext context
function GuideSystem.ClickNextGuide(context)
    if GuideSystem.beforeTarGObject ~= nil then
        GuideSystem.beforeTarGObject.onClick.Remove(GuideSystem.ClickNextGuide);
    end

    if GuideSystem.curMainID == 1 then
        if GuideSystem.beforeTarGObject ~= nil and GuideSystem.beforeTarGObject.name == "LevelButton" then
           local win = CS.UIWindowViewManager.ShowWindowByLua("UI_LevelInfoState");
            win.visible = false;
            CS.EventCtrl.inst:LuaTriggerEvent("HANDLE_STARTLEVEL")
            GuideSystem.GuideOver();
            return;
        end
    end

    CS.EventCtrl.inst.LuaTriggerEvent("FullScreenShade");
    GuideSystem.NextGuide();
end

--uint GObject
function GuideSystem.ShowGuide(guideID,tarGObject)
    if ~CS.UILuaWindowBase.GetWindow("UI_Guide").isShowing then
        CS.UILuaWindowBase.ShowWindow("UI_Guide");
    end
    CS.EventCtrl.inst:LuaTriggerEvent("ShowGuideUI","uint,GObject" ,{guideID, tarGObject});
    tarGObject.onClick.AddCapture(ClickNextGuide);
    GuideSystem.beforeTarGObject = tarGObject;
end

--开始引导
function GuideSystem.StartGuide(mainID,force)
    if force == nil then force = false end
    if ~force and GuideSystem.AlGuideIDs().Contains(mainID) then
        return
    end
    -- List<Teachconfig> teachCfgs
    local teachCfgs = CS.TeachconfigManager.Instance().GetConfigList(mainID);
    if teachCfgs ~= null and teachCfgs.Count > 0 then
        GuideSystem.curGuideIndex = 0;
        GuideSystem.curMainID = mainID;
        GuideSystem.curGuideList = teachCfgs;
        GuideSystem.guiding = true;
        GuideSystem.forceGuiding = force;
        GuideSystem.NextGuide();
    end
end

function GuideSystem.StartGuide(type)
    if (CS.GameDriver.inst.guideClose)then return false end
    local sysID =type
    local mainLists = CS.TeachconfigManager.Instance().GetMainList(sysID);
    if mainLists.Count == 0 then return false end
    -- value = List<Teachconfig>
    local guides = nil
    if type == GuideSystem.SystemType.Story then
        if GuideSystem.lastPlayStoryID == 0 then return false end
        for i,v in pairs(mainLists) do
            if v[0].Parame == GuideSystem.lastPlayStoryID then
                guides = v
            end
        end
        --这里是返回多个泛型集合的集合，但是这里在功能上够用了，但是linq还是需要真正的实现一遍
    elseif type == SystemType.Task then
        local taskID = CS.TaskSystem.inst.lastTaskID;
        if taskID == 0 then return false end
        for i,v in pairs(mainLists) do
            if v[0].Parame == taskID then
                guides = v
            end
        end
    elseif type == SystemType.Level then
       local levelID = CS.MatchTreeSystem.inst.lastPassLevelID;
        if levelID == 0 then return false end
        for i,v in pairs(mainLists) do
            if v[0].Parame == levelID then
                guides = v
            end
        end
    end

    if guides.Key ~= 0 then
        if GuideSystem.curMainID ~= 0 then  GuideSystem.GuideOver() end
        GuideSystem.curGuideIndex = 0;
        GuideSystem.curMainID = guides.Key;

        if  not CS.NetWorkManager.inst.mLogicServerStart and GuideSystem.curMainID ~= 1 then  return false end
        if GuideSystem.AlGuideIDs().Contains(GuideSystem.curMainID) then   return false end
        GuideSystem.curGuideList = guides.Value;
        GuideSystem.AddGuideingSave();
        GuideSystem.guiding = true;
        GuideSystem.forceGuiding = false;
        GuideSystem.NextGuide();
        return true;
    end
    return false;
end

function GuideSystem.NextGuide()
    CS.GameMsgHint.inst.CanClickScreen(false);
--    if GuideSystem.coroutine ~= nil then
--        CS.GameDriver.inst.StopCoroutine(GuideSystem.coroutine);
--        GuideSystem.coroutine = CS.GameDriver.inst.StartCoroutine(GuideSystem.INextGuide());
--    end
    --Lua中居然没有停止协程....
    assert(coroutine.resume(GuideSystem.INextGuide))
end



GuideSystem.INextGuide = coroutine.create(
function()
    print('coroutine start!')
    if GuideSystem.curGuideList.Count == 0 then
        GuideSystem.GuideOver();
        break;
    end
    local beforeIndex = GuideSystem.curGuideIndex - 1;
    if beforeIndex >= 0 then
        if GuideSystem.curGuideList[beforeIndex].End == 1 then
            GuideSystem.DelGuideingSave();
        end
    end

    if GuideSystem.curGuideIndex < GuideSystem.curGuideList.Count then
        local time = GuideSystem.curGuideCfg ~= nil and curGuideCfg.WaitTime or 0;
        yield_return2(CS.UnityEngine.WaitForSeconds(time))

        local curCfg = curGuideList[curGuideIndex];
        local windowNames = curCfg.UIWindowName;
        local comNames = windowNames.Split('/');

        local window = UIWindowViewManager.GetWindow(comNames[0]);
        if window == nil or not window.isShowing then
            print("当前窗口未显示：" .. comNames[0]);
            GuideSystem.GuideOver(false);
            break;
        end

        local parentCom = window.contentPane;
        local comName = "";
        for k = 1, comNames.Length do
            local i = k-1
            local comName = comNames[i];
            local gObj = null;
            if parentCom:GetType() == typeof(GList) then
                local index = 0;
                --out参数
                resultvalue,index = sint.TryParse(comName,index);
                if index < parentCom.numChildren then gObj = parentCom.GetChildAt(index) end
            else
                gObj = parentCom.GetChild(comName);
            end

            parentCom = gObj ~= nil and gObj.asCom or nil;
            if parentCom == nil then
                print("引导组件找不到 GuideID:" + curCfg.ID + "  comName:" + comName);
                GuideSystem.GuideOver(false);
                break;
            end
        end

        GuideSystem.ShowGuide(curCfg.ID, parentCom);
        GuideSystem.curGuideIndex = GuideSystem.curGuideIndex+1;
        print("继续引导 curMainID:" + curMainID + "  GuideID:" + curCfg.ID);
    else
        --引导结束
        GuideSystem.GuideOver();
    end
end)


function GuideSystem.GuideOver(delsave)
    if delsave == nil then delsave = true end
    if delsave then
        GuideSystem.DelGuideingSave();
        if not GuideSystem.forceGuiding and not GuideSystem.AlGuideIDs().Contains(GuideSystem.curMainID) then
            GuideSystem.AddAlGuideID(GuideSystem.curMainID);
        end
    end

    CS.UILuaWindowBase.HideWindow("UI_Guide");
    print("引导结束 curMainID:" + curMainID);
    GuideSystem.curMainID = 0;
    GuideSystem.guiding = false;
    GuideSystem.forceGuiding = false;
    CS.GameMsgHint.inst.CanClickScreen(true);
end

function GuideSystem.AddGuideingSave()
    CS.PlayerPrefs.SetInt(GuideSystem.SaveGuideingMainID(), GuideSystem.curMainID);
end

function GuideSystem.DelGuideingSave()
    if CS.PlayerPrefs.HasKey(GuideSystem.SaveGuideingMainID()) then
        CS.PlayerPrefs.DeleteKey(GuideSystem.SaveGuideingMainID());
    end
end

function GuideSystem.PlayGuideingSave()
    local mainID =  CS.PlayerPrefs.GetInt(GuideSystem.SaveGuideingMainID())
    if mainID ~= 0 then
        if CS.GameDriver.inst.guideClose then
            GuideSystem.GuideOver();
            return false;
        end
        local teachCfg = CS.TeachconfigManager.Instance().GetConfigList(mainID);
        if teachCfg ~= nil then
            if GuideSystem.curMainID ~= 0 then
                GuideSystem.GuideOver();
                return false;
            end
            GuideSystem.curMainID = mainID;
            GuideSystem.curGuideList = teachCfg;
            GuideSystem.NextGuide();
            return true;
        else
            return false
        end
    end
    return false;
end