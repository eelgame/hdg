---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yzc.
--- DateTime: 2018/9/5 15:53
--- CellLink管理类
---

CellLinkSystem = {}
CellLinkSystem.__index = CellLinkSystem
CellLinkSystem.className = "CellLinkSystem"

function CellLinkSystem.getInstance()
   return BaseSystem.getInstance(CellLinkSystem)
end


function CellLinkSystem.AddListeners()
    Event.AddListener(tostring(MsgTypeCmd.GC_GetChainAddressRspd), CellLinkSystem.GetChainAddress)
end

function CellLinkSystem.RemoveListeners()

    Event.RemoveListener(tostring(MsgTypeCmd.GC_GetChainAddressRspd), CellLinkSystem.GetChainAddress)
end

function CellLinkSystem:OnEnter()
    CellLinkSystem.AddListeners()
    CellLinkSystem.m_kCLB = CS.CellLinkEx.IxCellLinkBridge.LuaCall();
    --CellLinkSystem.InitializeRPCClient()
end
function CellLinkSystem:OnUpdate()
    CellLinkSystem.RemoveListeners()
end


CellLinkSystem.m_kCLB = nil;
CellLinkSystem.Host = nil
CellLinkSystem.iPort =nil
CellLinkSystem.User = nil;
CellLinkSystem.Pwd = nil;
CellLinkSystem.TokenContractAddress = nil
CellLinkSystem.masterKey = nil
CellLinkSystem.masterKeyName = nil
CellLinkSystem.pathKey = nil
CellLinkSystem.rawAddress = nil

--合约币的数量
CellLinkSystem.Coin = tostring(0);
--区块链是否连接
CellLinkSystem.IsConnect = false;

function CellLinkSystem.GetCoin()
      return CellLinkSystem.Coin
end

---初始化RPC
function  CellLinkSystem.InitializeRPCClient()

--[[
    if CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.Android or CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.IPhonePlayer then
         strHost = "http://47.100.203.230";
         iPort = 9202;
        CellLinkSystem.TokenContractAddress = "mx4ftQ4ybTU4xdDCVBZxgx5N5MnSAqzFdB"
    else
         strHost = "http://172.16.64.55";
         iPort = 9201;
        CellLinkSystem.TokenContractAddress = "mvJRqHX4nLUxFyya2cbsuSr6rwEKfRjRLi"
    end

    local strUser = "user";
    local strPwd = "pwd";
    ]]
    local eNT = CS.CellLinkEx.NETWORK_TYPE.TEST_NET;

    print("Initialize RPC client: " ..CellLinkSystem.Host.. ":" ..tostring(CellLinkSystem.iPort))
    local Host = "http://"..CellLinkSystem.Host
    local bRet = CellLinkSystem.m_kCLB:Initialize(Host, CellLinkSystem.iPort, CellLinkSystem.User, CellLinkSystem.Pwd, eNT);

    if bRet == false then
        print("Initialize RPC client failed!", "red")
    else
        print("Initialize RPC client succeed.")
    end
end

---创建根私钥,游戏第一阶段不开放给用户，只是内部使用，所以名字随机生成
function CellLinkSystem.CreateMasterKey(MasterKeyName)
    local strMasterKeyName
    if MasterKeyName ~= nil then
        strMasterKeyName= MasterKeyName
        if CellLinkSystem.m_kCLB.m_mapMKI:ContainsKey(strMasterKeyName) == true then
            print("根密钥名已存在,请重新创建")
            return
        end
    else
        strMasterKeyName = CellLinkSystem.m_kCLB:NewMasterName()
    end

    print(strMasterKeyName)

    local strMasterKey = CellLinkSystem.m_kCLB:CreateMasterExtKey(strMasterKeyName);

    if strMasterKey == nil or strMasterKey == "" then
        print("Create master key failed!", "red");
        return
    end
    --    print("New master key: " .. strMasterKey);
    --    print("Name: " .. strMasterKeyName);
    return strMasterKeyName,strMasterKey

end

function CellLinkSystem.ImportMasterKey(strMasterKey,MasterKeyName)
    local strKey = strMasterKey;

    if strMasterKey == nil or strMasterKey == "" then
        print("导入根密钥为空")
        return;
    end

    if MasterKeyName == nil or MasterKeyName == "" then
        print("导入根密钥名为空")
        return;
    end

    if  CellLinkSystem.m_kCLB:ImportMasterExtKey(MasterKeyName, strKey) then

        print("Import new master key succeed."..strMasterKey.."Name:"..MasterKeyName)
    end
end


---生成新的真实地址并加密成MCL，keypath可选，不输入则随机产生新的地址，否则根据keypath得到指定地址
---MCL <=> 真实地址+keypath+根私钥名（strMasterKeyName）
function CellLinkSystem.NewCLAddress(strMasterKeyName,strPath)
    local strCLAddress;--这个暂时没用，因为在服务器端需要我们自己实现解析..太麻烦，直接传三个参数就好了

    if strPath == nil or strPath == "" then
        print("strPath为空")
        strCLAddress = CellLinkSystem.m_kCLB:GenerateNewMCLAddress(strMasterKeyName);
    else
        print("strPath :" ..strPath)
        local strCelAddress = CellLinkSystem.m_kCLB:GetCelAddressByPath(strMasterKeyName, strPath);
        if strCelAddress == nil or strCelAddress == "" then
            print("GetCelAddressByPath error, path: ".. strPath);
            return
        end
        strCLAddress = CellLinkSystem.m_kCLB:EncodeMCLAddress(strMasterKeyName, strPath, strCelAddress);
    end

    if strCLAddress == nil or strCLAddress == "" then
        print("Generate new MCL address error!");
        return;
    end

    local strName;
    local strBTAddress;

    local returnValue,rstrName,rstrPath,rstrBTAddress = CellLinkSystem.m_kCLB:DecodeMCLAddress(strCLAddress)
   -- print("returnValue"..returnValue)
    --[[
     print("rstrName :"..rstrName)
     print("rstrPath :"..rstrPath)
     print("rstrBTAddress :"..rstrBTAddress)
     print("strCLAddress :"..strCLAddress)
     ]]
     if returnValue == true then
         strName = rstrName
         strPath = rstrPath
         strBTAddress = rstrBTAddress

         local kEKey = CellLinkSystem.m_kCLB:GetExtKeyByPath(strMasterKeyName, strPath);
         local strPriKey = kEKey.PrivateKey:GetWif(CellLinkSystem.m_kCLB.network):ToWif();

         print("Generate new MCL address succeed.");
     end

     return strCLAddress,rstrPath,rstrBTAddress
 end

 ---解析CLAddress
 function CellLinkSystem.BTA(strCLAddress)

     local strName;
     local strBTAddress;
     local strPath;
     local returnValue,rstrName,rstrPath,rstrBTAddress = CellLinkSystem.m_kCLB:DecodeMCLAddress(strCLAddress)
     if returnValue == true then
         strName = rstrName
         strPath = rstrPath
         strBTAddress = rstrBTAddress

         local kEKey = CellLinkSystem.m_kCLB:GetExtKeyByPath(strMasterKeyName, strPath);
         local strPriKey = kEKey.PrivateKey.GetWif(CellLinkSystem.m_kCLB.network).ToWif();

         print("Generate new MCL address succeed.");
     end
 end

 ---查询余额（Celllink的币），参数：真实的区块链地址
 function CellLinkSystem.Query(fBTAddr)
     local fV = CellLinkSystem.m_kCLB:GetBalanceByCelAddress(fBTAddr);
     print("Balance: ".. fV);
 end

 ---转账（Celllink的币）
 function CellLinkSystem.Transfer(strDestBTAddress,strChangeBTAddress,fMoney,PriKey)
     local returnValue,strTxid = CellLinkSystem.m_kCLB.TransferRaw(PriKey, strDestBTAddress, fMoney, -1.0, strChangeBTAddress)
     if returnValue then
         --交易ID
         print("Transfer succeed, txid: " + strTxid, "#80FF80");
     else
         print("Transfer failed!");
     end
 end

 ---服务器检测此账号是否存在（第一阶段）钱包
 function CellLinkSystem.GetChainAddress(...)
     local	rspd=MsgType.GCGetChainAddressRspd:New(...)

     CellLinkSystem.Host = rspd.rpcHost
     CellLinkSystem.iPort = rspd.rpcPort
     CellLinkSystem.User =  rspd.rpcUser
     CellLinkSystem.Pwd =  rspd.rpcPwd
     CellLinkSystem.TokenContractAddress = rspd.contractAddress

     CellLinkSystem.InitializeRPCClient()
     if rspd.rawAddress=="" then
         print("此账号不存在地址，需要生成新地址")
         local strMasterKeyName,strMasterKey = CellLinkSystem.CreateMasterKey(CellLinkSystem.masterKeyName)
         local strCLAddress,rstrPath,rstrBTAddress = CellLinkSystem.NewCLAddress(strMasterKeyName,CellLinkSystem.pathKey)

         local SaveChainAddress = MsgType.CGSaveChainAddressRqst:New()
         SaveChainAddress.masterKey = strMasterKey
         SaveChainAddress.masterKeyName = strMasterKeyName
         SaveChainAddress.pathKey = rstrPath
         SaveChainAddress.rawAddress = rstrBTAddress
         SaveChainAddress:Send()

         CellLinkSystem.masterKey = strMasterKey
         CellLinkSystem.masterKeyName = strMasterKeyName
         CellLinkSystem.pathKey = rstrPath
         CellLinkSystem.rawAddress = rstrBTAddress
         local arrArgs= {rstrBTAddress}
         --CellLinkSystem.ImportMasterKey(strMasterKey,strMasterKeyName)

     else
         --[[
         print("已经存在区块链地址")
         print("rawAddress: "..rspd.rawAddress)
         print("masterKey: "..rspd.masterKey)
         print("pathKey: "..rspd.pathKey)
         print("masterKeyName: "..rspd.masterKeyName)
         ]]
        CellLinkSystem.masterKey = rspd.masterKey
        CellLinkSystem.masterKeyName = rspd.masterKeyName
        CellLinkSystem.pathKey = rspd.pathKey
        CellLinkSystem.rawAddress = rspd.rawAddress

        CellLinkSystem.ImportMasterKey(rspd.masterKey,rspd.masterKeyName)
    end
end

--TODO 调用智能合约
---
---@param bSendCall bool 是否是SendCall类型交易，SendCall是需要广播的交易类型，要花费少量币，Call不用（只能用于非交易指令）
---@param strContractAddress string 合约地址
---@param CostKeyName string 花费密钥名
---@param CostKeyPath string 花费密钥keypath，（因为使用的非对称密钥为椭圆算法，所以可以通过私钥计算出公钥，从而计算出地址，所以只传私钥就行了）
---@param fCostAmount uint 交易金额，不要填0
---@param SenderKeyName string 合约密钥名
---@param SenderKeyPath string 合约密钥keypath
---@param strFuncName string 调用合约中方法的方法名
---@param arrArgs table 参数表
---@param strChargeBTAddress string 找零地址（为nil时，找零地址就是花费地址）
---@param strChargeBTAddress msgbox 失败时是否弹出窗口
--[[
function CellLinkSystem.CallContractFunction(bSendCall, strContractAddress, CostKeyName,CostKeyPath, fCostAmount, SenderKeyName,SenderKeyPath,strFuncName, arrArgs, strChargeBTAddress,msgbox)
    local CostPrivateKey = CellLinkSystem.m_kCLB:GetExtKeyByPath(CostKeyName,CostKeyPath)
    local SenderPrivateKey = CellLinkSystem.m_kCLB:GetExtKeyByPath(SenderKeyName,SenderKeyPath)
    local ret = CellLinkSystem.m_kCLB:CallContractFunction(bSendCall, strContractAddress, CostPrivateKey.PrivateKey, fCostAmount, SenderPrivateKey.PrivateKey, strFuncName,CS.XluaUtils.LuaTableToArr(arrArgs) , strChargeBTAddress)

    CellLinkSystem.IsConnect = true
    if  ret == nil then

       CellLinkSystem.IsConnect = false
        if msgbox ~= false then
            CS.GameMsgHint.inst:ShowOKMsgBox("区块链连接失败",nil,true)
        end
       return false
    end
    print("CallContractFunction ret  : " .. ret);
    return ret
end]]


function CellLinkSystem.Connect()

end
