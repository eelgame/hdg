---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by admin.
--- DateTime: 2018/7/13 10:48
---\
TestYzc = {}
TestYzc.path = "file:///"..CS.UnityEngine.Application.persistentDataPath.."/".."shareImage.jpg";
TestYzc.path1 = CS.UnityEngine.Application.persistentDataPath.."/";
TestYzc.path2 = CS.UnityEngine.Application.persistentDataPath.."/".."sssdddd.jpg";
--print("YZCTesting.......")
function TestYzc.TestUnZip()
    CS.SDKManager.inst:SDKLog("mmmmmmmmm")
end

function TestYzc.GetImage()
    local www =  CS.UnityEngine.WWW(TestYzc.path)
    while (not www.isDone) do

    end
    CS.SDKManager.inst:SDKLog(www)
    if www ~= nil then
        CS.SDKManager.inst:SDKLog("wwwwwwcunzai")
    end
    CS.SDKManager.inst:SDKLog("getImage!!!!!!!!!!! : " .. www.texture.height)
    return  www.texture
end

if false then
    local tx = CS.UnityEngine.Texture2D(100, 100);

    local files = CS.System.IO.FileStream(TestYzc.path, CS.System.IO.FileMode.Open);
    print(files)
    local byte1 = CS.XluaUtils.GetByteArray(files.Length)
    print(byte1.Length)
    files:Read(byte1, 0, byte1.Length);
    print(byte1.Length)
    files:Close();
    tx:LoadImage(byte1);
    print(tx)
end

if false then
    print(TestYzc.path1)
    print(CS.System.IO.Directory.Exists(TestYzc.path1))

    local ss  =  CS.System.IO.DirectoryInfo(TestYzc.path1);
    --print("ss"..ss)
    print(ss:GetFiles().Length)
    for i = 1, ss:GetFiles().Length do
        print(ss:GetFiles()[i-1].Name)
    end
    local www =  CS.UnityEngine.WWW(TestYzc.path)
    print(www)
    while (not www.isDone) do

    end
    CS.SDKManager.inst:SDKLog("GetImage!!!!!!!!!!! ：  " .. www.texture.height)
end


if false then
    try{
        function()
           error("error message")
        end
    ,
        {
            catch =
                function(errors)
                    print("errors : "..errors)
                end
        ,
            finally =
                function(ok,errors)
                    print(ok)
                    print(errors)
                end
        }
  }
end




if false then
    --lua协程
    local co1 = coroutine.wrap(function (a,b)
        local yreturn = coroutine.yield("kkkk")
        print("yreturn"..yreturn)
    end)
    print(co1(1,2))
    print(co1(23,34))

    os.time()
    local co = coroutine.create(function ()
        local yreturn = coroutine.yield(os.time())
    end)
    local co2 =  coroutine.wrap(function ()
        local result,value =  coroutine.resume(co)
        print("第一次协程挂起"..tostring(value))
        local time = os.clock()
        for i = 1, 10000 do
            if os.time() - value >= 2 then
                print("第二次协程挂起"..tostring(coroutine.resume(co)))
                print(time.."  :  "..os.clock())
                break
            end
            print(i.." :"..os.time().."-"..value)
        end
    end)

    co2()

end

--luaCallC#，xlua在c#侧实现的对于C#类的构造（函数同理）
if false then

    local yzctest = CS.YZCTest
    local type =  typeof(CS.YZCTest)


end

--print(MyType(CS.YZCTest))
--print(MyType(CS.YZCTest.GetInstance()))
--弱表               2018/8/6
--1.关于‘#’的一些问题
--（1）获得的长度为value的数量，和key无关，因为任意没有value的key都是nil.
--（2）长度只限于key为非引用类型，引用类型的key不算入长度内
--（3）gc后，对于所有无引用的对象都不算入长度。引用类型对象因为会自动gc没问题，但是值类型和string这种没有显示构造的类型不会被weak表移除，其中string会被回收但不会移除，值类型不会回收。
--这样会造成可以读到value却不算长度
--2.对于表的回收，设置为nil就会自动gc，对于强表，即使作为key的引用=nil，但是用for还是可以遍历出key-value，弱表就会直接为nil
--3.弱表之v，k，kv三种方式的区别。
--（1）value，只有引用类型被回收，这时弱表只会移除引用类型的值，这时通过key找value（相当于key-value都被移除了）
--（2）key，弱key直接回收key，会导致weak中通过key所有的value都找不到（相当于key-value都被移除了），但实际上value并没有被gc，如果value在其他地方还保留引用，那么是可以使用
--（3）key-value，任意一个被回收，键值对就会被从表中移除。如果只有一个没有被引用。只会gc回收没有引用的那个，另一个不会被回收。
--看起来这三个区别不大，其实还有有的


--弱Key测试
if false then

t = {}
setmetatable(t,{__mode = "k"})
a = {name = "a"}
b = {name = "b"}

t[a] = {value = "va"}
t[b] = {value = "vb"}
for k,v in pairs(t) do
    print("1"..k.name.." : "..v.value)
end
a = nil
b = nil
collectgarbage()
for k,v in pairs(t) do
    print("2"..k.name.." : "..v.value)
end

end
--弱value测试
if false then

weakTable = {}
local a = {}
local b = {}
local c = {}
weakTable[a] = function() print("a  weak1") end
weakTable[b] = function() print("a  weak2") end
weakTable[c] = 1
weakTable[1] = function() print("1  weak1") end
weakTable[2] = "nihao"
weakTable[3] = 1
setmetatable(weakTable,{__mode = "v"})
--setmetatable(weakTable,{__mode = "k"})
--setmetatable(weakTable,{__mode = "kv"})
print("初始长度"..#weakTable)
ele = weakTable[a]
print("a1",weakTable[a])
--让table可回收
--a = nil
--b = nil
--c = nil
collectgarbage()
print("a",weakTable[a])
print("b",weakTable[b])
print("c",weakTable[c])
print("1",weakTable[1])
print("2",weakTable[2])
print("3",weakTable[3])
print("4",weakTable[4])
print("d",weakTable[d])
print("清理后长度"..#weakTable)

print("ele",ele)

end
--弱表的用法
--1.弱key的用法，key分为两种，值类型和引用类型，值类型不需要回收，所以重点在于引用类型key的玩法。
--（1）附加属性，针对某个对象的附加属性，比如给某个table编号，但是并不想因为我在监控它的编号这一个引用让它不会被gc回收，于是以对象为key的弱表可以解决问题。
--（2）table的默认值，比如有一个水果表，我需要它的默认属性（类型=水果，是否能吃 = 能吃），当我没有给它赋值任何其他表引用的情况下这两属性我都需要。这时做一个全局的默认弱key表，
--在初始化时，给水果表设置Get默认表中值的元方法为__index。这样给了它元表作为默认属性，如果不需要这个默认属性，就会被gc掉
if false then

local defaults = {}
--setmetatable(defaults ,{__mode = "k"})
    setmetatable(defaults ,{__mode = "kv"})
local mt = {__index = function (t)return defaults[t] end}
    local function setDefault(t,d)
        defaults[t] = d
        setmetatable(t,mt)
    end

    b = {a = "111",b = "222",c = "333"}
    a = {}
    print("第0次"..collectgarbage("count"))
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第01次"..collectgarbage("count"))
    local dasdsadsadsda = {}
    for i = 1, 5000 do
        table.insert(dasdsadsadsda,{})
    end
   -- setDefault(a,b)
   setDefault(a,c)
   -- print(b)
   -- print((a.a).a)
    --print(defaults[a])
    --c = defaults[a]
    print("第一次"..collectgarbage("count"))
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第二次gc回收"..collectgarbage("count"))

    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第三次gc回收"..collectgarbage("count"))
    --a = {}
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第四次gc回收"..collectgarbage("count"))
    --a=nil
    --b= nil
    --c= nil
    dasdsadsadsda = nil
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第五次gc回收"..collectgarbage("count"))
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第五次gc回收"..collectgarbage("count"))
    collectgarbage("collect")--显式回收内存（没有被引用的局部变量）
    print("第五次gc回收"..collectgarbage("count"))
    collectgarbage("step")--显式回收内存（没有被引用的局部变量）
    print("第五次gc回收"..collectgarbage("count"))
    --print(c)

end


--Lua 字典  传的是两个类型（可以是c#，也可以是lua类型）未完待续..
if false then

    dic =  Dictionary:New(sint,CS.YZCTest)
    dic:Add(10,CS.YZCTest.GetInstance())
    dic:Add(11,CS.YZCTest.GetInstance())

    local dic =  Dictionary:New(sint,CS.YZCTest)


    yzctest.GetDictionary(dic)

end

--Lua的闭包..参考Java就好了
if false then
    function Close()
        local i = 0
        return function ()
            i = i+1
            print(i)
        end
    end

    c1 = Close()
    c2 = Close()
    c1()
    c1()
    c2()
    c2()
end

--List测试
if false then
list = List:New("suibiao")
list:Add(1)
list:Add(4)
list:Add(6)
list:Add(4)
list:Add("8")

print("长度"..list:Count())
end


--TestY = CS.DelegateToLua:TestClass()
--print(TestY:TestInt())

--C#数组交互的测试
if false then
    arr =  CS.DelegateToLua.TestMy()
    for i = 1, arr.Length do
        print(arr[i-1])
    end
end

--元表练习
if false then
    require("MyTest/TestYzcBase")
    yzctest = {}
    yzctest.__index = yzctest;
    function yzctest:New()
        local base =  Base:New()
        setmetatable(yzctest,getmetatable(base))
        tb = {}
        setmetatable(tb,yzctest)
        return tb;
    end

    class3 = {}
    class3.__index = class3;
    function class3:New()
        local  base =  yzctest:New()
        setmetatable(class3,getmetatable(base))
        tb = {}
        setmetatable(tb,class3)
        return tb;
    end

    function yzctest.Test()
        print("yzctest")
    end
    yzc = class3:New()
    yzc.Test()
    yzc.Test1()
end


-- 事件机制的测试Tests
if false then

    local EventLib = require "Common.eventlib"
    _M = EventLib._M
    local e = _M:new("test")
    local f = function(...)
        print("| Fired!", ...)
        arg = {...}
        for k, v in pairs(arg) do
            if k > 1 then
                for i,m in pairs(v)do
                    print(i,":",m)
                end
            end
        end
    end
    local e2 = e:connect(f)
    e:fire("arg1", 5, { })
    -- Would work in a ROBLOX Script, but not on Lua 5.1...
    if script ~= nil and failhorribly then
        EventLib.spawn(function() print("Wait() results", e:wait()) print"|- done waiting!" end)
    end
    e:fire(nil, "x")
    print("Disconnected events index:", e:disconnect(f))
    print("Couldn't disconnect an already disconnected handler?", e2:disconnect()==nil)
    print("Connections:", e:ConnectionCount())
    assert(e:ConnectionCount() == 0 and e:ConnectionCount() == #e.handlers)
    e:connect(f)
    e:connect(function() print"Throwing error... " error("123") end)
    e:fire("Testing throwing an error...")
    e:disconnect()
    e:Simulate()
    f("plain function call")
    assert(e:ConnectionCount() == 0)
    if wait then
        e:connect(function() wait(2, true) print'fired after waiting' end)
        e:Fire()
        e:WaitForCompletion()
        print'Done!'
    end

    local failhorribly = false
    if failhorribly then -- causes an eternal loop in the WaitForCompletion call
        e:connect(function() e:WaitForCompletion() print'done with connected function' end)
        e:Fire()
        print'done'
    end

    e:Destroy()
    assert(not e.EventName and not e.Fire and not e.Connect)
end

--对luaclass的测试.
--需要注意的点：此继承并不是真的继承
if  false then
    local Test = class("test");

    function Test:Ctor(shapeName)
        self.shapeName = shapeName
        print("Shape:Ctor(%s)", self.shapeName)
    end
    local a = {1,2,3}
    function Test:fun()
        print("Testfun",#a)

    end
    --function a:fun()
    --    print("afun")

    --end
    local b = {};
    b.__index = a;
    local TestSub = class("TestSub",Test)
    setmetatable(TestSub,b)

    function TestSub:Ctor()
        TestSub.super.Ctor(self, "TestSub")
    end

    --TestSub:New()
    --getmetatable(TestSub).fun();
    --TestSub:fun();
    function TestSub.fun()
        print("TestSub")

    end
end

--TestSub.super.fun();
--TestSub.fun();
--index的练习
--[[
Test = {a = 1,b = 2}
Testa = {c = 3};
Testc = {d = 4};

function Testc:fun1()
    print("a de fun1!!!")
end

Testa.__index = Testc;
setmetatable(Test,Testa)
local fun =  Test.fun1;
fun()
function Testc:new(o)
    o = o or{}
    print("new")
    setmetatable(o,self)
    return o;

end

Test.__index = function(table ,key)
    print("_index")
    return Test[key]
end


local Testb = Test:new()
print(getmetatable(Testb))
print(Testb.a)
--Testb.fun1();
]]

--[[
function Test:fun1()
    print("fun1",self.a,self.b);
end

function Test.fun2(test)
    print("fun2",test.a,test.b);
end

Test.fun3 = function(test)
    print("fun3",test.a,test.b);
end


Testb.testb = Test.fun1;
--local test = Test.new();
Test:fun1();
Testb.testb(Test);
]]
--Test:fun2();
--Test.fun1();
--Test.fun2(Test);
--Test.fun3(Test);


