local JSON = require("Libs.json.json4lua")
local MsgIndex = 0
local function IncKeyMsgSeq()
    MsgIndex = MsgIndex + 1
    return MsgIndex
end
MsgType = {}
MsgTypeCmd = {}

local BASE_CMD = 0
MsgTypeCmd.PROTO_VERSION = 2019071201
MsgTypeCmd.CG_TestRqst = BASE_CMD + 1
MsgTypeCmd.GC_TestRspd = BASE_CMD + 2
MsgTypeCmd.CG_KEEP_ALIVE = BASE_CMD + 3
MsgTypeCmd.GC_ECHO_KEEPALIVE = BASE_CMD + 4
MsgTypeCmd.GCPlayerKicked_CMD = BASE_CMD + 5
MsgTypeCmd.CG_LoginCheckRqst = BASE_CMD + 20
MsgTypeCmd.GC_LoginCheckRspd = BASE_CMD + 21
MsgTypeCmd.CG_EnterCopyMapRqst = BASE_CMD + 22
MsgTypeCmd.GC_EnterCopyMapRspd = BASE_CMD + 23
MsgTypeCmd.CG_LbsMapGetListRqst = BASE_CMD + 100
MsgTypeCmd.GC_LbsMapGetListRspd = BASE_CMD + 101
MsgTypeCmd.CG_LbsMapRefreshListRqst = BASE_CMD + 102
MsgTypeCmd.GC_LbsMapRefreshListRspd = BASE_CMD + 103
MsgTypeCmd.CG_LbsMapGetStepInfoRqst = BASE_CMD + 104
MsgTypeCmd.GC_LbsMapGetStepInfoRspd = BASE_CMD + 105
MsgTypeCmd.CG_LbsMapUploadStepRqst = BASE_CMD + 106
MsgTypeCmd.GC_LbsMapUploadStepRspd = BASE_CMD + 107
MsgTypeCmd.CG_LbsMapUploadLocationRqst = BASE_CMD + 108
MsgTypeCmd.GC_LbsMapUploadLocationRspd = BASE_CMD + 109
MsgTypeCmd.CG_LbsMapStepRewardRqst = BASE_CMD + 110
MsgTypeCmd.GC_LbsMapStepRewardRspd = BASE_CMD + 111
MsgTypeCmd.CG_EventGetListRqst = BASE_CMD + 120
MsgTypeCmd.GC_EventGetListRspd = BASE_CMD + 121
MsgTypeCmd.CG_EventSubmitRqst = BASE_CMD + 124
MsgTypeCmd.GC_EventSubmitRspd = BASE_CMD + 125
MsgTypeCmd.CG_EventResetRqst = BASE_CMD + 126
MsgTypeCmd.GC_EventResetRspd = BASE_CMD + 127
MsgTypeCmd.CG_EventSelectRqst = BASE_CMD + 128
MsgTypeCmd.GC_EventSelectRspd = BASE_CMD + 129
MsgTypeCmd.CG_EventFriendDegreeRqst = BASE_CMD + 130
MsgTypeCmd.GC_EventFriendDegreeRspd = BASE_CMD + 131
MsgTypeCmd.CG_EventSweepRqst = BASE_CMD + 132
MsgTypeCmd.GC_EventSweepRspd = BASE_CMD + 133
MsgTypeCmd.CG_EventGetFeelingRqst = BASE_CMD + 134
MsgTypeCmd.GC_EventGetFeelingRspd = BASE_CMD + 135
MsgTypeCmd.CG_EventFeelingRewardRqst = BASE_CMD + 136
MsgTypeCmd.GC_EventFeelingRewardRspd = BASE_CMD + 137
MsgTypeCmd.CG_EventResetTimesRqst = BASE_CMD + 138
MsgTypeCmd.GC_EventResetTimesRspd = BASE_CMD + 139
MsgTypeCmd.CG_GetLevelInfoRqst = BASE_CMD + 140
MsgTypeCmd.GC_GetLevelInfoRspd = BASE_CMD + 141
MsgTypeCmd.CG_CopyTeamRqst = BASE_CMD + 142
MsgTypeCmd.GC_CopyTeamRspd = BASE_CMD + 143
MsgTypeCmd.CG_UseItemRqst = BASE_CMD + 144
MsgTypeCmd.GC_UseItemRspd = BASE_CMD + 145
MsgTypeCmd.CG_GetLevelListRqst = BASE_CMD + 146
MsgTypeCmd.GC_GetLevelListRspd = BASE_CMD + 147
MsgTypeCmd.CG_FriendGetFriendListRqst = BASE_CMD + 150
MsgTypeCmd.GC_FriendGetFriendListRspd = BASE_CMD + 151
MsgTypeCmd.CG_FriendOptRqst = BASE_CMD + 152
MsgTypeCmd.GC_FriendOptRspd = BASE_CMD + 153
MsgTypeCmd.CG_FriendGetEquipModelRqst = BASE_CMD + 154
MsgTypeCmd.GC_FriendGetEquipModelRspd = BASE_CMD + 155
MsgTypeCmd.CG_FriendGetApDataRqst = BASE_CMD + 156
MsgTypeCmd.GC_FriendGetApDataRspd = BASE_CMD + 157
MsgTypeCmd.CG_FansGetFansListRqst = BASE_CMD + 158
MsgTypeCmd.GC_FansGetFansListRspd = BASE_CMD + 159
MsgTypeCmd.CG_MailGetListRqst = BASE_CMD + 160
MsgTypeCmd.GC_MailGetListRspd = BASE_CMD + 161
MsgTypeCmd.CG_MailReadRqst = BASE_CMD + 162
MsgTypeCmd.GC_MailReadRspd = BASE_CMD + 163
MsgTypeCmd.CG_MailPickAttachmentRqst = BASE_CMD + 164
MsgTypeCmd.GC_MailPickAttachmentRspd = BASE_CMD + 165
MsgTypeCmd.CG_MailDeleteRqst = BASE_CMD + 166
MsgTypeCmd.GC_MailDeleteRspd = BASE_CMD + 167
MsgTypeCmd.GC_ChatSrvInfoRspd = BASE_CMD + 180
MsgTypeCmd.CG_ChatChgChannelRqst = BASE_CMD + 181
MsgTypeCmd.GC_ChatChgChannelRspd = BASE_CMD + 182
MsgTypeCmd.CG_ChatChannelInfoRqst = BASE_CMD + 183
MsgTypeCmd.GC_ChatChannelInfoRspd = BASE_CMD + 184
MsgTypeCmd.CG_PeekPlayerInfoRqst = BASE_CMD + 185
MsgTypeCmd.GC_PeekPlayerInfoRspd = BASE_CMD + 186
MsgTypeCmd.CG_PetGetRoomListRqst = BASE_CMD + 200
MsgTypeCmd.GC_PetGetRoomListRspd = BASE_CMD + 201
MsgTypeCmd.CG_PetGetPetListRqst = BASE_CMD + 202
MsgTypeCmd.GC_PetGetPetListRspd = BASE_CMD + 203
MsgTypeCmd.CG_PetOptRqst = BASE_CMD + 204
MsgTypeCmd.GC_PetOptRspd = BASE_CMD + 205
MsgTypeCmd.CG_ShopGetSampleListRqst = BASE_CMD + 220
MsgTypeCmd.GC_ShopGetSampleListRspd = BASE_CMD + 221
MsgTypeCmd.CG_ShopGetGoodsListRqst = BASE_CMD + 222
MsgTypeCmd.GC_ShopGetGoodsListRspd = BASE_CMD + 223
MsgTypeCmd.CG_ShopGetVipCardListRqst = BASE_CMD + 224
MsgTypeCmd.GC_ShopGetVipCardListRspd = BASE_CMD + 225
MsgTypeCmd.CG_ShopBuyGoodsRqst = BASE_CMD + 226
MsgTypeCmd.GC_ShopBuyGoodsRspd = BASE_CMD + 227
MsgTypeCmd.CG_RedTipGetDataRqst = BASE_CMD + 240
MsgTypeCmd.GC_RedTipGetDataRspd = BASE_CMD + 241
MsgTypeCmd.CG_RedTipClearTipRqst = BASE_CMD + 242
MsgTypeCmd.GC_RedTipClearTipRspd = BASE_CMD + 243
MsgTypeCmd.CG_PayActivityRqst = BASE_CMD + 250
MsgTypeCmd.GC_PayActivityRspd = BASE_CMD + 251
MsgTypeCmd.CG_PayListRqst = BASE_CMD + 252
MsgTypeCmd.GC_PayListRspd = BASE_CMD + 253
MsgTypeCmd.CG_PayItemShopBuyRqst = BASE_CMD + 254
MsgTypeCmd.GC_PayItemShopBuyRspd = BASE_CMD + 255
MsgTypeCmd.CG_PayOrderRqst = BASE_CMD + 256
MsgTypeCmd.GC_PayOrderRspd = BASE_CMD + 257
MsgTypeCmd.CG_PayBalanceRqst = BASE_CMD + 258
MsgTypeCmd.GC_PayBalanceRspd = BASE_CMD + 259
MsgTypeCmd.GC_PaySuccessRspd = BASE_CMD + 260
MsgTypeCmd.CG_DanceBallGetBallListRqst = BASE_CMD + 270
MsgTypeCmd.GC_DanceBallGetBallListRspd = BASE_CMD + 271
MsgTypeCmd.CG_DanceBallGetServerInfoRqst = BASE_CMD + 272
MsgTypeCmd.GC_DanceBallGetServerInfoRspd = BASE_CMD + 273
MsgTypeCmd.CG_MapGetInfoRqst = BASE_CMD + 280
MsgTypeCmd.GC_MapGetInfoRspd = BASE_CMD + 281
MsgTypeCmd.CG_MapRollDiceRqst = BASE_CMD + 282
MsgTypeCmd.GC_MapRollDiceRspd = BASE_CMD + 283
MsgTypeCmd.GC_MapUpgradeRspd = BASE_CMD + 284
MsgTypeCmd.GC_SrvNotifyRspd = BASE_CMD + 300
MsgTypeCmd.CG_BlackMarketGetGoodsListRqst = BASE_CMD + 301
MsgTypeCmd.GC_BlackMarketGetGoodsListRspd = BASE_CMD + 302
MsgTypeCmd.CG_BlackMarketBuyGoodsRqst = BASE_CMD + 303
MsgTypeCmd.GC_BlackMarketBuyGoodsRspd = BASE_CMD + 304
MsgTypeCmd.CG_BlackMarketRetryGameRqst = BASE_CMD + 305
MsgTypeCmd.GC_BlackMarketRetryGameRspd = BASE_CMD + 306
MsgTypeCmd.CG_BlackMarketReturnDiscountRqst = BASE_CMD + 307
MsgTypeCmd.GC_BlackMarketReturnDiscountRspd = BASE_CMD + 308
MsgTypeCmd.CG_SpecialBuyRqst = BASE_CMD + 309
MsgTypeCmd.GC_SpecialBuyRspd = BASE_CMD + 310
MsgTypeCmd.GC_GoldenHandInfoRspd = BASE_CMD + 311
MsgTypeCmd.CG_NewFeedbackRqst = BASE_CMD + 312
MsgTypeCmd.GC_NewFeedbackRspd = BASE_CMD + 313
MsgTypeCmd.CG_SyncWebServerInfoRqst = BASE_CMD + 25
MsgTypeCmd.GC_SyncWebServerInfoRspd = BASE_CMD + 26
MsgTypeCmd.CG_KeepAliveRqst = BASE_CMD + 27
MsgTypeCmd.GC_KeepAliveRspd = BASE_CMD + 28
MsgTypeCmd.CG_RegisterAccountRqst = BASE_CMD + 30
MsgTypeCmd.GC_RegisterAccountRspd = BASE_CMD + 31
MsgTypeCmd.CG_AccountRqst = BASE_CMD + 6
MsgTypeCmd.GC_AccountRspd = BASE_CMD + 7
MsgTypeCmd.CG_LoginRqst = BASE_CMD + 32
MsgTypeCmd.GC_LoginRspd = BASE_CMD + 33
MsgTypeCmd.CG_CreateRoleRqst = BASE_CMD + 34
MsgTypeCmd.GC_CreateRoleRspd = BASE_CMD + 35
MsgTypeCmd.GC_RoleBriefInfoRspd = BASE_CMD + 36
MsgTypeCmd.GC_EquipInfoRspd = BASE_CMD + 37
MsgTypeCmd.CG_RoleCoverRqst = BASE_CMD + 8
MsgTypeCmd.GC_RoleCoverRspd = BASE_CMD + 9
MsgTypeCmd.CG_GetRoleDataRqst = BASE_CMD + 10
MsgTypeCmd.GC_GetRoleDataRspd = BASE_CMD + 11
MsgTypeCmd.CG_NoticeRqst = BASE_CMD + 12
MsgTypeCmd.GC_NoticeRspd = BASE_CMD + 13
MsgTypeCmd.CG_GetChainAddressRqst = BASE_CMD + 14
MsgTypeCmd.GC_GetChainAddressRspd = BASE_CMD + 15
MsgTypeCmd.CG_SaveChainAddressRqst = BASE_CMD + 16
MsgTypeCmd.GC_SaveChainAddressRspd = BASE_CMD + 17
MsgTypeCmd.CG_GetItemListRqst = BASE_CMD + 38
MsgTypeCmd.GC_GetItemListRspd = BASE_CMD + 39
MsgTypeCmd.CG_ChatRqst = BASE_CMD + 40
MsgTypeCmd.GC_ChatRspd = BASE_CMD + 41
MsgTypeCmd.GC_DisplayItemListRspd = BASE_CMD + 42
MsgTypeCmd.GC_UpdateItemInfoRspd = BASE_CMD + 43
MsgTypeCmd.CG_MoveItemRqst = BASE_CMD + 44
MsgTypeCmd.GC_MoveItemRspd = BASE_CMD + 45
MsgTypeCmd.GC_ObjEventChangeRspd = BASE_CMD + 46
MsgTypeCmd.CG_SaveMirrorSchemeRqst = BASE_CMD + 47
MsgTypeCmd.GC_SaveMirrorSchemeRspd = BASE_CMD + 48
MsgTypeCmd.GC_MirrorSchemeInfoRspd = BASE_CMD + 49
MsgTypeCmd.GC_SingleCopyEquipPropertyRspd = BASE_CMD + 50
MsgTypeCmd.CG_CalcScoreSingleCopyRqst = BASE_CMD + 51
MsgTypeCmd.GC_CalcScoreSingleCopyRspd = BASE_CMD + 52
MsgTypeCmd.GC_PlayerLevelupRspd = BASE_CMD + 53
MsgTypeCmd.CG_ModifyRoleNameRqst = BASE_CMD + 54
MsgTypeCmd.GC_ModifyRoleNameRspd = BASE_CMD + 55
MsgTypeCmd.CG_SetPortraitRqst = BASE_CMD + 56
MsgTypeCmd.GC_SetPortraitRspd = BASE_CMD + 57
MsgTypeCmd.CG_OperateBackgroundRqst = BASE_CMD + 58
MsgTypeCmd.GC_OperateBackgroundRspd = BASE_CMD + 59
MsgTypeCmd.CG_SynchInfoRqst = BASE_CMD + 60
MsgTypeCmd.CG_CommonBuyRqst = BASE_CMD + 61
MsgTypeCmd.GC_CommonBuyRspd = BASE_CMD + 62
MsgTypeCmd.CG_ActionPointInfoRqst = BASE_CMD + 63
MsgTypeCmd.GC_ActionPointInfoRspd = BASE_CMD + 64
MsgTypeCmd.GC_EquipOnsRspd = BASE_CMD + 65
MsgTypeCmd.CG_ReformEquipRqst = BASE_CMD + 66
MsgTypeCmd.GC_ReformEquipRspd = BASE_CMD + 67
MsgTypeCmd.CG_RebuildEquipRqst = BASE_CMD + 68
MsgTypeCmd.GC_RebuildEquipRspd = BASE_CMD + 69
MsgTypeCmd.CG_GetDesignInfoRqst = BASE_CMD + 70
MsgTypeCmd.GC_EquipCollectInfoRspd = BASE_CMD + 71
MsgTypeCmd.CG_AchieveInfoRqst = BASE_CMD + 80
MsgTypeCmd.GC_AchieveInfoRspd = BASE_CMD + 81
MsgTypeCmd.GC_AchieveProgressInfoRspd = BASE_CMD + 82
MsgTypeCmd.CG_AchieveRewardRqst = BASE_CMD + 83
MsgTypeCmd.GC_AchieveRewardRspd = BASE_CMD + 84
MsgTypeCmd.GC_AchieveStatusChangeRspd = BASE_CMD + 85
MsgTypeCmd.CG_LuckyDrawPoolInfoRqst = BASE_CMD + 90
MsgTypeCmd.GC_LuckyDrawPoolInfoRspd = BASE_CMD + 91
MsgTypeCmd.CG_LuckyDrawPersonalInfoRqst = BASE_CMD + 92
MsgTypeCmd.GC_LuckyDrawPersonalInfoRspd = BASE_CMD + 93
MsgTypeCmd.CG_LuckyDrawOpRqst = BASE_CMD + 94
MsgTypeCmd.GC_LuckyDrawOpRspd = BASE_CMD + 95
MsgTypeCmd.CG_LuckyDrawExchangeRqst = BASE_CMD + 96
MsgTypeCmd.GC_LuckyDrawExchangeRspd = BASE_CMD + 97
MsgTypeCmd.CG_ItemFlagRqst = BASE_CMD + 400
MsgTypeCmd.GC_ItemFlagRspd = BASE_CMD + 401
MsgTypeCmd.CG_TurntableGetInfoRqst = BASE_CMD + 500
MsgTypeCmd.GC_TurntableGetInfoRspd = BASE_CMD + 501
MsgTypeCmd.CG_TurntableOptRqst = BASE_CMD + 502
MsgTypeCmd.GC_TurntableOptRspd = BASE_CMD + 503
MsgTypeCmd.CG_WelfareGetInfoRqst = BASE_CMD + 504
MsgTypeCmd.GC_WelfareGetInfoRspd = BASE_CMD + 505
MsgTypeCmd.CG_WelfareOptRqst = BASE_CMD + 506
MsgTypeCmd.GC_WelfareOptRspd = BASE_CMD + 507
MsgTypeCmd.CG_GiftActiveCodeRqst = BASE_CMD + 508
MsgTypeCmd.GC_GiftActiveCodeRspd = BASE_CMD + 509
MsgTypeCmd.CG_CityGetInfoRqst = BASE_CMD + 510
MsgTypeCmd.GC_CityGetInfoRspd = BASE_CMD + 511
MsgTypeCmd.CG_CityOptRqst = BASE_CMD + 512
MsgTypeCmd.GC_CityOptRspd = BASE_CMD + 513
MsgTypeCmd.CG_ModifyDogNameRqst = BASE_CMD + 514
MsgTypeCmd.GC_ModifyDogNameRspd = BASE_CMD + 515
MsgTypeCmd.CG_ActivityEnterRqst = BASE_CMD + 1000
MsgTypeCmd.GC_ActivityEnterRspd = BASE_CMD + 1001
MsgTypeCmd.CG_CurrentChapterLevelRqst = BASE_CMD + 1002
MsgTypeCmd.GC_CurrentChapterLevelRspd = BASE_CMD + 1003
MsgTypeCmd.CG_ChapterLevelResultRqst = BASE_CMD + 1004
MsgTypeCmd.GC_ChapterLevelResultRspd = BASE_CMD + 1005
MsgTypeCmd.CG_ReceiveRewardRqst = BASE_CMD + 1006
MsgTypeCmd.GC_ReceiveRewardRspd = BASE_CMD + 1007
MsgTypeCmd.CG_StoryGetRqst = BASE_CMD + 1010
MsgTypeCmd.GC_StoryGetRspd = BASE_CMD + 1011
MsgTypeCmd.CG_StoryFinishRqst = BASE_CMD + 1012
MsgTypeCmd.GC_StoryFinishRspd = BASE_CMD + 1013
MsgTypeCmd.CG_TaskGetListRqst = BASE_CMD + 1020
MsgTypeCmd.GC_TaskGetListRspd = BASE_CMD + 1021
MsgTypeCmd.CG_TaskFinishRqst = BASE_CMD + 1022
MsgTypeCmd.GC_TaskFinishRspd = BASE_CMD + 1023
MsgTypeCmd.GC_TaskNewTaskRspd = BASE_CMD + 1024
MsgTypeCmd.GC_TaskDeleteTaskRspd = BASE_CMD + 1025
MsgTypeCmd.GC_TaskSectionRspd = BASE_CMD + 1026
MsgTypeCmd.CG_TaskProcessRqst = BASE_CMD + 1027
MsgTypeCmd.GC_TaskProcessRspd = BASE_CMD + 1028
MsgTypeCmd.GC_TaskFinishedListRspd = BASE_CMD + 1029
MsgTypeCmd.CG_InteractionRewardGetInfoRqst = BASE_CMD + 1040
MsgTypeCmd.GC_InteractionRewardGetInfoRspd = BASE_CMD + 1041
MsgTypeCmd.CG_InteractionRewardPickRqst = BASE_CMD + 1042
MsgTypeCmd.GC_InteractionRewardPickRspd = BASE_CMD + 1043
MsgTypeCmd.CG_RoomCurrentRoomRqst = BASE_CMD + 1050
MsgTypeCmd.GC_RoomCurrentRoomRspd = BASE_CMD + 1051
MsgTypeCmd.CG_RoomGetListRqst = BASE_CMD + 1052
MsgTypeCmd.GC_RoomGetListRspd = BASE_CMD + 1053
MsgTypeCmd.GC_RoomEventRspd = BASE_CMD + 1054
MsgTypeCmd.CG_ItemGatherActivityInfoRqst = BASE_CMD + 1055
MsgTypeCmd.GC_ItemGatherActivityInfoRspd = BASE_CMD + 1056
MsgTypeCmd.CG_ItemGatherGetAwardRqst = BASE_CMD + 1057
MsgTypeCmd.GC_ItemGatherGetAwardRspd = BASE_CMD + 1058
MsgTypeCmd.CG_PetActivityEnterInfoRqst = BASE_CMD + 1060
MsgTypeCmd.GC_PetActivityEnterInfoRspd = BASE_CMD + 1061
MsgTypeCmd.CG_PetActivityPlayerInfoRqst = BASE_CMD + 1062
MsgTypeCmd.GC_PetActivityPlayerInfoRspd = BASE_CMD + 1063
MsgTypeCmd.CG_PetActivityRewardRqst = BASE_CMD + 1064
MsgTypeCmd.GC_PetActivityRewardRspd = BASE_CMD + 1065
MsgTypeCmd.CG_OfflinePlayRqst = BASE_CMD + 1080
MsgTypeCmd.GC_OfflinePlayRspd = BASE_CMD + 1081
MsgTypeCmd.CG_ActivityOpenInfoRqst = BASE_CMD + 1090
MsgTypeCmd.GC_ActivityOpenInfoRspd = BASE_CMD + 1091
MsgTypeCmd.CG_ActivityPlayerInfoRqst = BASE_CMD + 1092
MsgTypeCmd.GC_ActivityPlayerInfoRspd = BASE_CMD + 1093
MsgTypeCmd.CG_ActivityBuyRqst = BASE_CMD + 1094
MsgTypeCmd.GC_ActivityBuyRspd = BASE_CMD + 1095
MsgTypeCmd.CG_ActivityLevelFinishRqst = BASE_CMD + 1096
MsgTypeCmd.GC_ActivityLevelFinishRspd = BASE_CMD + 1097
MsgTypeCmd.CG_GetAllActivityInfoRqst = BASE_CMD + 1098
MsgTypeCmd.CG_CoinActivityInfoRqst = BASE_CMD + 1100
MsgTypeCmd.GC_CoinActivityInfoRspd = BASE_CMD + 1101
MsgTypeCmd.CG_CoinEnterRqst = BASE_CMD + 1102
MsgTypeCmd.GC_CoinEnterRspd = BASE_CMD + 1103
MsgTypeCmd.CG_CoinFinishedRqst = BASE_CMD + 1104
MsgTypeCmd.GC_CoinFinishedRspd = BASE_CMD + 1105
MsgTypeCmd.CG_CoinTaskEventRqst = BASE_CMD + 1106
MsgTypeCmd.GC_CoinTaskEventRspd = BASE_CMD + 1107
MsgTypeCmd.CG_CoinOpenBoxRqst = BASE_CMD + 1108
MsgTypeCmd.GC_CoinOpenBoxRspd = BASE_CMD + 1109
MsgTypeCmd.CG_WateredRadishInfoRqst = BASE_CMD + 1110
MsgTypeCmd.GC_WateredRadishInfoRspd = BASE_CMD + 1111
MsgTypeCmd.CG_WateredRadishRewardRqst = BASE_CMD + 1112
MsgTypeCmd.GC_WateredRadishRewardRspd = BASE_CMD + 1113
MsgTypeCmd.CG_WateredRadishFlagRqst = BASE_CMD + 1114
MsgTypeCmd.GC_WateredRadishFlagRspd = BASE_CMD + 1115
MsgTypeCmd.CG_TeachStartRqst = BASE_CMD + 1116
MsgTypeCmd.GC_TeachStartRspd = BASE_CMD + 1117
MsgTypeCmd.CG_InviteFriendRqst = BASE_CMD + 1118
MsgTypeCmd.GC_InviteFriendRspd = BASE_CMD + 1119
MsgTypeCmd.CG_AdInfoRqst = BASE_CMD + 1200
MsgTypeCmd.GC_AdInfoRspd = BASE_CMD + 1201
MsgTypeCmd.CG_AdRewardRqst = BASE_CMD + 1202
MsgTypeCmd.GC_AdRewardRspd = BASE_CMD + 1203
MsgTypeCmd.CG_UgcLevelOptRqst = BASE_CMD + 1300
MsgTypeCmd.GC_UgcLevelOptRspd = BASE_CMD + 1301
MsgTypeCmd.CG_UgcLevelGetListRqst = BASE_CMD + 1302
MsgTypeCmd.GC_UgcLevelGetListRspd = BASE_CMD + 1303
MsgTypeCmd.CG_UgcLevelGetDetailRqst = BASE_CMD + 1304
MsgTypeCmd.GC_UgcLevelGetDetailRspd = BASE_CMD + 1305
MsgTypeCmd.CG_UgcLevelPlayStartRqst = BASE_CMD + 1306
MsgTypeCmd.GC_UgcLevelPlayStartRspd = BASE_CMD + 1307
MsgTypeCmd.CG_UgcLevelPlayEndRqst = BASE_CMD + 1308
MsgTypeCmd.GC_UgcLevelPlayEndRspd = BASE_CMD + 1309
MsgTypeCmd.CG_UgcLevelMatchRqst = BASE_CMD + 1310
MsgTypeCmd.GC_UgcLevelMatchRspd = BASE_CMD + 1311
MsgTypeCmd.CG_UgcLevelSearchRqst = BASE_CMD + 1312
MsgTypeCmd.GC_UgcLevelSearchRspd = BASE_CMD + 1313
MsgTypeCmd.CG_UgcLevelSelfTestRqst = BASE_CMD + 1314
MsgTypeCmd.GC_UgcLevelSelfTestRspd = BASE_CMD + 1315
MsgTypeCmd.GC_UgcComLevelListRspd = BASE_CMD + 1316
MsgTypeCmd.GC_UgcLevelCountInitRspd = BASE_CMD + 1320
MsgTypeCmd.GC_UgcLevelCountMatchRspd = BASE_CMD + 1321
MsgTypeCmd.CG_UgcGetCreatorInfoRqst = BASE_CMD + 1322
MsgTypeCmd.GC_UgcGetCreatorInfoRspd = BASE_CMD + 1323
MsgTypeCmd.CG_UgcEditIntrRqst = BASE_CMD + 1324
MsgTypeCmd.GC_UgcEditIntrRspd = BASE_CMD + 1325
MsgTypeCmd.CG_UgcGetOwnerLevelRqst = BASE_CMD + 1326
MsgTypeCmd.GC_UgcGetOwnerLevelRspd = BASE_CMD + 1327
MsgTypeCmd.CG_EveryDayTaskInfoRqst = BASE_CMD + 1400
MsgTypeCmd.GC_EveryDayTaskInfoRspd = BASE_CMD + 1401
MsgTypeCmd.CG_EveryDayTaskRewardRqst = BASE_CMD + 1402
MsgTypeCmd.GC_EveryDayTaskRewardRspd = BASE_CMD + 1403
MsgTypeCmd.CG_EveryDayTaskEventRqst = BASE_CMD + 1404
MsgTypeCmd.GC_EveryDayTaskEventRspd = BASE_CMD + 1405
MsgTypeCmd.CG_AdEndRqst = BASE_CMD + 1410
MsgTypeCmd.GC_AdEndRspd = BASE_CMD + 1411
MsgTypeCmd.CG_ClientDefineSetRqst = BASE_CMD + 1501
MsgTypeCmd.GC_ClientDefineSetRspd = BASE_CMD + 1502
MsgTypeCmd.CG_ClientDefineGetRqst = BASE_CMD + 1503
MsgTypeCmd.GC_ClientDefineGetRspd = BASE_CMD + 1504
MsgTypeCmd.WK_TestRqst = BASE_CMD + 2000
MsgTypeCmd.KW_TestRspd = BASE_CMD + 2001
MsgTypeCmd.WK_QueryBalanceRqst = BASE_CMD + 2010
MsgTypeCmd.KW_QueryBalanceRspd = BASE_CMD + 2011
MsgTypeCmd.WK_QueryCoinActivityRqst = BASE_CMD + 2012
MsgTypeCmd.KW_QueryCoinActivityRspd = BASE_CMD + 2013
MsgTypeCmd.WK_RewardCoinRqst = BASE_CMD + 2014
MsgTypeCmd.KW_RewardCoinRspd = BASE_CMD + 2015
MsgTypeCmd.KK_ActivityDataChgRqst = BASE_CMD + 2020
MsgTypeCmd.KK_ActivityDataChgRspd = BASE_CMD + 2021
MsgTypeCmd.KE_RegisterCountRqst = BASE_CMD + 2025
MsgTypeCmd.EK_RegisterCountRspd = BASE_CMD + 2026
MsgTypeCmd.WK_QueryChainAddressRqst = BASE_CMD + 2027
MsgTypeCmd.KW_QueryChainAddressRspd = BASE_CMD + 2028
MsgTypeCmd.GMK_QueryContractInfoRqst = BASE_CMD + 2029
MsgTypeCmd.KGM_QueryContractInfoRspd = BASE_CMD + 2030
MsgTypeCmd.WK_BindChainAddressRqst = BASE_CMD + 2031
MsgTypeCmd.KW_BindChainAddressRspd = BASE_CMD + 2032
MsgTypeCmd.GM_PingRqst = BASE_CMD + 5000
MsgTypeCmd.MG_PingRspd = BASE_CMD + 5001
MsgTypeCmd.GM_AddItemRqst = BASE_CMD + 5002
MsgTypeCmd.MG_AddItemRspd = BASE_CMD + 5003
MsgTypeCmd.GM_QueryServerConfigRqst = BASE_CMD + 5004
MsgTypeCmd.MG_QueryServerConfigRspd = BASE_CMD + 5005
MsgTypeCmd.GM_SendMailRqst = BASE_CMD + 10003
MsgTypeCmd.MG_SendMailRspd = BASE_CMD + 10004
MsgTypeCmd.GM_ReloadCsvRqst = BASE_CMD + 10015
MsgTypeCmd.MG_ReloadCsvRspd = BASE_CMD + 10016
MsgTypeCmd.GM_LoadCsvResultRqst = BASE_CMD + 10017
MsgTypeCmd.MG_LoadCsvResultRspd = BASE_CMD + 10018
MsgTypeCmd.GM_UgcComLevelListRqst = BASE_CMD + 10019
MsgTypeCmd.MG_UgcComLevelListRspd = BASE_CMD + 10020
MsgTypeCmd.GM_OptUgcComLevelRqst = BASE_CMD + 10021
MsgTypeCmd.MG_OptUgcComLevelRspd = BASE_CMD + 10022
MsgTypeCmd.GM_MonitorOptRqst = BASE_CMD + 11005
MsgTypeCmd.MG_MonitorOptRspd = BASE_CMD + 11006
MsgTypeCmd.GM_MonitorMachineStatusRqst = BASE_CMD + 11007
MsgTypeCmd.MG_MonitorMachineStatusRspd = BASE_CMD + 11008
MsgTypeCmd.GM_MonifyPayOrderRqst = BASE_CMD + 11009
MsgTypeCmd.MG_MonifyPayOrderRspd = BASE_CMD + 11010
MsgTypeCmd.GM_QueryActivityRqst = BASE_CMD + 11011
MsgTypeCmd.MG_QueryActivityRspd = BASE_CMD + 11012
MsgTypeCmd.GM_ModifyActivityRqst = BASE_CMD + 11013
MsgTypeCmd.MG_ModifyActivityRspd = BASE_CMD + 11014
MsgTypeCmd.GM_QueryActivityIsAllCloseRqst = BASE_CMD + 11015
MsgTypeCmd.MG_QueryActivityIsAllCloseRspd = BASE_CMD + 11016
MsgTypeCmd.GM_ActivityOneKeyCloseRqst = BASE_CMD + 11017
MsgTypeCmd.MG_ActivityOneKeyCloseRspd = BASE_CMD + 11018
MsgTypeCmd.GM_LockPlayerRqst = BASE_CMD + 11019
MsgTypeCmd.MG_LockPlayerRspd = BASE_CMD + 11020

MsgType.EPlatformType = {
    E_PT_NULL = 0,
    E_PT_GUEST = 1,
    E_PT_QuickSdk = 2
}

MsgType.EPaymentType = {
    E_PT_NULL = 0,
    E_PT_GUEST = 1,
    E_PT_QuickSdk = 2
}

MsgType.EObjType = {
    E_OBJ_INVALID = 0,
    E_OBJ_PLAYER = 1,
    E_OBJ_MONSTER = 2,
    E_OBJ_PET = 3,
    E_OBJ_SIMROBOT = 4
}

MsgType.ESrvNotifyType = {
    ESNT_OtherPlaceLogin = 1,
    ESNT_NeedReLogin = 2,
    ESNT_BeLocked = 3
}

MsgType.EEventType = {
    EET_MainTaskLevel = 11,
    EET_StarNormalLevel = 13,
    EET_NormalLevel = 14,
    EET_MainTaskDialogLevel = 21,
    EET_StarDialogLevel = 22,
    EET_NormalDialogLevel = 23,
    EET_CollectionLevel = 51
}

MsgType.EEventRefreshConditionType = {
    EERCT_Invalid = 0,
    EERCT_LbsPoiInfo = 1,
    EERCT_Date = 2,
    EERCT_Time = 3,
    EERCT_Weather = 4,
    EERCT_Random = 5,
    EERCT_NPCFriendDegree = 6
}

MsgType.EMapPoiType = {
    EMPT_Invalid = 0,
    EMPT_Shop = 1,
    EMPT_BlackMarket = 2,
    EMPT_MainTask = 3,
    EMPT_StarTask = 4,
    EMPT_BulkTask = 5
}

MsgType.EMapPoiStatus = {
    EMPS_Normal = 0,
    EMPT_Passed = 1
}

MsgType.EEventStatus = {
    EES_Lock = 0,
    EES_UnLock = 1
}

MsgType.EEventMsgSourceType = {
    EEMST_Invalid = 0,
    EEMST_LbsMap = 1,
    EEMST_TaskList = 2
}

MsgType.EPoiListNotiType = {
    EPLNT_Reset = 0,
    EEMST_Add = 1,
    EEMST_Del = 2
}

MsgType.EDialogTalkType = {
    EDTY_Invalid = 0,
    EDTY_Dance = 1,
    EDTY_Finish = 2,
    EDTY_AddFeeling = 3
}

MsgType.EFriendOptType = {
    EFOT_Invalid = 0,
    EFOT_AddFriend = 1,
    EFOT_DelFriend = 2,
    EFOT_AgreeFriend = 3,
    EFOT_RefuseFriend = 4,
    EFOT_AddBlack = 5,
    EFOT_RemoveBlack = 6,
    EFOT_SendActionPoint = 7,
    EFOT_BackActionPoint = 8,
    EFOT_RequestActionPoint = 9
}

MsgType.EFriendListType = {
    EFLT_Invalid = 0,
    EFLT_FriendList = 1,
    EFLT_ApplyList = 2,
    EFLT_BlackList = 4,
    EFLT_RecommendList = 8,
    EFLT_SearchList = 16
}

MsgType.EFansType = {
    EFLT_Invalid = 0,
    EFLT_FollowList = 1,
    EFLT_FansList = 2
}

MsgType.EFriendStatusType = {
    EFST_Offline = 0,
    EFST_Online = 1
}

MsgType.EPetOptType = {
    EPOT_Invalid = 0,
    EPOT_Show = 1,
    EPOT_CancelShow = 2,
    EPOT_Dance = 3,
    EPOT_CancelDance = 4,
    EPOT_QueryRecvApInfo = 5,
    EPOT_RecvAp = 6,
    EPOT_RefreshTask = 7,
    EPOT_AcceptTask = 8,
    EPOT_GiveUpTask = 9,
    EPOT_Interaction = 10,
    EPOT_BindFurniture = 11
}

MsgType.EPetFloorUnlockType = {
    EPFUT_Invalid = 0,
    EPFUT_Default = 1,
    EPFUT_PetNum = 2,
    EPFUT_RoleLevel = 3,
    EPFUT_FurnitureNum = 4,
    EPFUT_FinishPetTaskNum = 5,
    EPFUT_VIP = 6,
    EPFUT_UseDiamond = 7,
    EPFUT_UseGold = 8
}

MsgType.EPetInteractionType = {
    EPIT_Invalid = 0,
    EPIT_Show = 1,
    EPIT_CancelShow = 2
}

MsgType.EPetRoomInFloorPositionType = {
    EPRFPT_CENTER = 0,
    EPRFPT_LEFT = 1,
    EPRFPT_RIGHT = 2
}

MsgType.EShopActivityType = {
    ESAT_Invalid = 0,
    ESAT_ReachNumDel = 1,
    ESAT_ReachMoneyGetItem = 2,
    ESAT_BuyItemGetItem = 3,
    ESAT_TimeLimit = 4
}

MsgType.EMailTypeInMsg = {
    EMTIM_System = 0,
    EMTIM_Friend = 1,
    EMTIM_FriendApply = 2
}

MsgType.EMailReasonType = {
    EMailReasonType_RequestAp = 1,
    EMailReasonType_PresentAp = 2,
    EMailReasonType_PresentApBack = 3,
    EMailReasonType_FriendApply = 4,
    EMailReasonType_System = 5,
    EMailReasonType_ActivityExpireReward = 6,
    EMailReasonType_BornMail = 7
}

MsgType.EMailReadStatusInMsg = {
    EMRSIM_UnRead = 0,
    EMRSIM_Read = 1,
    EMRSIM_Handled = 2
}

MsgType.ELevelTopOptType = {
    ELTOT_Invalid = 0,
    ELTOT_PassLevel = 1,
    ELTOT_LevelTopDataChg = 2
}

MsgType.EChatChannelStatusType = {
    ECCST_Free = 0,
    ECCST_Lively = 1,
    ECCST_Fiery = 2,
    ECCST_Fullhouse = 3
}

MsgType.ERedTipType = {
    ERTT_None = 0,
    ERTT_Mail = 10,
    ERTT_Task = 20,
    ERTT_Equip = 30,
    ERTT_Achievement = 40
}

MsgType.EDanceBallStatus = {
    EDBS_Invalid = 0,
    EDBS_Waiting = 1,
    EDBS_Going1 = 2,
    EDBS_Going2 = 3,
    EDBS_Going3 = 4,
    EDBS_Going4 = 5,
    EDBS_Going5 = 6,
    EDBS_Going6 = 7,
    EDBS_End = 8
}

MsgType.EDanceBallJoinType = {
    EDBJT_Invitee = 0,
    EDBJT_Creater = 0
}

MsgType.EDanceBallGetServerReason = {
    EDBGSR_CreateBall = 1,
    EDBGSR_JoinBall = 2
}

MsgType.EMapSlotEventStatus = {
    EMSES_Invalid = 0,
    EMSES_UnTrigger = 1,
    EMSES_Trigger = 2
}

MsgType.EMapDiceType = {
    EMDT_Normal = 0,
    EMDT_Control = 1
}

MsgType.EOfflineType = {
    EBuyItemBeforePlay = 1,
    EPlay = 2
}

MsgType.EStepType = {
    EStep1 = 10401,
    EStep2 = 10402,
    EStep3 = 10403
}

MsgType.EMapSlotEventType = {
    EMSET_Invalid = 0,
    EMSET_Shop = 1,
    EMSET_Lottery = 2
}

MsgType.EMapUnLockType = {
    EMapUnLockType_Invalid = 0,
    EMapUnLockType_LevelPassNum = 1,
    EMapUnLockType_Time = 2
}

MsgType.EBagType = {
    EBagType_Item = 1,
    EBagType_Equip = 2,
    EBagType_EquipOn = 3,
    EBagType_Design = 4
}

MsgType.EBackgroundOptType = {
    EBackgroundOptType_Invalid = 0,
    EBackgroundOptType_CurrentList = 1,
    EBackgroundOptType_Set = 2,
    EBackgroundOptType_GainableList = 3,
    EBackgroundOptType_Gain = 4,
    EBackgroundOptType_UngainableList = 5
}

MsgType.EFeedbackOptionType = {
    EFeedbackOption_Satisfied = 0,
    EFeedbackOption_general = 1,
    EFeedbackOption_unSatisfied = 2
}

MsgType.ESpecialBuyType = {
    ESpecialBuyType_Step = 1,
    ADBuyType_Step = 2
}

MsgType.EChatType = {
    E_NORMAL_CHAT = 1,
    E_FRIEND_CHAT = 2,
    E_STRANGER_CHAT = 3,
    E_SYSTEM_CHAT = 4,
    E_BIGHORN_CHAT = 5,
    E_TINYHORN_CHAT = 6,
    E_GMCMD_CHAT = 10
}

MsgType.EObjEvent = {
    NO_CHANGE = 0,
    MONEY_CHANGE = 1,
    CRYSTAL_CHANGE = 2,
    EXP_CHANGE = 3,
    ACTION_POINT_CHANGE = 4,
    UGC_MONEY_CHANGE = 5,
    UGC_ACTION_POINT_CHANGE = 6,
    UGC_STONE_CHANGE = 7,
    UGC_WORKDER_POINT_CHANGE = 8,
    UGC_BUILDER_POINT_CHANGE = 9,
    UGC_FUNCOINS_CHANGE = 10
}

MsgType.ELogValueIncDecReason = {
}

MsgType.ESingleCopyCalcType = {
    ESingleCopyCalc_Finish = 0,
    ESingleCopyCalc_Timeout = 1,
    ESingleCopyCalc_Exist = 2
}

MsgType.EEquipReformType = {
    EEquipReform_Drawing = 1,
    EEquipReform_Coloration = 2,
    EEquipReform_Evolution = 3,
    EEquipReform_Resolution = 4
}

MsgType.EPayListType = {
    EPayListType_Recharge = 0,
    EPayListType_ItemShop = 1,
    EPayListType_Festival = 2,
    EPayListType_Sales = 3
}

MsgType.EActivityType = {
    EActivityType_ItemShop = 1,
    EActivityType_FestivalShop = 2,
    EActivityType_CandyHouse = 3,
    EActivityType_Sales = 4,
    EActivityType_Turntable = 5,
    EActivityType_WindMill = 6,
    EActivityType_Pet = 7,
    EActivityType_Clothes = 8,
    EActivityType_Watered = 9,
    EActivityType_Welfare = 100,
    EActivityType_Recharge = 101
}

MsgType.EPayMoneyType = {
    EPayMoneyType_Rmb = 1,
    EPayMoneyType_Gold = 2
}

MsgType.EPayPlatformType = {
    E_PPT_NULL = 0,
    E_PPT_ALI = 1
}

MsgType.ETurntableOptType = {
    ETurntableOpt_Invalid = 0,
    ETurntableOpt_EndTurntable = 1,
    ETurntableOpt_PickReward = 2
}

MsgType.ECityOptType = {
    ECityOpt_Invalid = 0,
    ECityOpt_Unlock = 1,
    ECityOpt_Switch = 2
}

MsgType.ELevelResultType = {
    ELRT_Pass = 1,
    ELRT_Failed = 2,
    ELRT_Quit = 3
}

MsgType.EAchieveStatus = {
    EAchieveStatusFufiled = 1,
    EAchieveStatusToReward = 2,
    EAchieveStatusInProgress = 3,
    EAchieveStatusNotOpen = 4
}

MsgType.ELuckyDrawOpType = {
    ELuckyDrawOpFree = 1,
    ELuckyDrawOpUseTicket = 2,
    ELuckyDrawOpUseResources = 3
}

MsgType.ELuckyDrawTimesType = {
    ELuckyDrawTimesSingle = 1,
    ELuckyDrawTimesMulti = 2
}

MsgType.EMapEnterType = {
    EMapEnterNormal = 0,
    EMapEnterPet = 1,
    EMapEnterActivity = 2,
    EMapEnterWatered = 3
}

MsgType.EStoryStatusType = {
    ESST_InProgress = 1,
    ESST_Finished = 2
}

MsgType.EStoryPreType = {
    ESPT_Null = 0,
    ESPT_Story = 1,
    ESPT_Task = 2,
    ESPT_Level = 3,
    ESPT_DateTime = 4
}

MsgType.ETaskStatusType = {
    ETST_InProgress = 1,
    ETST_Finished = 2
}

MsgType.ETaskRewardType = {
    ETRT_Item = 1,
    ETRT_Room = 2,
    ETRT_RoomObject = 3
}

MsgType.EVirtualCoinRewardType = {
    EVCRT_Level = 1
}

MsgType.ECoinActivityStatusType = {
    ECAST_Locked = 0,
    ECAST_Opening = 1,
    ECAST_NotOpen = 2
}

MsgType.ECoinTaskType = {
    ECoinTaskType_Level = 1,
    ECoinTaskType_Friend = 2,
    ECoinTaskType_Share = 3,
    ECoinTaskType_GoldCost = 4
}

MsgType.EChatErrorCode = {
    E_CHAT_SUCCEED = 1400,
    E_CHAT_ERROR_NOTGTPLAYER = 1401,
    E_CHAT_ERROR_TOOFAST = 1402,
    E_CHAT_ERROR_NO_BIGHORN = 1403,
    E_CHAT_ERROR_TGTOFFLINE = 1404,
    E_CHAT_ERROR_UNKNOWN = 1405,
    E_CHAT_ERROR_LOCKED = 1406,
    E_CHAT_ERROR_CHANNELFULL = 1407,
    E_CHAT_ERROR_NOTFRIEND = 1408,
    E_CHAT_ERROR_INSELFBLACKLIST = 1409,
    E_CHAT_ERROR_INTGTBLACKLIST = 1410,
    E_CHAT_ERROR_NO_TINYHORN = 1411,
    E_CHAT_ERROR_CONT_TOO_LONG = 1412
}

MsgType.EAccountChkRst = {
    EAccountChkRst_Ok = 1500,
    EAccountChkRst_Failed = 1501,
    EAccountChkRst_PlatformChkFailed = 1502,
    EAccountChkRst_VersionNoMatch = 1503
}

MsgType.EAccountRst = {
    EAccountRst_Ok = 2400,
    EAccountRst_UnknownError = 2401,
    EAccountRst_AccountNameExisted = 2402,
    EAccountRst_InvalidAccountName = 2403,
    EAccountRst_ExistRole = 2404,
    EAccountRst_InvalidRoleName = 2405,
    EAccountRst_RoleNameExisted = 2406,
    EAccountRst_NoExistRole = 2407,
    EAccountRst_SameToOldRoleName = 2408,
    EAccountRst_NoEnoughModifyNameItem = 2409,
    EAccountRst_TokenInvalid = 2410
}

MsgType.EEventOptCode = {
    EEventOptCode_Ok = 2200,
    EEventOptCode_Failed = 2201,
    EEventOptCode_MaxTimes = 2202,
    EEventOptCode_AlreadyReward = 2203,
    EEventOptCode_NotEnough = 2204
}

MsgType.ELbsMapOptCode = {
    ELbsMapOptCode_Ok = 200,
    ELbsMapOptCode_Failed = 201,
    ELbsMapOptCode_Refresh_NotEnoughItem = 202,
    ELbsMapOptCode_Refresh_NotEnoughStep = 203,
    ELbsMapOptCode_Refresh_AlreadyReward = 204
}

MsgType.ECopyTeamOptCode = {
    ECopyTeamOptCode_Ok = 2500,
    ECopyTeamOptCode_Failed = 2501,
    ECopyTeamOptCode_MaxTimes = 2502,
    ECopyTeamOptCode_NotEnoughItem = 2503,
    ECopyTeamOptCode_NotEnoughActionPoint = 2504,
    ECopyTeamOptCode_NoWateredInfo = 2504
}

MsgType.EUseItemOptCode = {
    EUseItemOptCode_Ok = 2600,
    EUseItemOptCode_Failed = 2601,
    EUseItemOptCode_NotEnoughItem = 2602
}

MsgType.EFriendOptCode = {
    EFriendOptCode_Ok = 1300,
    EFriendOptCode_Failed = 1301,
    EFriendOptCode_AlreadyFriend = 1302,
    EFriendOptCode_InSelfBlackList = 1303,
    EFriendOptCode_InTargetBlackList = 1304,
    EFriendOptCode_InSelfFriendList = 1305,
    EFriendOptCode_SelfFriendListMax = 1306,
    EFriendOptCode_TargetFriendListMax = 1307,
    EFriendOptCode_TargetApplyListMax = 1308,
    EFriendOptCode_SelfBlackListMax = 1309,
    EFriendOptCode_NotSelfFriend = 1310,
    EFriendOptCode_SelfSendMax = 1311,
    EFriendOptCode_TargetRecvMax = 1312,
    EFriendOptCode_TimeLimit = 1313,
    EFriendOptCode_AlreadyInBlackList = 1314,
    EFriendOptCode_AlreadyRequestAP = 1315,
    EFriendOptCode_AlreadyApply = 1316,
    EFriendOptCode_NoEnoughAp = 1317,
    EFriendOptCode_TargetIsSelf = 1318,
    EFriendOptCode_System = 1318
}

MsgType.EPetOptCode = {
    EPetOptCode_Ok = 1100,
    EPetOptCode_Failed = 1101,
    EPetOptCode_CancelShowIsDance = 1102,
    EPetOptCode_ShowLimit = 1103,
    EPetOptCode_RefreshTaskLimit = 1104,
    EPetOptCode_RecvApTimeLimit = 1105,
    EPetOptCode_RecvApAlreadyRecv = 1106,
    EPetOptCode_BindFurnitureLimit = 1107
}

MsgType.EMailOptCode = {
    EMailOptCode_Ok = 1200,
    EMailOptCode_Failed = 1201,
    EMailOptCode_MailNotExist = 1202,
    EMailOptCode_HavePicked = 1203,
    EMailOptCode_NoEnoughSpace = 1204,
    EMailOptCode_Empty = 1205,
    EMailOptCode_DelNoPicked = 1206,
    EMailOptCode_RecvMax = 1207,
    EMailOptCode_ApLimit = 1208
}

MsgType.EShopOptCode = {
    EShopOptCode_Ok = 400,
    EShopOptCode_Failed = 401,
    EShopOptCode_MoneyNotEnough = 402,
    EShopOptCode_GoodsSellEnd = 403,
    EShopOptCode_Locked = 404,
    EShopOptCode_BuyMaxLimit = 405,
    EShopOptCode_NotShop = 406,
    EShopOptCode_InvalidShop = 407,
    EShopOptCode_StarNotEnough = 408,
    EShopOptCode_CostNotEnough = 409
}

MsgType.EDanceBallOptCode = {
    EDanceBallOptCode_Ok = 400,
    EDanceBallOptCode_Failed = 401,
    EDanceBallOptCode_CreateMoneyNotEnough = 402
}

MsgType.EMapOptCode = {
    EMapOptCode_Ok = 1000,
    EMapOptCode_Failed = 1001,
    EMapOptCode_OkButNoCost = 1002
}

MsgType.EItemOptCode = {
    EItemOptCode_Ok = 2700,
    EItemOptCode_UnknownError = 2701,
    EItemOptCode_CannotOperate = 2702
}

MsgType.EGoldenHandOptCode = {
    EGoldenHandOptCode_Ok = 2800,
    EGoldenHandOptCode_UnknownError = 2801,
    EGoldenHandOptCode_NoEnoughBuyCount = 2802,
    EGoldenHandOptCode_NoEnoughCrystal = 2803,
    EGoldenHandOptCode_BuyInfoInvalid = 2804,
    EGoldenHandOptCode_PoolVipLevel = 2805
}

MsgType.EBlackMarketOptCode = {
    EBlackMarketOptCode_Ok = 1800,
    EBlackMarketOptCode_UnknownError = 1801,
    EBlackMarketOptCode_NoBlackMarket = 1802,
    EBlackMarketOptCode_NoEnoughCost = 1803,
    EBlackMarketOptCode_NoEnoughMoney = 1804,
    EBlackMarketOptCode_NoEnoughCrystal = 1805,
    EBlackMarketOptCode_InvalidGoods = 1806,
    EBlackMarketOptCode_CannotBuyRetry = 1807,
    EBlackMarketOptCode_CannotReturnDiscount = 1808
}

MsgType.EActionPointOptCode = {
    EActionPointOptCode_Ok = 1900,
    EActionPointOptCode_UnknownError = 1901,
    EActionPointOptCode_NoEnoughBuyCount = 1902,
    EActionPointOptCode_NoEnoughCrystal = 1903,
    EActionPointOptCode_BuyInfoInvalid = 1904,
    EActionPointOptCode_PoolVipLevel = 1905
}

MsgType.EPayErrorCode = {
    EPayErrorCode_Ok = 400,
    EPayErrorCode_Failed = 401,
    EPayErrorCode_MoneyNotEnough = 402
}

MsgType.EEquipReformOptCode = {
    EEquipReformOptCode_Ok = 2000,
    EEquipReformOptCode_UnknownError = 2001,
    EEquipReformOptCode_NoEnoughBuyCount = 2002,
    EEquipReformOptCode_NoEnoughCrystal = 2003,
    EEquipReformOptCode_NoDesign = 2004,
    EEquipReformOptCode_NoEnoughCost = 2005,
    EEquipReformOptCode_IsNotElement = 2006,
    EEquipReformOptCode_InvalidParam = 2007
}

MsgType.EAchieveQueryOptCode = {
    EAchieveQuery_Ok = 2100,
    EAchieveQuery_UnknownError = 2101
}

MsgType.EAchieveRewardOpCode = {
    EAchieveReward_Ok = 2111,
    EAchieveReward_UnknownError = 2112,
    EAchieveReward_UnknownAchieve = 2113,
    EAchieveReward_AchieveNotFulfil = 2114,
    EAchieveReward_AchieveRewarded = 2115,
    EAchieveReward_RewardOpFailed = 2116
}

MsgType.ELuckyDrawPoolQryRst = {
    ELuckyDrawPoolQry_Ok = 500,
    ELuckyDrawPoolQry_UnknownError = 501
}

MsgType.ELuckyDrawPersonalInfoQryRst = {
    ELuckyDrawPersonalInfoQry_Ok = 505,
    ELuckyDrawPersonalInfoQry_UnknownError = 506
}

MsgType.ELuckyDrawOpRst = {
    ELuckyDrawOp_Ok = 510,
    ELuckyDrawOp_UnknownError = 511,
    ELuckyDrawOp_ErrorPoolID = 512,
    ELuckyDrawOp_ErrorConsumeType = 513,
    ELuckyDrawOp_ErrorConsumeNotEnough = 514
}

MsgType.ELuckyDrawExchangeRst = {
    ELuckyDrawExchange_Ok = 515,
    ELuckyDrawExchange_UnknownError = 516,
    ELuckyDrawExchange_ErrorPoolID = 517,
    ELuckyDrawExchange_ErrorExchangeType = 518,
    ELuckyDrawExchange_ErrorNotEnoughCoin = 519,
    ELuckyDrawExchange_ErrorNoTgtItem = 520,
    ELuckyDrawExchange_ErrorTgtNum = 521
}

MsgType.EBackgroundOptCode = {
    EBackGroundOpt_Ok = 2300,
    EBackGroundOpt_Failed = 2301
}

MsgType.EPortraitOptCode = {
    EPortraitOpt_Ok = 2400,
    EPortraitOpt_Failed = 2401,
    EPeekPlayerInfo_Ok = 2500,
    EPeekPlayerInfo_Failed = 2501
}

MsgType.EPeekPlayerInfoCode = {
    EPeekPlayerInfo_Ok = 2500,
    EPeekPlayerInfo_Failed = 2501
}

MsgType.ETurntableOptCode = {
    ETurntableOpt_Ok = 2600,
    ETurntableOpt_UnnkonwError = 2601,
    ETurntableOpt_LessCount = 2602,
    ETurntableOpt_CannotUse = 2603,
    ETurntableOpt_CannotPickReward = 2604,
    ETurntableOpt_InvalidOptType = 2605,
    ETurntableOpt_CostNotEnough = 2606
}

MsgType.EWelfareOptCode = {
    EWelfareOpt_Ok = 2700,
    EWelfareOpt_UnnkonwError = 2701,
    EWelfareOpt_SignRepeat = 2702,
    EWelfareOpt_End = 2703,
    EWelfareOpt_ReachMaxLimit = 2704
}

MsgType.EGiftActiveCodeErrorCode = {
    EGiftActiveCodeErrorCode_SUCCEED = 2800,
    EGiftActiveCodeErrorCode_InvalidActiveCode = 2801,
    EGiftActiveCodeErrorCode_SameTypeActived = 2802,
    EGiftActiveCodeErrorCode_UnknownError = 2803
}

MsgType.ECityOptCode = {
    ECityOpt_Ok = 2900,
    ECityOpt_UnnkonwError = 2901,
    ECityOpt_CannotUnlock_Level = 2902,
    ECityOpt_CannotUnlock_Item = 2903,
    ECityOpt_AlreadyUnlocked = 2904,
    ECityOpt_InvalidCity = 2905,
    ECityOpt_ArreadyInCity = 2906,
    ECityOpt_NotUnlocked = 2907
}

MsgType.EFeedbackCode = {
    EFeedback_Ok = 3000,
    EFeedback_Failed = 3001
}

MsgType.ETaskOptCode = {
    ETaskOpt_Ok = 3100,
    ETaskOpt_UnknownError = 3101,
    ETaskOpt_HasFinish = 3102,
    ETaskOpt_NoEnoughStar = 3103,
    ETaskOpt_NoEnoughMoney = 3104
}

MsgType.EDogOptCode = {
    EDogOptCode_Ok = 3200,
    EDogOptCode_UnknownError = 3201,
    EDogOptCode_InvalidName = 3202
}

MsgType.ItemGatherOptCode = {
    EIGOptCode_Ok = 3300,
    EIGOptCode_UnknownError = 3301,
    EIGOptCode_InvalidConfig = 3302,
    EIGOptCode_InvalidAward = 3303,
    EIGOptCode_NoInfo = 3304,
    EIGOptCode_ActivityExpire = 3305,
    EIGOptCode_SaveAwardError = 3306,
    EIGOptCode_InvalidLevel = 3307,
    EIGOptCode_HasGetAward = 3308
}

MsgType.EPetActivityOptCode = {
    EPetActivityOptCode_Ok = 3400,
    EPetActivityOptCode_UnknownError = 3401,
    EPetActivityOptCode_InvalidConfig = 3402,
    EPetActivityOptCode_InvalidAward = 3403,
    EPetActivityOptCode_ActivityExpire = 3404,
    EPetActivityOptCode_AlreadyGotten = 3405
}

MsgType.OfflineOptCode = {
    EOptCode_Ok = 3500,
    EOptCode_Unknown = 3501,
    EOptCode_InvalidMsg = 3502,
    EOptCode_Invalid = 3503,
    EOptCode_InvalidGold = 3504,
    EOptCode_InvalidItem = 3505,
    EOptCode_NoEnoughItem = 3506,
    EOptCode_LevelHasPassed = 3507,
    EOptCode_Md5Invalid = 3508,
    EOptCode_APInvalid = 3508
}

MsgType.EActivityOptCode = {
    EActivityOptCode_Ok = 3600,
    EActivityOptCode_UnknownError = 3601,
    EActivityOptCode_InvalidConfig = 3602,
    EActivityOptCode_InvalidAward = 3603,
    EActivityOptCode_ActivityExpire = 3604,
    EActivityOptCode_AlreadyGotten = 3605,
    EActivityOptCode_InvalidType = 3606,
    EActivityOptCode_CoinNotEnough = 3607,
    EActivityOptCode_WrongAward = 3608,
    EActivityOptCode_WrongLevel = 3609
}

MsgType.ECoinOptCode = {
    ECoinOptCode_Ok = 3700,
    ECoinOptCode_UnknownError = 3701,
    ECoinOptCode_InvalidConfig = 3702,
    ECoinOptCode_NotOpen = 3703,
    ECoinOptCode_TodayUsed = 3704,
    ECoinOptCode_NoKey = 3705
}

MsgType.WateredOptCode = {
    EOptCode_Ok = 3800,
    EOptCode_InvalidAward = 3801,
    EOptCode_Unknown = 3802,
    EOptCode_HasAward = 3803,
    EOptCode_AllHasAward = 3804,
    EOptCode_SaveAward = 3805,
    EOptCode_NoAward = 3806,
    EOptCode_InvalidLevel = 3807,
    EOptCode_NoActivity = 3809,
    EOptCode_HasPassTheLevel = 3810
}

MsgType.LocInMsg = {
    lng = 0,
    lat = 0
}
MsgType.LocInMsg.__index = MsgType.LocInMsg

function MsgType.LocInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LocInMsg:Encode()
    local tb = {}
    if nil ~= self.lng and 0 ~= self.lng then
        tb.b = self.lng
    end
    if nil ~= self.lat and 0 ~= self.lat then
        tb.c = self.lat
    end
    return tb
end

function MsgType.LocInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.lng = 0
    self.lat = 0
    if nil ~= data.b then
        self.lng = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lat = tonumber(data.c) or 0
    end
    return self
end

function MsgType.LocInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MapPoiSingleInDB = {
    addTime = 0,
    poiType = 0, --enum EMapPoiType
    poiValue = 0,
    optValue = 0,
    optValueList = {}, -- array of number
    location = ""
}
MsgType.MapPoiSingleInDB.__index = MsgType.MapPoiSingleInDB

function MsgType.MapPoiSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MapPoiSingleInDB:Encode()
    local tb = {}
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.b = self.addTime
    end
    if nil ~= self.poiType and 0 ~= self.poiType then
        tb.c = self.poiType
    end
    if nil ~= self.poiValue and 0 ~= self.poiValue then
        tb.d = self.poiValue
    end
    if nil ~= self.optValue and 0 ~= self.optValue then
        tb.e = self.optValue
    end
    if nil ~= self.optValueList and string.len(self.optValueList) > 0 then
        tb.f = self.optValueList
    end
    if nil ~= self.location and string.len(self.location) > 0 then
        tb.g = self.location
    end
    return tb
end

function MsgType.MapPoiSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.addTime = 0
    self.poiType = 0
    self.poiValue = 0
    self.optValue = 0
    self.optValueList = {}
    self.location = ""
    if nil ~= data.b then
        self.addTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.poiType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.poiValue = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optValue = tonumber(data.e) or 0
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.optValueList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g then
        self.location = tostring(data.g)
    end
    return self
end

function MsgType.MapPoiSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MapPoiListInDB = {
    refreshTime = 0,
    list = {}, -- array of MsgType.MapPoiSingleInDB
    refreshAdditionalArg = 0
}
MsgType.MapPoiListInDB.__index = MsgType.MapPoiListInDB

function MsgType.MapPoiListInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MapPoiListInDB:_listEncode()
    local tb = {}
    for i=1, #self.list do
        tb[i] = self.list[i]:encode()
    end
    return tb
end
function MsgType.MapPoiListInDB:Encode()
    local tb = {}
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.b = self.refreshTime
    end
    tb.c = self:_listEncode()
    if nil ~= self.refreshAdditionalArg and 0 ~= self.refreshAdditionalArg then
        tb.d = self.refreshAdditionalArg
    end
    return tb
end

function MsgType.MapPoiListInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.refreshTime = 0
    self.list = {}
    self.refreshAdditionalArg = 0
    if nil ~= data.b then
        self.refreshTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpListObj = MsgType.MapPoiSingleInDB:New()
            tmpListObj:Decode(data.c[i])
            self.list[i] = tmpListObj
        end
    end
    if nil ~= data.d then
        self.refreshAdditionalArg = tonumber(data.d) or 0
    end
    return self
end

function MsgType.MapPoiListInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LbsMapLocationInDB = {
    blockx = 0,
    blocky = 0,
    loc = "",
    cityCode = "",
    weather = ""
}
MsgType.LbsMapLocationInDB.__index = MsgType.LbsMapLocationInDB

function MsgType.LbsMapLocationInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LbsMapLocationInDB:Encode()
    local tb = {}
    if nil ~= self.blockx and 0 ~= self.blockx then
        tb.b = self.blockx
    end
    if nil ~= self.blocky and 0 ~= self.blocky then
        tb.c = self.blocky
    end
    if nil ~= self.loc and string.len(self.loc) > 0 then
        tb.d = self.loc
    end
    if nil ~= self.cityCode and string.len(self.cityCode) > 0 then
        tb.e = self.cityCode
    end
    if nil ~= self.weather and string.len(self.weather) > 0 then
        tb.f = self.weather
    end
    return tb
end

function MsgType.LbsMapLocationInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.blockx = 0
    self.blocky = 0
    self.loc = ""
    self.cityCode = ""
    self.weather = ""
    if nil ~= data.b then
        self.blockx = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.blocky = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.loc = tostring(data.d)
    end
    if nil ~= data.e then
        self.cityCode = tostring(data.e)
    end
    if nil ~= data.f then
        self.weather = tostring(data.f)
    end
    return self
end

function MsgType.LbsMapLocationInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PoiInfoStruct = {
    addTime = 0,
    poiType = 0, --enum EMapPoiType
    poiValue = 0,
    optValue = 0,
    selectDialogs = {}, -- array of number
    location = "",
    poiStatus = 0 --enum EMapPoiStatus
}
MsgType.PoiInfoStruct.__index = MsgType.PoiInfoStruct

function MsgType.PoiInfoStruct:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PoiInfoStruct:Encode()
    local tb = {}
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.b = self.addTime
    end
    if nil ~= self.poiType and 0 ~= self.poiType then
        tb.c = self.poiType
    end
    if nil ~= self.poiValue and 0 ~= self.poiValue then
        tb.d = self.poiValue
    end
    if nil ~= self.optValue and 0 ~= self.optValue then
        tb.e = self.optValue
    end
    if nil ~= self.selectDialogs and string.len(self.selectDialogs) > 0 then
        tb.f = self.selectDialogs
    end
    if nil ~= self.location and string.len(self.location) > 0 then
        tb.g = self.location
    end
    if nil ~= self.poiStatus and 0 ~= self.poiStatus then
        tb.h = self.poiStatus
    end
    return tb
end

function MsgType.PoiInfoStruct:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.addTime = 0
    self.poiType = 0
    self.poiValue = 0
    self.optValue = 0
    self.selectDialogs = {}
    self.location = ""
    self.poiStatus = 0
    if nil ~= data.b then
        self.addTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.poiType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.poiValue = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optValue = tonumber(data.e) or 0
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.selectDialogs[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g then
        self.location = tostring(data.g)
    end
    if nil ~= data.h then
        self.poiStatus = tonumber(data.h) or 0
    end
    return self
end

function MsgType.PoiInfoStruct:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EventSingleInDB = {
    eventID = 0,
    acceptTime = 0,
    todayTimes = 0,
    eventStatus = 0,
    branchEvent = 0,
    selectList = {} -- array of number
}
MsgType.EventSingleInDB.__index = MsgType.EventSingleInDB

function MsgType.EventSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EventSingleInDB:Encode()
    local tb = {}
    if nil ~= self.eventID and 0 ~= self.eventID then
        tb.b = self.eventID
    end
    if nil ~= self.acceptTime and 0 ~= self.acceptTime then
        tb.c = self.acceptTime
    end
    if nil ~= self.todayTimes and 0 ~= self.todayTimes then
        tb.d = self.todayTimes
    end
    if nil ~= self.eventStatus and 0 ~= self.eventStatus then
        tb.e = self.eventStatus
    end
    if nil ~= self.branchEvent and 0 ~= self.branchEvent then
        tb.f = self.branchEvent
    end
    if nil ~= self.selectList and string.len(self.selectList) > 0 then
        tb.g = self.selectList
    end
    return tb
end

function MsgType.EventSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventID = 0
    self.acceptTime = 0
    self.todayTimes = 0
    self.eventStatus = 0
    self.branchEvent = 0
    self.selectList = {}
    if nil ~= data.b then
        self.eventID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.acceptTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.todayTimes = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.eventStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.branchEvent = tonumber(data.f) or 0
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.selectList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.EventSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EventDataInMsg = {
    eventId = 0,
    eventStatus = 0, --enum EEventStatus
    finishTimes = 0,
    bestScore = 0,
    branchEvent = 0,
    selectDialogs = {} -- array of number
}
MsgType.EventDataInMsg.__index = MsgType.EventDataInMsg

function MsgType.EventDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EventDataInMsg:Encode()
    local tb = {}
    if nil ~= self.eventId and 0 ~= self.eventId then
        tb.b = self.eventId
    end
    if nil ~= self.eventStatus and 0 ~= self.eventStatus then
        tb.c = self.eventStatus
    end
    if nil ~= self.finishTimes and 0 ~= self.finishTimes then
        tb.d = self.finishTimes
    end
    if nil ~= self.bestScore and 0 ~= self.bestScore then
        tb.e = self.bestScore
    end
    if nil ~= self.branchEvent and 0 ~= self.branchEvent then
        tb.f = self.branchEvent
    end
    if nil ~= self.selectDialogs and string.len(self.selectDialogs) > 0 then
        tb.g = self.selectDialogs
    end
    return tb
end

function MsgType.EventDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventId = 0
    self.eventStatus = 0
    self.finishTimes = 0
    self.bestScore = 0
    self.branchEvent = 0
    self.selectDialogs = {}
    if nil ~= data.b then
        self.eventId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.eventStatus = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.finishTimes = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.bestScore = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.branchEvent = tonumber(data.f) or 0
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.selectDialogs[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.EventDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EventDataInDB = {
}

MsgType.LbsMapStepInfoInDB = {
    refreshTime = 0,
    curStep = 0,
    rewardFlag = 0
}
MsgType.LbsMapStepInfoInDB.__index = MsgType.LbsMapStepInfoInDB

function MsgType.LbsMapStepInfoInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LbsMapStepInfoInDB:Encode()
    local tb = {}
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.b = self.refreshTime
    end
    if nil ~= self.curStep and 0 ~= self.curStep then
        tb.c = self.curStep
    end
    if nil ~= self.rewardFlag and 0 ~= self.rewardFlag then
        tb.d = self.rewardFlag
    end
    return tb
end

function MsgType.LbsMapStepInfoInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.refreshTime = 0
    self.curStep = 0
    self.rewardFlag = 0
    if nil ~= data.b then
        self.refreshTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.curStep = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    return self
end

function MsgType.LbsMapStepInfoInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LbsMapDataInDB = {
    roleUID = 0,
    location = {},
    shopData = {},
    blackMarketData = {},
    mainTaskData = {},
    bulkTaskData = {},
    starTaskData = {},
    stepData = {}
}
MsgType.LbsMapDataInDB.__index = MsgType.LbsMapDataInDB
setmetatable(MsgType.LbsMapDataInDB.location, MsgType.LbsMapLocationInDB)
setmetatable(MsgType.LbsMapDataInDB.shopData, MsgType.MapPoiListInDB)
setmetatable(MsgType.LbsMapDataInDB.blackMarketData, MsgType.MapPoiListInDB)
setmetatable(MsgType.LbsMapDataInDB.mainTaskData, MsgType.MapPoiListInDB)
setmetatable(MsgType.LbsMapDataInDB.bulkTaskData, MsgType.MapPoiListInDB)
setmetatable(MsgType.LbsMapDataInDB.starTaskData, MsgType.MapPoiListInDB)
setmetatable(MsgType.LbsMapDataInDB.stepData, MsgType.LbsMapStepInfoInDB)

function MsgType.LbsMapDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LbsMapDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    tb.c = self.location:Encode()
    tb.d = self.shopData:Encode()
    tb.e = self.blackMarketData:Encode()
    tb.f = self.mainTaskData:Encode()
    tb.g = self.bulkTaskData:Encode()
    tb.h = self.starTaskData:Encode()
    tb.i = self.stepData:Encode()
    return tb
end

function MsgType.LbsMapDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.location = MsgType.LbsMapLocationInDB:New()
    self.shopData = MsgType.MapPoiListInDB:New()
    self.blackMarketData = MsgType.MapPoiListInDB:New()
    self.mainTaskData = MsgType.MapPoiListInDB:New()
    self.bulkTaskData = MsgType.MapPoiListInDB:New()
    self.starTaskData = MsgType.MapPoiListInDB:New()
    self.stepData = MsgType.LbsMapStepInfoInDB:New()
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.location:Decode(data.c)
    end
    if nil ~= data.d then
        self.shopData:Decode(data.d)
    end
    if nil ~= data.e then
        self.blackMarketData:Decode(data.e)
    end
    if nil ~= data.f then
        self.mainTaskData:Decode(data.f)
    end
    if nil ~= data.g then
        self.bulkTaskData:Decode(data.g)
    end
    if nil ~= data.h then
        self.starTaskData:Decode(data.h)
    end
    if nil ~= data.i then
        self.stepData:Decode(data.i)
    end
    return self
end

function MsgType.LbsMapDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FeelingSingle = {
    npcId = 0,
    feeling = 0,
    rewardFlag = 0
}
MsgType.FeelingSingle.__index = MsgType.FeelingSingle

function MsgType.FeelingSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FeelingSingle:Encode()
    local tb = {}
    if nil ~= self.npcId and 0 ~= self.npcId then
        tb.b = self.npcId
    end
    if nil ~= self.feeling and 0 ~= self.feeling then
        tb.c = self.feeling
    end
    if nil ~= self.rewardFlag and 0 ~= self.rewardFlag then
        tb.d = self.rewardFlag
    end
    return tb
end

function MsgType.FeelingSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.npcId = 0
    self.feeling = 0
    self.rewardFlag = 0
    if nil ~= data.b then
        self.npcId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.feeling = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    return self
end

function MsgType.FeelingSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FeelingSingleInDB = {
    npcID = 0,
    feeling = 0,
    rewardFlag = 0
}
MsgType.FeelingSingleInDB.__index = MsgType.FeelingSingleInDB

function MsgType.FeelingSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FeelingSingleInDB:Encode()
    local tb = {}
    if nil ~= self.npcID and 0 ~= self.npcID then
        tb.b = self.npcID
    end
    if nil ~= self.feeling and 0 ~= self.feeling then
        tb.c = self.feeling
    end
    if nil ~= self.rewardFlag and 0 ~= self.rewardFlag then
        tb.d = self.rewardFlag
    end
    return tb
end

function MsgType.FeelingSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.npcID = 0
    self.feeling = 0
    self.rewardFlag = 0
    if nil ~= data.b then
        self.npcID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.feeling = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    return self
end

function MsgType.FeelingSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FeelingChapterInDB = {
}

MsgType.FeelingDataInDB = {
}

MsgType.FriendSingle = {
    createTime = 0,
    roleUID = 0
}
MsgType.FriendSingle.__index = MsgType.FriendSingle

function MsgType.FriendSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendSingle:Encode()
    local tb = {}
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.b = self.createTime
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    return tb
end

function MsgType.FriendSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.createTime = 0
    self.roleUID = 0
    if nil ~= data.b then
        self.createTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    return self
end

function MsgType.FriendSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FansSingle = {
    createTime = 0,
    roleUID = 0
}
MsgType.FansSingle.__index = MsgType.FansSingle

function MsgType.FansSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FansSingle:Encode()
    local tb = {}
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.b = self.createTime
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    return tb
end

function MsgType.FansSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.createTime = 0
    self.roleUID = 0
    if nil ~= data.b then
        self.createTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    return self
end

function MsgType.FansSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FollowSingle = {
    createTime = 0,
    roleUID = 0
}
MsgType.FollowSingle.__index = MsgType.FollowSingle

function MsgType.FollowSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FollowSingle:Encode()
    local tb = {}
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.b = self.createTime
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    return tb
end

function MsgType.FollowSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.createTime = 0
    self.roleUID = 0
    if nil ~= data.b then
        self.createTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    return self
end

function MsgType.FollowSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendSendApSingle = {
    roleUID = 0,
    lastSendTime = 0,
    sendCount = 0
}
MsgType.FriendSendApSingle.__index = MsgType.FriendSendApSingle

function MsgType.FriendSendApSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendSendApSingle:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.lastSendTime and 0 ~= self.lastSendTime then
        tb.c = self.lastSendTime
    end
    if nil ~= self.sendCount and 0 ~= self.sendCount then
        tb.d = self.sendCount
    end
    return tb
end

function MsgType.FriendSendApSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.lastSendTime = 0
    self.sendCount = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastSendTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.sendCount = tonumber(data.d) or 0
    end
    return self
end

function MsgType.FriendSendApSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendRequestApSingle = {
    roleUID = 0,
    lastRequestTime = 0
}
MsgType.FriendRequestApSingle.__index = MsgType.FriendRequestApSingle

function MsgType.FriendRequestApSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendRequestApSingle:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.lastRequestTime and 0 ~= self.lastRequestTime then
        tb.c = self.lastRequestTime
    end
    return tb
end

function MsgType.FriendRequestApSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.lastRequestTime = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastRequestTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.FriendRequestApSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendSingleInMsg = {
    roleUID = 0,
    roleName = "",
    roleLevel = 0,
    onlineStatus = 0, --enum EFriendStatusType
    onlineStatusTime = 0,
    sendApCDTime = 0,
    equipCollect = 0,
    musicCollect = 0,
    danceCollect = 0,
    totalLevelCount = 0,
    portraitID = 0,
    roomID = 0,
    workerPoint = 0,
    builderPoint = 0,
    UgcLevelList = ""
}
MsgType.FriendSingleInMsg.__index = MsgType.FriendSingleInMsg

function MsgType.FriendSingleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendSingleInMsg:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.roleLevel and 0 ~= self.roleLevel then
        tb.d = self.roleLevel
    end
    if nil ~= self.onlineStatus and 0 ~= self.onlineStatus then
        tb.e = self.onlineStatus
    end
    if nil ~= self.onlineStatusTime and 0 ~= self.onlineStatusTime then
        tb.f = self.onlineStatusTime
    end
    if nil ~= self.sendApCDTime and 0 ~= self.sendApCDTime then
        tb.g = self.sendApCDTime
    end
    if nil ~= self.equipCollect and 0 ~= self.equipCollect then
        tb.h = self.equipCollect
    end
    if nil ~= self.musicCollect and 0 ~= self.musicCollect then
        tb.i = self.musicCollect
    end
    if nil ~= self.danceCollect and 0 ~= self.danceCollect then
        tb.j = self.danceCollect
    end
    if nil ~= self.totalLevelCount and 0 ~= self.totalLevelCount then
        tb.k = self.totalLevelCount
    end
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.l = self.portraitID
    end
    if nil ~= self.roomID and 0 ~= self.roomID then
        tb.m = self.roomID
    end
    if nil ~= self.workerPoint and 0 ~= self.workerPoint then
        tb.n = self.workerPoint
    end
    if nil ~= self.builderPoint and 0 ~= self.builderPoint then
        tb.o = self.builderPoint
    end
    if nil ~= self.UgcLevelList and string.len(self.UgcLevelList) > 0 then
        tb.p = self.UgcLevelList
    end
    return tb
end

function MsgType.FriendSingleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.roleName = ""
    self.roleLevel = 0
    self.onlineStatus = 0
    self.onlineStatusTime = 0
    self.sendApCDTime = 0
    self.equipCollect = 0
    self.musicCollect = 0
    self.danceCollect = 0
    self.totalLevelCount = 0
    self.portraitID = 0
    self.roomID = 0
    self.workerPoint = 0
    self.builderPoint = 0
    self.UgcLevelList = ""
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.onlineStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.onlineStatusTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sendApCDTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.equipCollect = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.musicCollect = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.danceCollect = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.totalLevelCount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.portraitID = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.roomID = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.workerPoint = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.builderPoint = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.UgcLevelList = tostring(data.p)
    end
    return self
end

function MsgType.FriendSingleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FansMsg = {
    roleUID = 0,
    roleName = "",
    portraitID = 0,
    UgcLevelList = "",
    workerPoint = 0,
    builderPoint = 0
}
MsgType.FansMsg.__index = MsgType.FansMsg

function MsgType.FansMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FansMsg:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.d = self.portraitID
    end
    if nil ~= self.UgcLevelList and string.len(self.UgcLevelList) > 0 then
        tb.e = self.UgcLevelList
    end
    if nil ~= self.workerPoint and 0 ~= self.workerPoint then
        tb.f = self.workerPoint
    end
    if nil ~= self.builderPoint and 0 ~= self.builderPoint then
        tb.g = self.builderPoint
    end
    return tb
end

function MsgType.FansMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.roleName = ""
    self.portraitID = 0
    self.UgcLevelList = ""
    self.workerPoint = 0
    self.builderPoint = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.portraitID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.UgcLevelList = tostring(data.e)
    end
    if nil ~= data.f then
        self.workerPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.builderPoint = tonumber(data.g) or 0
    end
    return self
end

function MsgType.FansMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendListInDB = {
}

MsgType.FriendApplyListInDB = {
}

MsgType.FriendBlackListInDB = {
}

MsgType.FansListInDB = {
}

MsgType.FollowListInDB = {
}

MsgType.FriendApDataInDB = {
}

MsgType.ItemInMailAttachment = {
    itemID = 0,
    itemNum = 0
}
MsgType.ItemInMailAttachment.__index = MsgType.ItemInMailAttachment

function MsgType.ItemInMailAttachment:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemInMailAttachment:Encode()
    local tb = {}
    if nil ~= self.itemID and 0 ~= self.itemID then
        tb.b = self.itemID
    end
    if nil ~= self.itemNum and 0 ~= self.itemNum then
        tb.c = self.itemNum
    end
    return tb
end

function MsgType.ItemInMailAttachment:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemID = 0
    self.itemNum = 0
    if nil ~= data.b then
        self.itemID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemNum = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ItemInMailAttachment:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailAttachment = {
    itemList = {} -- array of MsgType.ItemInMailAttachment
}
MsgType.MailAttachment.__index = MsgType.MailAttachment

function MsgType.MailAttachment:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailAttachment:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.MailAttachment:Encode()
    local tb = {}
    tb.b = self:_itemListEncode()
    return tb
end

function MsgType.MailAttachment:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpItemListObj = MsgType.ItemInMailAttachment:New()
            tmpItemListObj:Decode(data.b[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end

function MsgType.MailAttachment:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailSimpleInMsg = {
    mailID = 0,
    mailType = 0, --enum EMailTypeInMsg
    mailReason = 0,
    readStatus = 0, --enum EMailReadStatusInMsg
    haveAttachment = 0,
    sendTime = 0,
    leftTime = 0,
    senderUID = 0,
    senderName = "",
    mailTitle = "",
    mailContent = ""
}
MsgType.MailSimpleInMsg.__index = MsgType.MailSimpleInMsg

function MsgType.MailSimpleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailSimpleInMsg:Encode()
    local tb = {}
    if nil ~= self.mailID and 0 ~= self.mailID then
        tb.b = self.mailID
    end
    if nil ~= self.mailType and 0 ~= self.mailType then
        tb.c = self.mailType
    end
    if nil ~= self.mailReason and 0 ~= self.mailReason then
        tb.d = self.mailReason
    end
    if nil ~= self.readStatus and 0 ~= self.readStatus then
        tb.e = self.readStatus
    end
    if nil ~= self.haveAttachment and 0 ~= self.haveAttachment then
        tb.f = self.haveAttachment
    end
    if nil ~= self.sendTime and 0 ~= self.sendTime then
        tb.g = self.sendTime
    end
    if nil ~= self.leftTime and 0 ~= self.leftTime then
        tb.h = self.leftTime
    end
    if nil ~= self.senderUID and 0 ~= self.senderUID then
        tb.i = self.senderUID
    end
    if nil ~= self.senderName and string.len(self.senderName) > 0 then
        tb.j = self.senderName
    end
    if nil ~= self.mailTitle and string.len(self.mailTitle) > 0 then
        tb.k = self.mailTitle
    end
    if nil ~= self.mailContent and string.len(self.mailContent) > 0 then
        tb.l = self.mailContent
    end
    return tb
end

function MsgType.MailSimpleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mailID = 0
    self.mailType = 0
    self.mailReason = 0
    self.readStatus = 0
    self.haveAttachment = 0
    self.sendTime = 0
    self.leftTime = 0
    self.senderUID = 0
    self.senderName = ""
    self.mailTitle = ""
    self.mailContent = ""
    if nil ~= data.b then
        self.mailID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.mailType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.mailReason = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.readStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.haveAttachment = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sendTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.leftTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.senderUID = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.senderName = tostring(data.j)
    end
    if nil ~= data.k then
        self.mailTitle = tostring(data.k)
    end
    if nil ~= data.l then
        self.mailContent = tostring(data.l)
    end
    return self
end

function MsgType.MailSimpleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailDetailInMsg = {
    mailSimple = {},
    senderUID = 0,
    senderName = "",
    attachment = {}
}
MsgType.MailDetailInMsg.__index = MsgType.MailDetailInMsg
setmetatable(MsgType.MailDetailInMsg.mailSimple, MsgType.MailSimpleInMsg)
setmetatable(MsgType.MailDetailInMsg.attachment, MsgType.MailAttachment)

function MsgType.MailDetailInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailDetailInMsg:Encode()
    local tb = {}
    tb.b = self.mailSimple:Encode()
    if nil ~= self.senderUID and 0 ~= self.senderUID then
        tb.c = self.senderUID
    end
    if nil ~= self.senderName and string.len(self.senderName) > 0 then
        tb.d = self.senderName
    end
    tb.e = self.attachment:Encode()
    return tb
end

function MsgType.MailDetailInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mailSimple = MsgType.MailSimpleInMsg:New()
    self.senderUID = 0
    self.senderName = ""
    self.attachment = MsgType.MailAttachment:New()
    if nil ~= data.b then
        self.mailSimple:Decode(data.b)
    end
    if nil ~= data.c then
        self.senderUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.senderName = tostring(data.d)
    end
    if nil ~= data.e then
        self.attachment:Decode(data.e)
    end
    return self
end

function MsgType.MailDetailInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailContInDB = {
    senderUID = 0,
    senderName = "",
    attachment = {}
}
MsgType.MailContInDB.__index = MsgType.MailContInDB
setmetatable(MsgType.MailContInDB.attachment, MsgType.MailAttachment)

function MsgType.MailContInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailContInDB:Encode()
    local tb = {}
    if nil ~= self.senderUID and 0 ~= self.senderUID then
        tb.b = self.senderUID
    end
    if nil ~= self.senderName and string.len(self.senderName) > 0 then
        tb.c = self.senderName
    end
    tb.d = self.attachment:Encode()
    return tb
end

function MsgType.MailContInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.senderUID = 0
    self.senderName = ""
    self.attachment = MsgType.MailAttachment:New()
    if nil ~= data.b then
        self.senderUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.senderName = tostring(data.c)
    end
    if nil ~= data.d then
        self.attachment:Decode(data.d)
    end
    return self
end

function MsgType.MailContInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailExtInfoInDB = {
    senderUID = 0,
    senderName = "",
    hasAttachment = 0
}
MsgType.MailExtInfoInDB.__index = MsgType.MailExtInfoInDB

function MsgType.MailExtInfoInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailExtInfoInDB:Encode()
    local tb = {}
    if nil ~= self.senderUID and 0 ~= self.senderUID then
        tb.b = self.senderUID
    end
    if nil ~= self.senderName and string.len(self.senderName) > 0 then
        tb.c = self.senderName
    end
    if nil ~= self.hasAttachment and 0 ~= self.hasAttachment then
        tb.d = self.hasAttachment
    end
    return tb
end

function MsgType.MailExtInfoInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.senderUID = 0
    self.senderName = ""
    self.hasAttachment = 0
    if nil ~= data.b then
        self.senderUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.senderName = tostring(data.c)
    end
    if nil ~= data.d then
        self.hasAttachment = tonumber(data.d) or 0
    end
    return self
end

function MsgType.MailExtInfoInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailContTextInDB = {
    mailTitle = "",
    mailContent = ""
}
MsgType.MailContTextInDB.__index = MsgType.MailContTextInDB

function MsgType.MailContTextInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailContTextInDB:Encode()
    local tb = {}
    if nil ~= self.mailTitle and string.len(self.mailTitle) > 0 then
        tb.b = self.mailTitle
    end
    if nil ~= self.mailContent and string.len(self.mailContent) > 0 then
        tb.c = self.mailContent
    end
    return tb
end

function MsgType.MailContTextInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mailTitle = ""
    self.mailContent = ""
    if nil ~= data.b then
        self.mailTitle = tostring(data.b)
    end
    if nil ~= data.c then
        self.mailContent = tostring(data.c)
    end
    return self
end

function MsgType.MailContTextInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MailSenderSingleInMsg = {
    roleUID = 0,
    roleName = "",
    roleLevel = 0,
    onlineStatus = 0, --enum EFriendStatusType
    onlineStatusTime = 0,
    sendApCDTime = 0,
    equipCollect = 0,
    musicCollect = 0,
    danceCollect = 0,
    totalLevelCount = 0,
    portraitID = 0
}
MsgType.MailSenderSingleInMsg.__index = MsgType.MailSenderSingleInMsg

function MsgType.MailSenderSingleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MailSenderSingleInMsg:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.roleLevel and 0 ~= self.roleLevel then
        tb.d = self.roleLevel
    end
    if nil ~= self.onlineStatus and 0 ~= self.onlineStatus then
        tb.e = self.onlineStatus
    end
    if nil ~= self.onlineStatusTime and 0 ~= self.onlineStatusTime then
        tb.f = self.onlineStatusTime
    end
    if nil ~= self.sendApCDTime and 0 ~= self.sendApCDTime then
        tb.g = self.sendApCDTime
    end
    if nil ~= self.equipCollect and 0 ~= self.equipCollect then
        tb.h = self.equipCollect
    end
    if nil ~= self.musicCollect and 0 ~= self.musicCollect then
        tb.i = self.musicCollect
    end
    if nil ~= self.danceCollect and 0 ~= self.danceCollect then
        tb.j = self.danceCollect
    end
    if nil ~= self.totalLevelCount and 0 ~= self.totalLevelCount then
        tb.k = self.totalLevelCount
    end
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.l = self.portraitID
    end
    return tb
end

function MsgType.MailSenderSingleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.roleName = ""
    self.roleLevel = 0
    self.onlineStatus = 0
    self.onlineStatusTime = 0
    self.sendApCDTime = 0
    self.equipCollect = 0
    self.musicCollect = 0
    self.danceCollect = 0
    self.totalLevelCount = 0
    self.portraitID = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.onlineStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.onlineStatusTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sendApCDTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.equipCollect = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.musicCollect = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.danceCollect = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.totalLevelCount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.portraitID = tonumber(data.l) or 0
    end
    return self
end

function MsgType.MailSenderSingleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EquipsInLevelData = {
    equipList = {} -- array of number
}
MsgType.EquipsInLevelData.__index = MsgType.EquipsInLevelData

function MsgType.EquipsInLevelData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EquipsInLevelData:Encode()
    local tb = {}
    if nil ~= self.equipList and string.len(self.equipList) > 0 then
        tb.b = self.equipList
    end
    return tb
end

function MsgType.EquipsInLevelData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.equipList = {}
    if nil ~= data.b and #data.b > 0 then
        for i=1, #data.b do
            self.equipList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.EquipsInLevelData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelSingle = {
    levelID = 0,
    refreshTime = 0
}
MsgType.LevelSingle.__index = MsgType.LevelSingle

function MsgType.LevelSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelSingle:Encode()
    local tb = {}
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.b = self.levelID
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.c = self.refreshTime
    end
    return tb
end

function MsgType.LevelSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelID = 0
    self.refreshTime = 0
    if nil ~= data.b then
        self.levelID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.refreshTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.LevelSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelCopyData = {
    insID = "",
    enterTime = 0,
    enterLevel = 0,
    isCostAp = 0,
    selectItems = {}, -- array of number
    rewards = {}, -- array of MsgType.ItemDisplayerInfo
    sk = "",
    isRewarded = 0,
    isDouble = 0
}
MsgType.LevelCopyData.__index = MsgType.LevelCopyData

function MsgType.LevelCopyData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelCopyData:_rewardsEncode()
    local tb = {}
    for i=1, #self.rewards do
        tb[i] = self.rewards[i]:encode()
    end
    return tb
end
function MsgType.LevelCopyData:Encode()
    local tb = {}
    if nil ~= self.insID and string.len(self.insID) > 0 then
        tb.b = self.insID
    end
    if nil ~= self.enterTime and 0 ~= self.enterTime then
        tb.c = self.enterTime
    end
    if nil ~= self.enterLevel and 0 ~= self.enterLevel then
        tb.d = self.enterLevel
    end
    if nil ~= self.isCostAp and 0 ~= self.isCostAp then
        tb.e = self.isCostAp
    end
    if nil ~= self.selectItems and string.len(self.selectItems) > 0 then
        tb.f = self.selectItems
    end
    tb.g = self:_rewardsEncode()
    if nil ~= self.sk and string.len(self.sk) > 0 then
        tb.h = self.sk
    end
    if nil ~= self.isRewarded and 0 ~= self.isRewarded then
        tb.i = self.isRewarded
    end
    if nil ~= self.isDouble and 0 ~= self.isDouble then
        tb.j = self.isDouble
    end
    return tb
end

function MsgType.LevelCopyData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.insID = ""
    self.enterTime = 0
    self.enterLevel = 0
    self.isCostAp = 0
    self.selectItems = {}
    self.rewards = {}
    self.sk = ""
    self.isRewarded = 0
    self.isDouble = 0
    if nil ~= data.b then
        self.insID = tostring(data.b)
    end
    if nil ~= data.c then
        self.enterTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.enterLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isCostAp = tonumber(data.e) or 0
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.selectItems[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardsObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardsObj:Decode(data.g[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    if nil ~= data.h then
        self.sk = tostring(data.h)
    end
    if nil ~= data.i then
        self.isRewarded = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.isDouble = tonumber(data.j) or 0
    end
    return self
end

function MsgType.LevelCopyData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelDataInDB = {
}

MsgType.LevelTopSingle = {
    createTime = 0,
    roleUID = 0,
    roleName = "",
    score = 0,
    equipList = {}
}
MsgType.LevelTopSingle.__index = MsgType.LevelTopSingle
setmetatable(MsgType.LevelTopSingle.equipList, MsgType.EquipsInLevelData)

function MsgType.LevelTopSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelTopSingle:Encode()
    local tb = {}
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.b = self.createTime
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.d = self.roleName
    end
    if nil ~= self.score and 0 ~= self.score then
        tb.e = self.score
    end
    tb.f = self.equipList:Encode()
    return tb
end

function MsgType.LevelTopSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.createTime = 0
    self.roleUID = 0
    self.roleName = ""
    self.score = 0
    self.equipList = MsgType.EquipsInLevelData:New()
    if nil ~= data.b then
        self.createTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.score = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.equipList:Decode(data.f)
    end
    return self
end

function MsgType.LevelTopSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelTopSingleInMsg = {
    rank = 0,
    roleName = "",
    score = 0
}
MsgType.LevelTopSingleInMsg.__index = MsgType.LevelTopSingleInMsg

function MsgType.LevelTopSingleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelTopSingleInMsg:Encode()
    local tb = {}
    if nil ~= self.rank and 0 ~= self.rank then
        tb.b = self.rank
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.score and 0 ~= self.score then
        tb.d = self.score
    end
    return tb
end

function MsgType.LevelTopSingleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.rank = 0
    self.roleName = ""
    self.score = 0
    if nil ~= data.b then
        self.rank = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.score = tonumber(data.d) or 0
    end
    return self
end

function MsgType.LevelTopSingleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelTopArray = {
    levelID = 0,
    singleList = {} -- array of MsgType.LevelTopSingle
}
MsgType.LevelTopArray.__index = MsgType.LevelTopArray

function MsgType.LevelTopArray:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelTopArray:_singleListEncode()
    local tb = {}
    for i=1, #self.singleList do
        tb[i] = self.singleList[i]:encode()
    end
    return tb
end
function MsgType.LevelTopArray:Encode()
    local tb = {}
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.b = self.levelID
    end
    tb.c = self:_singleListEncode()
    return tb
end

function MsgType.LevelTopArray:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelID = 0
    self.singleList = {}
    if nil ~= data.b then
        self.levelID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpSingleListObj = MsgType.LevelTopSingle:New()
            tmpSingleListObj:Decode(data.c[i])
            self.singleList[i] = tmpSingleListObj
        end
    end
    return self
end

function MsgType.LevelTopArray:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelTopDataInDB = {
}

MsgType.OfflineChatSingle = {
    chatType = 0,
    chatCont = "",
    sendTime = 0,
    sourceRoleUID = 0,
    sourceRoleName = "",
    targetRoleUID = 0,
    targetRoleName = ""
}
MsgType.OfflineChatSingle.__index = MsgType.OfflineChatSingle

function MsgType.OfflineChatSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OfflineChatSingle:Encode()
    local tb = {}
    if nil ~= self.chatType and 0 ~= self.chatType then
        tb.b = self.chatType
    end
    if nil ~= self.chatCont and string.len(self.chatCont) > 0 then
        tb.c = self.chatCont
    end
    if nil ~= self.sendTime and 0 ~= self.sendTime then
        tb.d = self.sendTime
    end
    if nil ~= self.sourceRoleUID and 0 ~= self.sourceRoleUID then
        tb.e = self.sourceRoleUID
    end
    if nil ~= self.sourceRoleName and string.len(self.sourceRoleName) > 0 then
        tb.f = self.sourceRoleName
    end
    if nil ~= self.targetRoleUID and 0 ~= self.targetRoleUID then
        tb.g = self.targetRoleUID
    end
    if nil ~= self.targetRoleName and string.len(self.targetRoleName) > 0 then
        tb.h = self.targetRoleName
    end
    return tb
end

function MsgType.OfflineChatSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.chatType = 0
    self.chatCont = ""
    self.sendTime = 0
    self.sourceRoleUID = 0
    self.sourceRoleName = ""
    self.targetRoleUID = 0
    self.targetRoleName = ""
    if nil ~= data.b then
        self.chatType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.chatCont = tostring(data.c)
    end
    if nil ~= data.d then
        self.sendTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.sourceRoleUID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.sourceRoleName = tostring(data.f)
    end
    if nil ~= data.g then
        self.targetRoleUID = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.targetRoleName = tostring(data.h)
    end
    return self
end

function MsgType.OfflineChatSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.OfflineChatDataInDB = {
    roleUID = 0,
    offlineChatList = {} -- array of MsgType.OfflineChatSingle
}
MsgType.OfflineChatDataInDB.__index = MsgType.OfflineChatDataInDB

function MsgType.OfflineChatDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OfflineChatDataInDB:_offlineChatListEncode()
    local tb = {}
    for i=1, #self.offlineChatList do
        tb[i] = self.offlineChatList[i]:encode()
    end
    return tb
end
function MsgType.OfflineChatDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    tb.c = self:_offlineChatListEncode()
    return tb
end

function MsgType.OfflineChatDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.offlineChatList = {}
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpOfflineChatListObj = MsgType.OfflineChatSingle:New()
            tmpOfflineChatListObj:Decode(data.c[i])
            self.offlineChatList[i] = tmpOfflineChatListObj
        end
    end
    return self
end

function MsgType.OfflineChatDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetSingleInDB = {
    petID = 0,
    addTime = 0,
    petLevel = 0,
    petExp = 0,
    isDance = 0,
    isShow = 0,
    showRoom = 0,
    bindRoom = 0,
    bindFurniture = 0,
    taskID = 0
}
MsgType.PetSingleInDB.__index = MsgType.PetSingleInDB

function MsgType.PetSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetSingleInDB:Encode()
    local tb = {}
    if nil ~= self.petID and 0 ~= self.petID then
        tb.b = self.petID
    end
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.c = self.addTime
    end
    if nil ~= self.petLevel and 0 ~= self.petLevel then
        tb.d = self.petLevel
    end
    if nil ~= self.petExp and 0 ~= self.petExp then
        tb.e = self.petExp
    end
    if nil ~= self.isDance and 0 ~= self.isDance then
        tb.f = self.isDance
    end
    if nil ~= self.isShow and 0 ~= self.isShow then
        tb.g = self.isShow
    end
    if nil ~= self.showRoom and 0 ~= self.showRoom then
        tb.h = self.showRoom
    end
    if nil ~= self.bindRoom and 0 ~= self.bindRoom then
        tb.i = self.bindRoom
    end
    if nil ~= self.bindFurniture and 0 ~= self.bindFurniture then
        tb.j = self.bindFurniture
    end
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.k = self.taskID
    end
    return tb
end

function MsgType.PetSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.petID = 0
    self.addTime = 0
    self.petLevel = 0
    self.petExp = 0
    self.isDance = 0
    self.isShow = 0
    self.showRoom = 0
    self.bindRoom = 0
    self.bindFurniture = 0
    self.taskID = 0
    if nil ~= data.b then
        self.petID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.addTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.petLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.petExp = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isDance = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.isShow = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.showRoom = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.bindRoom = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.bindFurniture = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.taskID = tonumber(data.k) or 0
    end
    return self
end

function MsgType.PetSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetRoomSingleInDB = {
    roomID = 0,
    addTime = 0,
    bindFloorID = 0,
    bindFloorPosition = 0
}
MsgType.PetRoomSingleInDB.__index = MsgType.PetRoomSingleInDB

function MsgType.PetRoomSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetRoomSingleInDB:Encode()
    local tb = {}
    if nil ~= self.roomID and 0 ~= self.roomID then
        tb.b = self.roomID
    end
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.c = self.addTime
    end
    if nil ~= self.bindFloorID and 0 ~= self.bindFloorID then
        tb.d = self.bindFloorID
    end
    if nil ~= self.bindFloorPosition and 0 ~= self.bindFloorPosition then
        tb.e = self.bindFloorPosition
    end
    return tb
end

function MsgType.PetRoomSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roomID = 0
    self.addTime = 0
    self.bindFloorID = 0
    self.bindFloorPosition = 0
    if nil ~= data.b then
        self.roomID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.addTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.bindFloorID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.bindFloorPosition = tonumber(data.e) or 0
    end
    return self
end

function MsgType.PetRoomSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetFloorSingleInDB = {
    floorID = 0,
    addTime = 0
}
MsgType.PetFloorSingleInDB.__index = MsgType.PetFloorSingleInDB

function MsgType.PetFloorSingleInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetFloorSingleInDB:Encode()
    local tb = {}
    if nil ~= self.floorID and 0 ~= self.floorID then
        tb.b = self.floorID
    end
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.c = self.addTime
    end
    return tb
end

function MsgType.PetFloorSingleInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.floorID = 0
    self.addTime = 0
    if nil ~= data.b then
        self.floorID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.addTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.PetFloorSingleInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetAcceptTaskInfoInDB = {
    petID = 0,
    acceptEventList = {} -- array of number
}
MsgType.PetAcceptTaskInfoInDB.__index = MsgType.PetAcceptTaskInfoInDB

function MsgType.PetAcceptTaskInfoInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetAcceptTaskInfoInDB:Encode()
    local tb = {}
    if nil ~= self.petID and 0 ~= self.petID then
        tb.b = self.petID
    end
    if nil ~= self.acceptEventList and string.len(self.acceptEventList) > 0 then
        tb.c = self.acceptEventList
    end
    return tb
end

function MsgType.PetAcceptTaskInfoInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.petID = 0
    self.acceptEventList = {}
    if nil ~= data.b then
        self.petID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.acceptEventList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.PetAcceptTaskInfoInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetInteractionInfoInDB = {
    petID = 0,
    interactionCount = 0
}
MsgType.PetInteractionInfoInDB.__index = MsgType.PetInteractionInfoInDB

function MsgType.PetInteractionInfoInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetInteractionInfoInDB:Encode()
    local tb = {}
    if nil ~= self.petID and 0 ~= self.petID then
        tb.b = self.petID
    end
    if nil ~= self.interactionCount and 0 ~= self.interactionCount then
        tb.c = self.interactionCount
    end
    return tb
end

function MsgType.PetInteractionInfoInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.petID = 0
    self.interactionCount = 0
    if nil ~= data.b then
        self.petID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.interactionCount = tonumber(data.c) or 0
    end
    return self
end

function MsgType.PetInteractionInfoInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetDataInDB = {
}

MsgType.PetListDataInDB = {
}

MsgType.PetRoomDataInDB = {
}

MsgType.PetFloorDataInDB = {
}

MsgType.PetFloorInMsg = {
    floorID = 0
}
MsgType.PetFloorInMsg.__index = MsgType.PetFloorInMsg

function MsgType.PetFloorInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetFloorInMsg:Encode()
    local tb = {}
    if nil ~= self.floorID and 0 ~= self.floorID then
        tb.b = self.floorID
    end
    return tb
end

function MsgType.PetFloorInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.floorID = 0
    if nil ~= data.b then
        self.floorID = tonumber(data.b) or 0
    end
    return self
end

function MsgType.PetFloorInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetRoomInMsg = {
    roomID = 0,
    bindFloorID = 0,
    bindFloorPosition = 0 --enum EPetRoomInFloorPositionType
}
MsgType.PetRoomInMsg.__index = MsgType.PetRoomInMsg

function MsgType.PetRoomInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetRoomInMsg:Encode()
    local tb = {}
    if nil ~= self.roomID and 0 ~= self.roomID then
        tb.b = self.roomID
    end
    if nil ~= self.bindFloorID and 0 ~= self.bindFloorID then
        tb.c = self.bindFloorID
    end
    if nil ~= self.bindFloorPosition and 0 ~= self.bindFloorPosition then
        tb.d = self.bindFloorPosition
    end
    return tb
end

function MsgType.PetRoomInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roomID = 0
    self.bindFloorID = 0
    self.bindFloorPosition = 0
    if nil ~= data.b then
        self.roomID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.bindFloorID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.bindFloorPosition = tonumber(data.d) or 0
    end
    return self
end

function MsgType.PetRoomInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetSingleInMsg = {
    petID = 0,
    petLevel = 0,
    petExp = 0,
    isDance = 0,
    isShow = 0,
    showRoom = 0,
    bindRoom = 0,
    bindFurniture = 0,
    taskID = 0
}
MsgType.PetSingleInMsg.__index = MsgType.PetSingleInMsg

function MsgType.PetSingleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetSingleInMsg:Encode()
    local tb = {}
    if nil ~= self.petID and 0 ~= self.petID then
        tb.b = self.petID
    end
    if nil ~= self.petLevel and 0 ~= self.petLevel then
        tb.c = self.petLevel
    end
    if nil ~= self.petExp and 0 ~= self.petExp then
        tb.d = self.petExp
    end
    if nil ~= self.isDance and 0 ~= self.isDance then
        tb.e = self.isDance
    end
    if nil ~= self.isShow and 0 ~= self.isShow then
        tb.f = self.isShow
    end
    if nil ~= self.showRoom and 0 ~= self.showRoom then
        tb.g = self.showRoom
    end
    if nil ~= self.bindRoom and 0 ~= self.bindRoom then
        tb.h = self.bindRoom
    end
    if nil ~= self.bindFurniture and 0 ~= self.bindFurniture then
        tb.i = self.bindFurniture
    end
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.j = self.taskID
    end
    return tb
end

function MsgType.PetSingleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.petID = 0
    self.petLevel = 0
    self.petExp = 0
    self.isDance = 0
    self.isShow = 0
    self.showRoom = 0
    self.bindRoom = 0
    self.bindFurniture = 0
    self.taskID = 0
    if nil ~= data.b then
        self.petID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.petLevel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.petExp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isDance = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isShow = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.showRoom = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.bindRoom = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.bindFurniture = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.taskID = tonumber(data.j) or 0
    end
    return self
end

function MsgType.PetSingleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopSampleInMsg = {
    shopID = 0,
    shopActivityID = 0,
    shopActivityStartTime = 0,
    shopActivityEndTime = 0
}
MsgType.ShopSampleInMsg.__index = MsgType.ShopSampleInMsg

function MsgType.ShopSampleInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopSampleInMsg:Encode()
    local tb = {}
    if nil ~= self.shopID and 0 ~= self.shopID then
        tb.b = self.shopID
    end
    if nil ~= self.shopActivityID and 0 ~= self.shopActivityID then
        tb.c = self.shopActivityID
    end
    if nil ~= self.shopActivityStartTime and 0 ~= self.shopActivityStartTime then
        tb.d = self.shopActivityStartTime
    end
    if nil ~= self.shopActivityEndTime and 0 ~= self.shopActivityEndTime then
        tb.e = self.shopActivityEndTime
    end
    return tb
end

function MsgType.ShopSampleInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.shopID = 0
    self.shopActivityID = 0
    self.shopActivityStartTime = 0
    self.shopActivityEndTime = 0
    if nil ~= data.b then
        self.shopID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.shopActivityID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.shopActivityStartTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.shopActivityEndTime = tonumber(data.e) or 0
    end
    return self
end

function MsgType.ShopSampleInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopGoodsInMsg = {
    goodsID = 0,
    goodsType = 0,
    itemID = 0,
    itemNum = 0,
    moneyType = 0,
    price = 0,
    startTime = 0,
    endTime = 0,
    sort = 0
}
MsgType.ShopGoodsInMsg.__index = MsgType.ShopGoodsInMsg

function MsgType.ShopGoodsInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopGoodsInMsg:Encode()
    local tb = {}
    if nil ~= self.goodsID and 0 ~= self.goodsID then
        tb.b = self.goodsID
    end
    if nil ~= self.goodsType and 0 ~= self.goodsType then
        tb.c = self.goodsType
    end
    if nil ~= self.itemID and 0 ~= self.itemID then
        tb.d = self.itemID
    end
    if nil ~= self.itemNum and 0 ~= self.itemNum then
        tb.e = self.itemNum
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.f = self.moneyType
    end
    if nil ~= self.price and 0 ~= self.price then
        tb.g = self.price
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.h = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.i = self.endTime
    end
    if nil ~= self.sort and 0 ~= self.sort then
        tb.j = self.sort
    end
    return tb
end

function MsgType.ShopGoodsInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.goodsID = 0
    self.goodsType = 0
    self.itemID = 0
    self.itemNum = 0
    self.moneyType = 0
    self.price = 0
    self.startTime = 0
    self.endTime = 0
    self.sort = 0
    if nil ~= data.b then
        self.goodsID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.goodsType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemNum = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.moneyType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.price = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.startTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.endTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.sort = tonumber(data.j) or 0
    end
    return self
end

function MsgType.ShopGoodsInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopVipCardInMsg = {
    ownerRoleUID = 0,
    ownerRoleName = "",
    vipID = 0,
    vipLevel = 0
}
MsgType.ShopVipCardInMsg.__index = MsgType.ShopVipCardInMsg

function MsgType.ShopVipCardInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopVipCardInMsg:Encode()
    local tb = {}
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.b = self.ownerRoleUID
    end
    if nil ~= self.ownerRoleName and string.len(self.ownerRoleName) > 0 then
        tb.c = self.ownerRoleName
    end
    if nil ~= self.vipID and 0 ~= self.vipID then
        tb.d = self.vipID
    end
    if nil ~= self.vipLevel and 0 ~= self.vipLevel then
        tb.e = self.vipLevel
    end
    return tb
end

function MsgType.ShopVipCardInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ownerRoleUID = 0
    self.ownerRoleName = ""
    self.vipID = 0
    self.vipLevel = 0
    if nil ~= data.b then
        self.ownerRoleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.ownerRoleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.vipID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.vipLevel = tonumber(data.e) or 0
    end
    return self
end

function MsgType.ShopVipCardInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopBuyGoodsInMsg = {
    goodsID = 0,
    buyNum = 0
}
MsgType.ShopBuyGoodsInMsg.__index = MsgType.ShopBuyGoodsInMsg

function MsgType.ShopBuyGoodsInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopBuyGoodsInMsg:Encode()
    local tb = {}
    if nil ~= self.goodsID and 0 ~= self.goodsID then
        tb.b = self.goodsID
    end
    if nil ~= self.buyNum and 0 ~= self.buyNum then
        tb.c = self.buyNum
    end
    return tb
end

function MsgType.ShopBuyGoodsInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.goodsID = 0
    self.buyNum = 0
    if nil ~= data.b then
        self.goodsID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buyNum = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ShopBuyGoodsInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopVipCard = {
    vipID = 0,
    vipLevel = 0,
    vipExp = 0
}
MsgType.ShopVipCard.__index = MsgType.ShopVipCard

function MsgType.ShopVipCard:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopVipCard:Encode()
    local tb = {}
    if nil ~= self.vipID and 0 ~= self.vipID then
        tb.b = self.vipID
    end
    if nil ~= self.vipLevel and 0 ~= self.vipLevel then
        tb.c = self.vipLevel
    end
    if nil ~= self.vipExp and 0 ~= self.vipExp then
        tb.d = self.vipExp
    end
    return tb
end

function MsgType.ShopVipCard:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.vipID = 0
    self.vipLevel = 0
    self.vipExp = 0
    if nil ~= data.b then
        self.vipID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.vipLevel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.vipExp = tonumber(data.d) or 0
    end
    return self
end

function MsgType.ShopVipCard:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ShopVipCardDataInDB = {
}

MsgType.RedTipSingle = {
    tipType = 0, --enum ERedTipType
    tipParam = 0,
    tipCount = 0
}
MsgType.RedTipSingle.__index = MsgType.RedTipSingle

function MsgType.RedTipSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RedTipSingle:Encode()
    local tb = {}
    if nil ~= self.tipType and 0 ~= self.tipType then
        tb.b = self.tipType
    end
    if nil ~= self.tipParam and 0 ~= self.tipParam then
        tb.c = self.tipParam
    end
    if nil ~= self.tipCount and 0 ~= self.tipCount then
        tb.d = self.tipCount
    end
    return tb
end

function MsgType.RedTipSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.tipType = 0
    self.tipParam = 0
    self.tipCount = 0
    if nil ~= data.b then
        self.tipType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.tipParam = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.tipCount = tonumber(data.d) or 0
    end
    return self
end

function MsgType.RedTipSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RedTipDataInDB = {
}

MsgType.RedTip = {
    tipType = 0, --enum ERedTipType
    tipCount = 0
}
MsgType.RedTip.__index = MsgType.RedTip

function MsgType.RedTip:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RedTip:Encode()
    local tb = {}
    if nil ~= self.tipType and 0 ~= self.tipType then
        tb.b = self.tipType
    end
    if nil ~= self.tipCount and 0 ~= self.tipCount then
        tb.c = self.tipCount
    end
    return tb
end

function MsgType.RedTip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.tipType = 0
    self.tipCount = 0
    if nil ~= data.b then
        self.tipType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.tipCount = tonumber(data.c) or 0
    end
    return self
end

function MsgType.RedTip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.DanceBallDataInDB = {
    roleUID = 0,
    refreshTime = 0,
    joinBallTimes = 0,
    createBallTimes = 0
}
MsgType.DanceBallDataInDB.__index = MsgType.DanceBallDataInDB

function MsgType.DanceBallDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.DanceBallDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.c = self.refreshTime
    end
    if nil ~= self.joinBallTimes and 0 ~= self.joinBallTimes then
        tb.d = self.joinBallTimes
    end
    if nil ~= self.createBallTimes and 0 ~= self.createBallTimes then
        tb.e = self.createBallTimes
    end
    return tb
end

function MsgType.DanceBallDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.refreshTime = 0
    self.joinBallTimes = 0
    self.createBallTimes = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.refreshTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.joinBallTimes = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.createBallTimes = tonumber(data.e) or 0
    end
    return self
end

function MsgType.DanceBallDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.DanceBallInMsg = {
    mapServerID = 0,
    danceBallID = 0,
    createrRoleUID = 0,
    createrRoleName = "",
    danceBallName = "",
    roleList = {}, -- array of number
    maxJoinNum = 0,
    startTime = 0,
    endTime = 0,
    danceBallStatus = 0 --enum EDanceBallStatus
}
MsgType.DanceBallInMsg.__index = MsgType.DanceBallInMsg

function MsgType.DanceBallInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.DanceBallInMsg:Encode()
    local tb = {}
    if nil ~= self.mapServerID and 0 ~= self.mapServerID then
        tb.b = self.mapServerID
    end
    if nil ~= self.danceBallID and 0 ~= self.danceBallID then
        tb.c = self.danceBallID
    end
    if nil ~= self.createrRoleUID and 0 ~= self.createrRoleUID then
        tb.d = self.createrRoleUID
    end
    if nil ~= self.createrRoleName and string.len(self.createrRoleName) > 0 then
        tb.e = self.createrRoleName
    end
    if nil ~= self.danceBallName and string.len(self.danceBallName) > 0 then
        tb.f = self.danceBallName
    end
    if nil ~= self.roleList and string.len(self.roleList) > 0 then
        tb.g = self.roleList
    end
    if nil ~= self.maxJoinNum and 0 ~= self.maxJoinNum then
        tb.h = self.maxJoinNum
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.i = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.j = self.endTime
    end
    if nil ~= self.danceBallStatus and 0 ~= self.danceBallStatus then
        tb.k = self.danceBallStatus
    end
    return tb
end

function MsgType.DanceBallInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mapServerID = 0
    self.danceBallID = 0
    self.createrRoleUID = 0
    self.createrRoleName = ""
    self.danceBallName = ""
    self.roleList = {}
    self.maxJoinNum = 0
    self.startTime = 0
    self.endTime = 0
    self.danceBallStatus = 0
    if nil ~= data.b then
        self.mapServerID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.danceBallID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.createrRoleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.createrRoleName = tostring(data.e)
    end
    if nil ~= data.f then
        self.danceBallName = tostring(data.f)
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.roleList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.h then
        self.maxJoinNum = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.startTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.endTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.danceBallStatus = tonumber(data.k) or 0
    end
    return self
end

function MsgType.DanceBallInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoleDanceBallInfoInMsg = {
    remainJoinTimes = 0,
    maxJoinTimes = 0,
    remainCreateTimes = 0,
    curJoinDanceBallID = 0,
    joinType = 0 --enum EDanceBallJoinType
}
MsgType.RoleDanceBallInfoInMsg.__index = MsgType.RoleDanceBallInfoInMsg

function MsgType.RoleDanceBallInfoInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleDanceBallInfoInMsg:Encode()
    local tb = {}
    if nil ~= self.remainJoinTimes and 0 ~= self.remainJoinTimes then
        tb.b = self.remainJoinTimes
    end
    if nil ~= self.maxJoinTimes and 0 ~= self.maxJoinTimes then
        tb.c = self.maxJoinTimes
    end
    if nil ~= self.remainCreateTimes and 0 ~= self.remainCreateTimes then
        tb.d = self.remainCreateTimes
    end
    if nil ~= self.curJoinDanceBallID and 0 ~= self.curJoinDanceBallID then
        tb.e = self.curJoinDanceBallID
    end
    if nil ~= self.joinType and 0 ~= self.joinType then
        tb.f = self.joinType
    end
    return tb
end

function MsgType.RoleDanceBallInfoInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.remainJoinTimes = 0
    self.maxJoinTimes = 0
    self.remainCreateTimes = 0
    self.curJoinDanceBallID = 0
    self.joinType = 0
    if nil ~= data.b then
        self.remainJoinTimes = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.maxJoinTimes = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.remainCreateTimes = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.curJoinDanceBallID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.joinType = tonumber(data.f) or 0
    end
    return self
end

function MsgType.RoleDanceBallInfoInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.OneMapSlotData = {
    slotID = 0,
    slotStatus = 0 --enum EMapSlotEventStatus
}
MsgType.OneMapSlotData.__index = MsgType.OneMapSlotData

function MsgType.OneMapSlotData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneMapSlotData:Encode()
    local tb = {}
    if nil ~= self.slotID and 0 ~= self.slotID then
        tb.b = self.slotID
    end
    if nil ~= self.slotStatus and 0 ~= self.slotStatus then
        tb.c = self.slotStatus
    end
    return tb
end

function MsgType.OneMapSlotData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.slotID = 0
    self.slotStatus = 0
    if nil ~= data.b then
        self.slotID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.slotStatus = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneMapSlotData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.OneMapData = {
}

MsgType.MapData = {
}

MsgType.OneMapInMsg = {
    mapID = 0,
    templateID = 0
}
MsgType.OneMapInMsg.__index = MsgType.OneMapInMsg

function MsgType.OneMapInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneMapInMsg:Encode()
    local tb = {}
    if nil ~= self.mapID and 0 ~= self.mapID then
        tb.b = self.mapID
    end
    if nil ~= self.templateID and 0 ~= self.templateID then
        tb.c = self.templateID
    end
    return tb
end

function MsgType.OneMapInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mapID = 0
    self.templateID = 0
    if nil ~= data.b then
        self.mapID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.templateID = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneMapInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MapDataInMsg = {
    curCityID = 0,
    curMapLevel = 0,
    curMapID = 0,
    curSlotID = 0,
    curSlotStatus = 0, --enum EMapSlotEventStatus
    mapList = {} -- array of MsgType.OneMapInMsg
}
MsgType.MapDataInMsg.__index = MsgType.MapDataInMsg

function MsgType.MapDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MapDataInMsg:_mapListEncode()
    local tb = {}
    for i=1, #self.mapList do
        tb[i] = self.mapList[i]:encode()
    end
    return tb
end
function MsgType.MapDataInMsg:Encode()
    local tb = {}
    if nil ~= self.curCityID and 0 ~= self.curCityID then
        tb.b = self.curCityID
    end
    if nil ~= self.curMapLevel and 0 ~= self.curMapLevel then
        tb.c = self.curMapLevel
    end
    if nil ~= self.curMapID and 0 ~= self.curMapID then
        tb.d = self.curMapID
    end
    if nil ~= self.curSlotID and 0 ~= self.curSlotID then
        tb.e = self.curSlotID
    end
    if nil ~= self.curSlotStatus and 0 ~= self.curSlotStatus then
        tb.f = self.curSlotStatus
    end
    tb.g = self:_mapListEncode()
    return tb
end

function MsgType.MapDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curCityID = 0
    self.curMapLevel = 0
    self.curMapID = 0
    self.curSlotID = 0
    self.curSlotStatus = 0
    self.mapList = {}
    if nil ~= data.b then
        self.curCityID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.curMapLevel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.curMapID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.curSlotID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.curSlotStatus = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpMapListObj = MsgType.OneMapInMsg:New()
            tmpMapListObj:Decode(data.g[i])
            self.mapList[i] = tmpMapListObj
        end
    end
    return self
end

function MsgType.MapDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ChatChannelInfo = {
    channelID = 0,
    channelName = "",
    channelStatus = 0 --enum EChatChannelStatusType
}
MsgType.ChatChannelInfo.__index = MsgType.ChatChannelInfo

function MsgType.ChatChannelInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ChatChannelInfo:Encode()
    local tb = {}
    if nil ~= self.channelID and 0 ~= self.channelID then
        tb.b = self.channelID
    end
    if nil ~= self.channelName and string.len(self.channelName) > 0 then
        tb.c = self.channelName
    end
    if nil ~= self.channelStatus and 0 ~= self.channelStatus then
        tb.d = self.channelStatus
    end
    return tb
end

function MsgType.ChatChannelInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.channelID = 0
    self.channelName = ""
    self.channelStatus = 0
    if nil ~= data.b then
        self.channelID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.channelName = tostring(data.c)
    end
    if nil ~= data.d then
        self.channelStatus = tonumber(data.d) or 0
    end
    return self
end

function MsgType.ChatChannelInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ActionPointData = {
    actionPoint = 0,
    buyNum = 0,
    lastResetTime = 0,
    lastAutoRecoverTime = 0,
    limitlessStartTime = 0,
    limitlessEndTime = 0
}
MsgType.ActionPointData.__index = MsgType.ActionPointData

function MsgType.ActionPointData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ActionPointData:Encode()
    local tb = {}
    if nil ~= self.actionPoint and 0 ~= self.actionPoint then
        tb.b = self.actionPoint
    end
    if nil ~= self.buyNum and 0 ~= self.buyNum then
        tb.c = self.buyNum
    end
    if nil ~= self.lastResetTime and 0 ~= self.lastResetTime then
        tb.d = self.lastResetTime
    end
    if nil ~= self.lastAutoRecoverTime and 0 ~= self.lastAutoRecoverTime then
        tb.e = self.lastAutoRecoverTime
    end
    if nil ~= self.limitlessStartTime and 0 ~= self.limitlessStartTime then
        tb.f = self.limitlessStartTime
    end
    if nil ~= self.limitlessEndTime and 0 ~= self.limitlessEndTime then
        tb.g = self.limitlessEndTime
    end
    return tb
end

function MsgType.ActionPointData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.actionPoint = 0
    self.buyNum = 0
    self.lastResetTime = 0
    self.lastAutoRecoverTime = 0
    self.limitlessStartTime = 0
    self.limitlessEndTime = 0
    if nil ~= data.b then
        self.actionPoint = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buyNum = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastResetTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.lastAutoRecoverTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.limitlessStartTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.limitlessEndTime = tonumber(data.g) or 0
    end
    return self
end

function MsgType.ActionPointData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ActionPointDataClient = {
    actionPoint = 0,
    buyNum = 0,
    lastAutoRecoverTime = 0,
    autoRecoverRemainTime = 0,
    limitlessStartTime = 0,
    limitlessEndTime = 0,
    limitlessRemainTime = 0
}
MsgType.ActionPointDataClient.__index = MsgType.ActionPointDataClient

function MsgType.ActionPointDataClient:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ActionPointDataClient:Encode()
    local tb = {}
    if nil ~= self.actionPoint and 0 ~= self.actionPoint then
        tb.b = self.actionPoint
    end
    if nil ~= self.buyNum and 0 ~= self.buyNum then
        tb.c = self.buyNum
    end
    if nil ~= self.lastAutoRecoverTime and 0 ~= self.lastAutoRecoverTime then
        tb.d = self.lastAutoRecoverTime
    end
    if nil ~= self.autoRecoverRemainTime and 0 ~= self.autoRecoverRemainTime then
        tb.e = self.autoRecoverRemainTime
    end
    if nil ~= self.limitlessStartTime and 0 ~= self.limitlessStartTime then
        tb.f = self.limitlessStartTime
    end
    if nil ~= self.limitlessEndTime and 0 ~= self.limitlessEndTime then
        tb.g = self.limitlessEndTime
    end
    if nil ~= self.limitlessRemainTime and 0 ~= self.limitlessRemainTime then
        tb.h = self.limitlessRemainTime
    end
    return tb
end

function MsgType.ActionPointDataClient:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.actionPoint = 0
    self.buyNum = 0
    self.lastAutoRecoverTime = 0
    self.autoRecoverRemainTime = 0
    self.limitlessStartTime = 0
    self.limitlessEndTime = 0
    self.limitlessRemainTime = 0
    if nil ~= data.b then
        self.actionPoint = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buyNum = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastAutoRecoverTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.autoRecoverRemainTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.limitlessStartTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.limitlessEndTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.limitlessRemainTime = tonumber(data.h) or 0
    end
    return self
end

function MsgType.ActionPointDataClient:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.VipData = {
    vipLevel = 0,
    vipExp = 0
}
MsgType.VipData.__index = MsgType.VipData

function MsgType.VipData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.VipData:Encode()
    local tb = {}
    if nil ~= self.vipLevel and 0 ~= self.vipLevel then
        tb.b = self.vipLevel
    end
    if nil ~= self.vipExp and 0 ~= self.vipExp then
        tb.c = self.vipExp
    end
    return tb
end

function MsgType.VipData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.vipLevel = 0
    self.vipExp = 0
    if nil ~= data.b then
        self.vipLevel = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.vipExp = tonumber(data.c) or 0
    end
    return self
end

function MsgType.VipData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GoldenHandData = {
    buyNum = 0,
    lastResetTime = 0
}
MsgType.GoldenHandData.__index = MsgType.GoldenHandData

function MsgType.GoldenHandData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GoldenHandData:Encode()
    local tb = {}
    if nil ~= self.buyNum and 0 ~= self.buyNum then
        tb.b = self.buyNum
    end
    if nil ~= self.lastResetTime and 0 ~= self.lastResetTime then
        tb.c = self.lastResetTime
    end
    return tb
end

function MsgType.GoldenHandData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.buyNum = 0
    self.lastResetTime = 0
    if nil ~= data.b then
        self.buyNum = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastResetTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.GoldenHandData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PortraitData = {
    currentPortaitID = 0,
    portraits = {} -- array of number
}
MsgType.PortraitData.__index = MsgType.PortraitData

function MsgType.PortraitData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PortraitData:Encode()
    local tb = {}
    if nil ~= self.currentPortaitID and 0 ~= self.currentPortaitID then
        tb.b = self.currentPortaitID
    end
    if nil ~= self.portraits and string.len(self.portraits) > 0 then
        tb.c = self.portraits
    end
    return tb
end

function MsgType.PortraitData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentPortaitID = 0
    self.portraits = {}
    if nil ~= data.b then
        self.currentPortaitID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.portraits[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.PortraitData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.BackgroundData = {
    currentBackgroundID = 0,
    backgrounds = {} -- array of number
}
MsgType.BackgroundData.__index = MsgType.BackgroundData

function MsgType.BackgroundData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BackgroundData:Encode()
    local tb = {}
    if nil ~= self.currentBackgroundID and 0 ~= self.currentBackgroundID then
        tb.b = self.currentBackgroundID
    end
    if nil ~= self.backgrounds and string.len(self.backgrounds) > 0 then
        tb.c = self.backgrounds
    end
    return tb
end

function MsgType.BackgroundData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentBackgroundID = 0
    self.backgrounds = {}
    if nil ~= data.b then
        self.currentBackgroundID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.backgrounds[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.BackgroundData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.DogData = {
    dogName = ""
}
MsgType.DogData.__index = MsgType.DogData

function MsgType.DogData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.DogData:Encode()
    local tb = {}
    if nil ~= self.dogName and string.len(self.dogName) > 0 then
        tb.b = self.dogName
    end
    return tb
end

function MsgType.DogData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.dogName = ""
    if nil ~= data.b then
        self.dogName = tostring(data.b)
    end
    return self
end

function MsgType.DogData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoleBindAccountData = {
    bindEmail = "",
    bindFbAccount = "",
    bindFbName = "",
    bindGoogleAccount = "",
    bindGoogleName = "",
    bindGameCenterAccount = "",
    bindGameCenterName = ""
}
MsgType.RoleBindAccountData.__index = MsgType.RoleBindAccountData

function MsgType.RoleBindAccountData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleBindAccountData:Encode()
    local tb = {}
    if nil ~= self.bindEmail and string.len(self.bindEmail) > 0 then
        tb.b = self.bindEmail
    end
    if nil ~= self.bindFbAccount and string.len(self.bindFbAccount) > 0 then
        tb.c = self.bindFbAccount
    end
    if nil ~= self.bindFbName and string.len(self.bindFbName) > 0 then
        tb.d = self.bindFbName
    end
    if nil ~= self.bindGoogleAccount and string.len(self.bindGoogleAccount) > 0 then
        tb.e = self.bindGoogleAccount
    end
    if nil ~= self.bindGoogleName and string.len(self.bindGoogleName) > 0 then
        tb.f = self.bindGoogleName
    end
    if nil ~= self.bindGameCenterAccount and string.len(self.bindGameCenterAccount) > 0 then
        tb.g = self.bindGameCenterAccount
    end
    if nil ~= self.bindGameCenterName and string.len(self.bindGameCenterName) > 0 then
        tb.h = self.bindGameCenterName
    end
    return tb
end

function MsgType.RoleBindAccountData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.bindEmail = ""
    self.bindFbAccount = ""
    self.bindFbName = ""
    self.bindGoogleAccount = ""
    self.bindGoogleName = ""
    self.bindGameCenterAccount = ""
    self.bindGameCenterName = ""
    if nil ~= data.b then
        self.bindEmail = tostring(data.b)
    end
    if nil ~= data.c then
        self.bindFbAccount = tostring(data.c)
    end
    if nil ~= data.d then
        self.bindFbName = tostring(data.d)
    end
    if nil ~= data.e then
        self.bindGoogleAccount = tostring(data.e)
    end
    if nil ~= data.f then
        self.bindGoogleName = tostring(data.f)
    end
    if nil ~= data.g then
        self.bindGameCenterAccount = tostring(data.g)
    end
    if nil ~= data.h then
        self.bindGameCenterName = tostring(data.h)
    end
    return self
end

function MsgType.RoleBindAccountData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoleBaseInDB = {
    roleUid = 0,
    deviceID = "",
    roleName = "",
    account = "",
    roleCreateTime = 0,
    lastLoginTime = 0,
    totalOnlineTime = 0,
    totalLoginTimes = 0,
    gold = 0,
    ugcGold = 0,
    stone = 0,
    wPoint = 0,
    bPoint = 0,
    actionPointData = {},
    ugcActionPointData = {},
    portraitData = {},
    backgroundData = {},
    dogData = {},
    lockTime = 0,
    region = "",
    coin = 0,
    introduction = "",
    blux = ""
}
MsgType.RoleBaseInDB.__index = MsgType.RoleBaseInDB
setmetatable(MsgType.RoleBaseInDB.actionPointData, MsgType.ActionPointData)
setmetatable(MsgType.RoleBaseInDB.ugcActionPointData, MsgType.ActionPointData)
setmetatable(MsgType.RoleBaseInDB.portraitData, MsgType.PortraitData)
setmetatable(MsgType.RoleBaseInDB.backgroundData, MsgType.BackgroundData)
setmetatable(MsgType.RoleBaseInDB.dogData, MsgType.DogData)

function MsgType.RoleBaseInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleBaseInDB:Encode()
    local tb = {}
    if nil ~= self.roleUid and 0 ~= self.roleUid then
        tb.b = self.roleUid
    end
    if nil ~= self.deviceID and string.len(self.deviceID) > 0 then
        tb.c = self.deviceID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.d = self.roleName
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.e = self.account
    end
    if nil ~= self.roleCreateTime and 0 ~= self.roleCreateTime then
        tb.f = self.roleCreateTime
    end
    if nil ~= self.lastLoginTime and 0 ~= self.lastLoginTime then
        tb.g = self.lastLoginTime
    end
    if nil ~= self.totalOnlineTime and 0 ~= self.totalOnlineTime then
        tb.h = self.totalOnlineTime
    end
    if nil ~= self.totalLoginTimes and 0 ~= self.totalLoginTimes then
        tb.i = self.totalLoginTimes
    end
    if nil ~= self.gold and 0 ~= self.gold then
        tb.j = self.gold
    end
    if nil ~= self.ugcGold and 0 ~= self.ugcGold then
        tb.k = self.ugcGold
    end
    if nil ~= self.stone and 0 ~= self.stone then
        tb.l = self.stone
    end
    if nil ~= self.wPoint and 0 ~= self.wPoint then
        tb.m = self.wPoint
    end
    if nil ~= self.bPoint and 0 ~= self.bPoint then
        tb.n = self.bPoint
    end
    tb.o = self.actionPointData:Encode()
    tb.p = self.ugcActionPointData:Encode()
    tb.q = self.portraitData:Encode()
    tb.r = self.backgroundData:Encode()
    tb.s = self.dogData:Encode()
    if nil ~= self.lockTime and 0 ~= self.lockTime then
        tb.t = self.lockTime
    end
    if nil ~= self.region and string.len(self.region) > 0 then
        tb.u = self.region
    end
    if nil ~= self.coin and 0 ~= self.coin then
        tb.v = self.coin
    end
    if nil ~= self.introduction and string.len(self.introduction) > 0 then
        tb.w = self.introduction
    end
    if nil ~= self.blux and string.len(self.blux) > 0 then
        tb.x = self.blux
    end
    return tb
end

function MsgType.RoleBaseInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUid = 0
    self.deviceID = ""
    self.roleName = ""
    self.account = ""
    self.roleCreateTime = 0
    self.lastLoginTime = 0
    self.totalOnlineTime = 0
    self.totalLoginTimes = 0
    self.gold = 0
    self.ugcGold = 0
    self.stone = 0
    self.wPoint = 0
    self.bPoint = 0
    self.actionPointData = MsgType.ActionPointData:New()
    self.ugcActionPointData = MsgType.ActionPointData:New()
    self.portraitData = MsgType.PortraitData:New()
    self.backgroundData = MsgType.BackgroundData:New()
    self.dogData = MsgType.DogData:New()
    self.lockTime = 0
    self.region = ""
    self.coin = 0
    self.introduction = ""
    self.blux = ""
    if nil ~= data.b then
        self.roleUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.deviceID = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.account = tostring(data.e)
    end
    if nil ~= data.f then
        self.roleCreateTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.lastLoginTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.totalOnlineTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.totalLoginTimes = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.gold = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.ugcGold = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.stone = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.wPoint = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.bPoint = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.actionPointData:Decode(data.o)
    end
    if nil ~= data.p then
        self.ugcActionPointData:Decode(data.p)
    end
    if nil ~= data.q then
        self.portraitData:Decode(data.q)
    end
    if nil ~= data.r then
        self.backgroundData:Decode(data.r)
    end
    if nil ~= data.s then
        self.dogData:Decode(data.s)
    end
    if nil ~= data.t then
        self.lockTime = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.region = tostring(data.u)
    end
    if nil ~= data.v then
        self.coin = tonumber(data.v) or 0
    end
    if nil ~= data.w then
        self.introduction = tostring(data.w)
    end
    if nil ~= data.x then
        self.blux = tostring(data.x)
    end
    return self
end

function MsgType.RoleBaseInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.DeviceRoleInfo = {
    isNewRole = 0,
    account = "",
    deviceID = "",
    roleUID = 0,
    roleName = "",
    portraitID = 0,
    gold = 0,
    star = 0,
    levelNum = 0
}
MsgType.DeviceRoleInfo.__index = MsgType.DeviceRoleInfo

function MsgType.DeviceRoleInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.DeviceRoleInfo:Encode()
    local tb = {}
    if nil ~= self.isNewRole and 0 ~= self.isNewRole then
        tb.b = self.isNewRole
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.c = self.account
    end
    if nil ~= self.deviceID and string.len(self.deviceID) > 0 then
        tb.d = self.deviceID
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.e = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.f = self.roleName
    end
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.g = self.portraitID
    end
    if nil ~= self.gold and 0 ~= self.gold then
        tb.h = self.gold
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.i = self.star
    end
    if nil ~= self.levelNum and 0 ~= self.levelNum then
        tb.j = self.levelNum
    end
    return tb
end

function MsgType.DeviceRoleInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isNewRole = 0
    self.account = ""
    self.deviceID = ""
    self.roleUID = 0
    self.roleName = ""
    self.portraitID = 0
    self.gold = 0
    self.star = 0
    self.levelNum = 0
    if nil ~= data.b then
        self.isNewRole = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.deviceID = tostring(data.d)
    end
    if nil ~= data.e then
        self.roleUID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.roleName = tostring(data.f)
    end
    if nil ~= data.g then
        self.portraitID = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.gold = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.star = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.levelNum = tonumber(data.j) or 0
    end
    return self
end

function MsgType.DeviceRoleInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ItemDataDB = {
    itemUId = 0,
    itemType = 0,
    count = 0,
    flag = 0
}
MsgType.ItemDataDB.__index = MsgType.ItemDataDB

function MsgType.ItemDataDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemDataDB:Encode()
    local tb = {}
    if nil ~= self.itemUId and 0 ~= self.itemUId then
        tb.b = self.itemUId
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.d = self.count
    end
    if nil ~= self.flag and 0 ~= self.flag then
        tb.e = self.flag
    end
    return tb
end

function MsgType.ItemDataDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemUId = 0
    self.itemType = 0
    self.count = 0
    self.flag = 0
    if nil ~= data.b then
        self.itemUId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.count = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.flag = tonumber(data.e) or 0
    end
    return self
end

function MsgType.ItemDataDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ItemSysInDB = {
}

MsgType.ItemDisplayerInfo = {
    itemType = 0,
    count = 0
}
MsgType.ItemDisplayerInfo.__index = MsgType.ItemDisplayerInfo

function MsgType.ItemDisplayerInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemDisplayerInfo:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.ItemDisplayerInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ItemDisplayerInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoleBriefInfo = {
    roleUid = 0,
    roleName = "",
    gold = 0,
    ugcGold = 0,
    stone = 0,
    workerPoint = 0,
    builderPoint = 0,
    actionPointData = {},
    ugcActionPointData = {},
    goldenHandData = {},
    portraitData = {},
    backgroundData = {},
    dogData = {},
    coin = 0,
    blux = ""
}
MsgType.RoleBriefInfo.__index = MsgType.RoleBriefInfo
setmetatable(MsgType.RoleBriefInfo.actionPointData, MsgType.ActionPointDataClient)
setmetatable(MsgType.RoleBriefInfo.ugcActionPointData, MsgType.ActionPointDataClient)
setmetatable(MsgType.RoleBriefInfo.goldenHandData, MsgType.GoldenHandData)
setmetatable(MsgType.RoleBriefInfo.portraitData, MsgType.PortraitData)
setmetatable(MsgType.RoleBriefInfo.backgroundData, MsgType.BackgroundData)
setmetatable(MsgType.RoleBriefInfo.dogData, MsgType.DogData)

function MsgType.RoleBriefInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleBriefInfo:Encode()
    local tb = {}
    if nil ~= self.roleUid and 0 ~= self.roleUid then
        tb.b = self.roleUid
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.gold and 0 ~= self.gold then
        tb.d = self.gold
    end
    if nil ~= self.ugcGold and 0 ~= self.ugcGold then
        tb.e = self.ugcGold
    end
    if nil ~= self.stone and 0 ~= self.stone then
        tb.f = self.stone
    end
    if nil ~= self.workerPoint and 0 ~= self.workerPoint then
        tb.g = self.workerPoint
    end
    if nil ~= self.builderPoint and 0 ~= self.builderPoint then
        tb.h = self.builderPoint
    end
    tb.i = self.actionPointData:Encode()
    tb.j = self.ugcActionPointData:Encode()
    tb.k = self.goldenHandData:Encode()
    tb.l = self.portraitData:Encode()
    tb.m = self.backgroundData:Encode()
    tb.n = self.dogData:Encode()
    if nil ~= self.coin and 0 ~= self.coin then
        tb.o = self.coin
    end
    if nil ~= self.blux and string.len(self.blux) > 0 then
        tb.p = self.blux
    end
    return tb
end

function MsgType.RoleBriefInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUid = 0
    self.roleName = ""
    self.gold = 0
    self.ugcGold = 0
    self.stone = 0
    self.workerPoint = 0
    self.builderPoint = 0
    self.actionPointData = MsgType.ActionPointDataClient:New()
    self.ugcActionPointData = MsgType.ActionPointDataClient:New()
    self.goldenHandData = MsgType.GoldenHandData:New()
    self.portraitData = MsgType.PortraitData:New()
    self.backgroundData = MsgType.BackgroundData:New()
    self.dogData = MsgType.DogData:New()
    self.coin = 0
    self.blux = ""
    if nil ~= data.b then
        self.roleUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.gold = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.ugcGold = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.stone = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.workerPoint = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.builderPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.actionPointData:Decode(data.i)
    end
    if nil ~= data.j then
        self.ugcActionPointData:Decode(data.j)
    end
    if nil ~= data.k then
        self.goldenHandData:Decode(data.k)
    end
    if nil ~= data.l then
        self.portraitData:Decode(data.l)
    end
    if nil ~= data.m then
        self.backgroundData:Decode(data.m)
    end
    if nil ~= data.n then
        self.dogData:Decode(data.n)
    end
    if nil ~= data.o then
        self.coin = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.blux = tostring(data.p)
    end
    return self
end

function MsgType.RoleBriefInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.SingleCopyStatisticsInfo = {
    getStars = {}, -- array of number
    standardVal = 0,
    expectationVal = {} -- array of number
}
MsgType.SingleCopyStatisticsInfo.__index = MsgType.SingleCopyStatisticsInfo

function MsgType.SingleCopyStatisticsInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.SingleCopyStatisticsInfo:Encode()
    local tb = {}
    if nil ~= self.getStars and string.len(self.getStars) > 0 then
        tb.b = self.getStars
    end
    if nil ~= self.standardVal and 0 ~= self.standardVal then
        tb.c = self.standardVal
    end
    if nil ~= self.expectationVal and string.len(self.expectationVal) > 0 then
        tb.d = self.expectationVal
    end
    return tb
end

function MsgType.SingleCopyStatisticsInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.getStars = {}
    self.standardVal = 0
    self.expectationVal = {}
    if nil ~= data.b and #data.b > 0 then
        for i=1, #data.b do
            self.getStars[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.c then
        self.standardVal = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.expectationVal[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.SingleCopyStatisticsInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.SingleCopyTargetInfo = {
    targetID = "",
    targetNum = 0,
    targetReach = 0
}
MsgType.SingleCopyTargetInfo.__index = MsgType.SingleCopyTargetInfo

function MsgType.SingleCopyTargetInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.SingleCopyTargetInfo:Encode()
    local tb = {}
    if nil ~= self.targetID and string.len(self.targetID) > 0 then
        tb.b = self.targetID
    end
    if nil ~= self.targetNum and 0 ~= self.targetNum then
        tb.c = self.targetNum
    end
    if nil ~= self.targetReach and 0 ~= self.targetReach then
        tb.d = self.targetReach
    end
    return tb
end

function MsgType.SingleCopyTargetInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.targetID = ""
    self.targetNum = 0
    self.targetReach = 0
    if nil ~= data.b then
        self.targetID = tostring(data.b)
    end
    if nil ~= data.c then
        self.targetNum = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.targetReach = tonumber(data.d) or 0
    end
    return self
end

function MsgType.SingleCopyTargetInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.SingleCopyResultInfo = {
    resultType = 0, --enum ELevelResultType
    remainStep = 0,
    rewards = {}, -- array of MsgType.ItemDisplayerInfo
    costItems = {}, -- array of MsgType.ItemDisplayerInfo
    buyItems = {}, -- array of MsgType.ItemDisplayerInfo
    generateItems = {}, -- array of MsgType.ItemDisplayerInfo
    targets = {} -- array of MsgType.SingleCopyTargetInfo
}
MsgType.SingleCopyResultInfo.__index = MsgType.SingleCopyResultInfo

function MsgType.SingleCopyResultInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.SingleCopyResultInfo:_rewardsEncode()
    local tb = {}
    for i=1, #self.rewards do
        tb[i] = self.rewards[i]:encode()
    end
    return tb
end
function MsgType.SingleCopyResultInfo:_costItemsEncode()
    local tb = {}
    for i=1, #self.costItems do
        tb[i] = self.costItems[i]:encode()
    end
    return tb
end
function MsgType.SingleCopyResultInfo:_buyItemsEncode()
    local tb = {}
    for i=1, #self.buyItems do
        tb[i] = self.buyItems[i]:encode()
    end
    return tb
end
function MsgType.SingleCopyResultInfo:_generateItemsEncode()
    local tb = {}
    for i=1, #self.generateItems do
        tb[i] = self.generateItems[i]:encode()
    end
    return tb
end
function MsgType.SingleCopyResultInfo:_targetsEncode()
    local tb = {}
    for i=1, #self.targets do
        tb[i] = self.targets[i]:encode()
    end
    return tb
end
function MsgType.SingleCopyResultInfo:Encode()
    local tb = {}
    if nil ~= self.resultType and 0 ~= self.resultType then
        tb.b = self.resultType
    end
    if nil ~= self.remainStep and 0 ~= self.remainStep then
        tb.c = self.remainStep
    end
    tb.d = self:_rewardsEncode()
    tb.e = self:_costItemsEncode()
    tb.f = self:_buyItemsEncode()
    tb.g = self:_generateItemsEncode()
    tb.h = self:_targetsEncode()
    return tb
end

function MsgType.SingleCopyResultInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.resultType = 0
    self.remainStep = 0
    self.rewards = {}
    self.costItems = {}
    self.buyItems = {}
    self.generateItems = {}
    self.targets = {}
    if nil ~= data.b then
        self.resultType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.remainStep = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpRewardsObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardsObj:Decode(data.d[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpCostItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpCostItemsObj:Decode(data.e[i])
            self.costItems[i] = tmpCostItemsObj
        end
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpBuyItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpBuyItemsObj:Decode(data.f[i])
            self.buyItems[i] = tmpBuyItemsObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpGenerateItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpGenerateItemsObj:Decode(data.g[i])
            self.generateItems[i] = tmpGenerateItemsObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpTargetsObj = MsgType.SingleCopyTargetInfo:New()
            tmpTargetsObj:Decode(data.h[i])
            self.targets[i] = tmpTargetsObj
        end
    end
    return self
end

function MsgType.SingleCopyResultInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.BlackMarketDataInDB = {
    roleUID = 0,
    goodslist = {}, -- array of number
    totalCostOfLastBuy = {}, -- array of MsgType.ItemDisplayerInfo
    returnDiscountFlag = false
}
MsgType.BlackMarketDataInDB.__index = MsgType.BlackMarketDataInDB

function MsgType.BlackMarketDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BlackMarketDataInDB:_totalCostOfLastBuyEncode()
    local tb = {}
    for i=1, #self.totalCostOfLastBuy do
        tb[i] = self.totalCostOfLastBuy[i]:encode()
    end
    return tb
end
function MsgType.BlackMarketDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.goodslist and string.len(self.goodslist) > 0 then
        tb.c = self.goodslist
    end
    tb.d = self:_totalCostOfLastBuyEncode()
    if self.returnDiscountFlag then
        tb.e = self.returnDiscountFlag
    end
    return tb
end

function MsgType.BlackMarketDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.goodslist = {}
    self.totalCostOfLastBuy = {}
    self.returnDiscountFlag = false
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.goodslist[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpTotalCostOfLastBuyObj = MsgType.ItemDisplayerInfo:New()
            tmpTotalCostOfLastBuyObj:Decode(data.d[i])
            self.totalCostOfLastBuy[i] = tmpTotalCostOfLastBuyObj
        end
    end
    if nil ~= data.e then
        self.returnDiscountFlag = data.e
    end
    return self
end

function MsgType.BlackMarketDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TurntableDataInDB = {
    roleUID = 0,
    refreshTime = 0,
    usedCount = 0,
    areaId = 0
}
MsgType.TurntableDataInDB.__index = MsgType.TurntableDataInDB

function MsgType.TurntableDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TurntableDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.c = self.refreshTime
    end
    if nil ~= self.usedCount and 0 ~= self.usedCount then
        tb.d = self.usedCount
    end
    if nil ~= self.areaId and 0 ~= self.areaId then
        tb.e = self.areaId
    end
    return tb
end

function MsgType.TurntableDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.refreshTime = 0
    self.usedCount = 0
    self.areaId = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.refreshTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.usedCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.areaId = tonumber(data.e) or 0
    end
    return self
end

function MsgType.TurntableDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ItemDisplayerInfoE = {
    itemType = 0,
    count = 0,
    icon = ""
}
MsgType.ItemDisplayerInfoE.__index = MsgType.ItemDisplayerInfoE

function MsgType.ItemDisplayerInfoE:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemDisplayerInfoE:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    if nil ~= self.icon and string.len(self.icon) > 0 then
        tb.d = self.icon
    end
    return tb
end

function MsgType.ItemDisplayerInfoE:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    self.icon = ""
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.icon = tostring(data.d)
    end
    return self
end

function MsgType.ItemDisplayerInfoE:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TurntableDataItemList = {
    itemList = {}, -- array of MsgType.ItemDisplayerInfo
    icon = ""
}
MsgType.TurntableDataItemList.__index = MsgType.TurntableDataItemList

function MsgType.TurntableDataItemList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TurntableDataItemList:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.TurntableDataItemList:Encode()
    local tb = {}
    tb.b = self:_itemListEncode()
    if nil ~= self.icon and string.len(self.icon) > 0 then
        tb.c = self.icon
    end
    return tb
end

function MsgType.TurntableDataItemList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    self.icon = ""
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpItemListObj = MsgType.ItemDisplayerInfo:New()
            tmpItemListObj:Decode(data.b[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.c then
        self.icon = tostring(data.c)
    end
    return self
end

function MsgType.TurntableDataItemList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TurntableDataInMsg = {
    usedCount = 0,
    areaId = 0,
    itemList = {}, -- array of MsgType.TurntableDataItemList
    costItem = {}
}
MsgType.TurntableDataInMsg.__index = MsgType.TurntableDataInMsg
setmetatable(MsgType.TurntableDataInMsg.costItem, MsgType.ItemDisplayerInfo)

function MsgType.TurntableDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TurntableDataInMsg:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.TurntableDataInMsg:Encode()
    local tb = {}
    if nil ~= self.usedCount and 0 ~= self.usedCount then
        tb.b = self.usedCount
    end
    if nil ~= self.areaId and 0 ~= self.areaId then
        tb.c = self.areaId
    end
    tb.d = self:_itemListEncode()
    tb.e = self.costItem:Encode()
    return tb
end

function MsgType.TurntableDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.usedCount = 0
    self.areaId = 0
    self.itemList = {}
    self.costItem = MsgType.ItemDisplayerInfo:New()
    if nil ~= data.b then
        self.usedCount = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.areaId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpItemListObj = MsgType.TurntableDataItemList:New()
            tmpItemListObj:Decode(data.d[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.e then
        self.costItem:Decode(data.e)
    end
    return self
end

function MsgType.TurntableDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.WelfareDataInDB = {
    roleUID = 0,
    refreshTime = 0,
    activityID = 0,
    count = 0,
    lastOptTime = 0,
    cycle = 0
}
MsgType.WelfareDataInDB.__index = MsgType.WelfareDataInDB

function MsgType.WelfareDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WelfareDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.c = self.refreshTime
    end
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.d = self.activityID
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.e = self.count
    end
    if nil ~= self.lastOptTime and 0 ~= self.lastOptTime then
        tb.f = self.lastOptTime
    end
    if nil ~= self.cycle and 0 ~= self.cycle then
        tb.g = self.cycle
    end
    return tb
end

function MsgType.WelfareDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.refreshTime = 0
    self.activityID = 0
    self.count = 0
    self.lastOptTime = 0
    self.cycle = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.refreshTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.activityID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.count = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.lastOptTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.cycle = tonumber(data.g) or 0
    end
    return self
end

function MsgType.WelfareDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.WelfareDataItemList = {
    itemList = {} -- array of MsgType.ItemDisplayerInfoE
}
MsgType.WelfareDataItemList.__index = MsgType.WelfareDataItemList

function MsgType.WelfareDataItemList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WelfareDataItemList:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.WelfareDataItemList:Encode()
    local tb = {}
    tb.b = self:_itemListEncode()
    return tb
end

function MsgType.WelfareDataItemList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpItemListObj = MsgType.ItemDisplayerInfoE:New()
            tmpItemListObj:Decode(data.b[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end

function MsgType.WelfareDataItemList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.WelfareDataInMsg = {
    activityID = 0,
    count = 0,
    canSign = false,
    itemList = {}, -- array of MsgType.WelfareDataItemList
    npcIcon = "",
    title = 0,
    beginTime = 0,
    endTime = 0
}
MsgType.WelfareDataInMsg.__index = MsgType.WelfareDataInMsg

function MsgType.WelfareDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WelfareDataInMsg:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.WelfareDataInMsg:Encode()
    local tb = {}
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.b = self.activityID
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    if self.canSign then
        tb.d = self.canSign
    end
    tb.e = self:_itemListEncode()
    if nil ~= self.npcIcon and string.len(self.npcIcon) > 0 then
        tb.f = self.npcIcon
    end
    if nil ~= self.title and 0 ~= self.title then
        tb.g = self.title
    end
    if nil ~= self.beginTime and 0 ~= self.beginTime then
        tb.h = self.beginTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.i = self.endTime
    end
    return tb
end

function MsgType.WelfareDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.activityID = 0
    self.count = 0
    self.canSign = false
    self.itemList = {}
    self.npcIcon = ""
    self.title = 0
    self.beginTime = 0
    self.endTime = 0
    if nil ~= data.b then
        self.activityID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.canSign = data.d
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpItemListObj = MsgType.WelfareDataItemList:New()
            tmpItemListObj:Decode(data.e[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.f then
        self.npcIcon = tostring(data.f)
    end
    if nil ~= data.g then
        self.title = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.beginTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.endTime = tonumber(data.i) or 0
    end
    return self
end

function MsgType.WelfareDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GiftActiveCodeDataInDB = {
    roleUID = 0,
    usedList = {}
}
MsgType.GiftActiveCodeDataInDB.__index = MsgType.GiftActiveCodeDataInDB

function MsgType.GiftActiveCodeDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GiftActiveCodeDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.usedList and string.len(self.usedList) > 0 then
        tb.c = self.usedList
    end
    return tb
end

function MsgType.GiftActiveCodeDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.usedList = {}
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.usedList = table.concat(data.c, ",")
    end
    return self
end

function MsgType.GiftActiveCodeDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UsedGiftActiveCodeDataInDB = {
    giftActiveCode = "",
    optRoleUID = 0,
    optTime = 0,
    giftActiveCodeType = 0
}
MsgType.UsedGiftActiveCodeDataInDB.__index = MsgType.UsedGiftActiveCodeDataInDB

function MsgType.UsedGiftActiveCodeDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UsedGiftActiveCodeDataInDB:Encode()
    local tb = {}
    if nil ~= self.giftActiveCode and string.len(self.giftActiveCode) > 0 then
        tb.b = self.giftActiveCode
    end
    if nil ~= self.optRoleUID and 0 ~= self.optRoleUID then
        tb.c = self.optRoleUID
    end
    if nil ~= self.optTime and 0 ~= self.optTime then
        tb.d = self.optTime
    end
    if nil ~= self.giftActiveCodeType and 0 ~= self.giftActiveCodeType then
        tb.e = self.giftActiveCodeType
    end
    return tb
end

function MsgType.UsedGiftActiveCodeDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.giftActiveCode = ""
    self.optRoleUID = 0
    self.optTime = 0
    self.giftActiveCodeType = 0
    if nil ~= data.b then
        self.giftActiveCode = tostring(data.b)
    end
    if nil ~= data.c then
        self.optRoleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.optTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.giftActiveCodeType = tonumber(data.e) or 0
    end
    return self
end

function MsgType.UsedGiftActiveCodeDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.OneCityData = {
    cityID = 0
}
MsgType.OneCityData.__index = MsgType.OneCityData

function MsgType.OneCityData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneCityData:Encode()
    local tb = {}
    if nil ~= self.cityID and 0 ~= self.cityID then
        tb.b = self.cityID
    end
    return tb
end

function MsgType.OneCityData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.cityID = 0
    if nil ~= data.b then
        self.cityID = tonumber(data.b) or 0
    end
    return self
end

function MsgType.OneCityData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CityDataInDB = {
}

MsgType.OneCityInMsg = {
    cityID = 0
}
MsgType.OneCityInMsg.__index = MsgType.OneCityInMsg

function MsgType.OneCityInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneCityInMsg:Encode()
    local tb = {}
    if nil ~= self.cityID and 0 ~= self.cityID then
        tb.b = self.cityID
    end
    return tb
end

function MsgType.OneCityInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.cityID = 0
    if nil ~= data.b then
        self.cityID = tonumber(data.b) or 0
    end
    return self
end

function MsgType.OneCityInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CityDataInMsg = {
    cityList = {} -- array of MsgType.OneCityInMsg
}
MsgType.CityDataInMsg.__index = MsgType.CityDataInMsg

function MsgType.CityDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CityDataInMsg:_cityListEncode()
    local tb = {}
    for i=1, #self.cityList do
        tb[i] = self.cityList[i]:encode()
    end
    return tb
end
function MsgType.CityDataInMsg:Encode()
    local tb = {}
    tb.b = self:_cityListEncode()
    return tb
end

function MsgType.CityDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.cityList = {}
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpCityListObj = MsgType.OneCityInMsg:New()
            tmpCityListObj:Decode(data.b[i])
            self.cityList[i] = tmpCityListObj
        end
    end
    return self
end

function MsgType.CityDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.BreakthroughData = {
    roleUID = 0,
    actionPointData = {},
    chapterID = 0,
    levelID = 0,
    isChapterPassed = false,
    rewardID = 0,
    realLevelID = 0,
    chapterLevelIDList = {}, -- array of number
    rewardID1 = 0,
    rewardNum1 = 0,
    rewardID2 = 0,
    rewardNum2 = 0,
    rewardID3 = 0,
    rewardNum3 = 0,
    sceneName = "",
    banner = ""
}
MsgType.BreakthroughData.__index = MsgType.BreakthroughData
setmetatable(MsgType.BreakthroughData.actionPointData, MsgType.ActionPointData)

function MsgType.BreakthroughData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BreakthroughData:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    tb.c = self.actionPointData:Encode()
    if nil ~= self.chapterID and 0 ~= self.chapterID then
        tb.d = self.chapterID
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.e = self.levelID
    end
    if self.isChapterPassed then
        tb.f = self.isChapterPassed
    end
    if nil ~= self.rewardID and 0 ~= self.rewardID then
        tb.g = self.rewardID
    end
    if nil ~= self.realLevelID and 0 ~= self.realLevelID then
        tb.h = self.realLevelID
    end
    if nil ~= self.chapterLevelIDList and string.len(self.chapterLevelIDList) > 0 then
        tb.i = self.chapterLevelIDList
    end
    if nil ~= self.rewardID1 and 0 ~= self.rewardID1 then
        tb.j = self.rewardID1
    end
    if nil ~= self.rewardNum1 and 0 ~= self.rewardNum1 then
        tb.k = self.rewardNum1
    end
    if nil ~= self.rewardID2 and 0 ~= self.rewardID2 then
        tb.l = self.rewardID2
    end
    if nil ~= self.rewardNum2 and 0 ~= self.rewardNum2 then
        tb.m = self.rewardNum2
    end
    if nil ~= self.rewardID3 and 0 ~= self.rewardID3 then
        tb.n = self.rewardID3
    end
    if nil ~= self.rewardNum3 and 0 ~= self.rewardNum3 then
        tb.o = self.rewardNum3
    end
    if nil ~= self.sceneName and string.len(self.sceneName) > 0 then
        tb.p = self.sceneName
    end
    if nil ~= self.banner and string.len(self.banner) > 0 then
        tb.q = self.banner
    end
    return tb
end

function MsgType.BreakthroughData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.actionPointData = MsgType.ActionPointData:New()
    self.chapterID = 0
    self.levelID = 0
    self.isChapterPassed = false
    self.rewardID = 0
    self.realLevelID = 0
    self.chapterLevelIDList = {}
    self.rewardID1 = 0
    self.rewardNum1 = 0
    self.rewardID2 = 0
    self.rewardNum2 = 0
    self.rewardID3 = 0
    self.rewardNum3 = 0
    self.sceneName = ""
    self.banner = ""
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.actionPointData:Decode(data.c)
    end
    if nil ~= data.d then
        self.chapterID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.levelID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isChapterPassed = data.f
    end
    if nil ~= data.g then
        self.rewardID = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.realLevelID = tonumber(data.h) or 0
    end
    if nil ~= data.i and #data.i > 0 then
        for i=1, #data.i do
            self.chapterLevelIDList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.j then
        self.rewardID1 = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.rewardNum1 = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.rewardID2 = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.rewardNum2 = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.rewardID3 = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.rewardNum3 = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.sceneName = tostring(data.p)
    end
    if nil ~= data.q then
        self.banner = tostring(data.q)
    end
    return self
end

function MsgType.BreakthroughData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FeedbackDataInDB = {
    roleUid = 0,
    roleName = "",
    account = "",
    title = "",
    content = "",
    option = 0,
    createTime = 0
}
MsgType.FeedbackDataInDB.__index = MsgType.FeedbackDataInDB

function MsgType.FeedbackDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FeedbackDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUid and 0 ~= self.roleUid then
        tb.b = self.roleUid
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.d = self.account
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.e = self.title
    end
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.f = self.content
    end
    if nil ~= self.option and 0 ~= self.option then
        tb.g = self.option
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.h = self.createTime
    end
    return tb
end

function MsgType.FeedbackDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUid = 0
    self.roleName = ""
    self.account = ""
    self.title = ""
    self.content = ""
    self.option = 0
    self.createTime = 0
    if nil ~= data.b then
        self.roleUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.account = tostring(data.d)
    end
    if nil ~= data.e then
        self.title = tostring(data.e)
    end
    if nil ~= data.f then
        self.content = tostring(data.f)
    end
    if nil ~= data.g then
        self.option = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.createTime = tonumber(data.h) or 0
    end
    return self
end

function MsgType.FeedbackDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FeedbackDataInMsg = {
    title = "",
    content = "",
    option = 0
}
MsgType.FeedbackDataInMsg.__index = MsgType.FeedbackDataInMsg

function MsgType.FeedbackDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FeedbackDataInMsg:Encode()
    local tb = {}
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.b = self.title
    end
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.c = self.content
    end
    if nil ~= self.option and 0 ~= self.option then
        tb.d = self.option
    end
    return tb
end

function MsgType.FeedbackDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.title = ""
    self.content = ""
    self.option = 0
    if nil ~= data.b then
        self.title = tostring(data.b)
    end
    if nil ~= data.c then
        self.content = tostring(data.c)
    end
    if nil ~= data.d then
        self.option = tonumber(data.d) or 0
    end
    return self
end

function MsgType.FeedbackDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.NoticeData = {
    title = "",
    content = ""
}
MsgType.NoticeData.__index = MsgType.NoticeData

function MsgType.NoticeData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.NoticeData:Encode()
    local tb = {}
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.b = self.title
    end
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.c = self.content
    end
    return tb
end

function MsgType.NoticeData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.title = ""
    self.content = ""
    if nil ~= data.b then
        self.title = tostring(data.b)
    end
    if nil ~= data.c then
        self.content = tostring(data.c)
    end
    return self
end

function MsgType.NoticeData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PreviewDataInMsg = {
    ID = 0,
    Frequency = 0,
    Position = 0,
    Picture = "",
    Begin = "",
    Content = ""
}
MsgType.PreviewDataInMsg.__index = MsgType.PreviewDataInMsg

function MsgType.PreviewDataInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PreviewDataInMsg:Encode()
    local tb = {}
    if nil ~= self.ID and 0 ~= self.ID then
        tb.b = self.ID
    end
    if nil ~= self.Frequency and 0 ~= self.Frequency then
        tb.c = self.Frequency
    end
    if nil ~= self.Position and 0 ~= self.Position then
        tb.d = self.Position
    end
    if nil ~= self.Picture and string.len(self.Picture) > 0 then
        tb.e = self.Picture
    end
    if nil ~= self.Begin and string.len(self.Begin) > 0 then
        tb.f = self.Begin
    end
    if nil ~= self.Content and string.len(self.Content) > 0 then
        tb.g = self.Content
    end
    return tb
end

function MsgType.PreviewDataInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ID = 0
    self.Frequency = 0
    self.Position = 0
    self.Picture = ""
    self.Begin = ""
    self.Content = ""
    if nil ~= data.b then
        self.ID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.Frequency = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.Position = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.Picture = tostring(data.e)
    end
    if nil ~= data.f then
        self.Begin = tostring(data.f)
    end
    if nil ~= data.g then
        self.Content = tostring(data.g)
    end
    return self
end

function MsgType.PreviewDataInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.NoticeDataInDB = {
    fromTime = 0,
    toTime = 0,
    title = "",
    content = ""
}
MsgType.NoticeDataInDB.__index = MsgType.NoticeDataInDB

function MsgType.NoticeDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.NoticeDataInDB:Encode()
    local tb = {}
    if nil ~= self.fromTime and 0 ~= self.fromTime then
        tb.b = self.fromTime
    end
    if nil ~= self.toTime and 0 ~= self.toTime then
        tb.c = self.toTime
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.d = self.title
    end
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.e = self.content
    end
    return tb
end

function MsgType.NoticeDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.fromTime = 0
    self.toTime = 0
    self.title = ""
    self.content = ""
    if nil ~= data.b then
        self.fromTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.toTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.title = tostring(data.d)
    end
    if nil ~= data.e then
        self.content = tostring(data.e)
    end
    return self
end

function MsgType.NoticeDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PreviewDataInDB = {
    ID = 0,
    Frequency = 0,
    Position = 0,
    Picture = "",
    ShowStartTime = 0,
    ShowEndTime = 0,
    Begin = "",
    Content = ""
}
MsgType.PreviewDataInDB.__index = MsgType.PreviewDataInDB

function MsgType.PreviewDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PreviewDataInDB:Encode()
    local tb = {}
    if nil ~= self.ID and 0 ~= self.ID then
        tb.b = self.ID
    end
    if nil ~= self.Frequency and 0 ~= self.Frequency then
        tb.c = self.Frequency
    end
    if nil ~= self.Position and 0 ~= self.Position then
        tb.d = self.Position
    end
    if nil ~= self.Picture and string.len(self.Picture) > 0 then
        tb.e = self.Picture
    end
    if nil ~= self.ShowStartTime and 0 ~= self.ShowStartTime then
        tb.f = self.ShowStartTime
    end
    if nil ~= self.ShowEndTime and 0 ~= self.ShowEndTime then
        tb.g = self.ShowEndTime
    end
    if nil ~= self.Begin and string.len(self.Begin) > 0 then
        tb.h = self.Begin
    end
    if nil ~= self.Content and string.len(self.Content) > 0 then
        tb.i = self.Content
    end
    return tb
end

function MsgType.PreviewDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ID = 0
    self.Frequency = 0
    self.Position = 0
    self.Picture = ""
    self.ShowStartTime = 0
    self.ShowEndTime = 0
    self.Begin = ""
    self.Content = ""
    if nil ~= data.b then
        self.ID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.Frequency = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.Position = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.Picture = tostring(data.e)
    end
    if nil ~= data.f then
        self.ShowStartTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.ShowEndTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.Begin = tostring(data.h)
    end
    if nil ~= data.i then
        self.Content = tostring(data.i)
    end
    return self
end

function MsgType.PreviewDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.NoticeWrapDataInDB = {
    notice = {},
    previewList = {} -- array of MsgType.PreviewDataInDB
}
MsgType.NoticeWrapDataInDB.__index = MsgType.NoticeWrapDataInDB
setmetatable(MsgType.NoticeWrapDataInDB.notice, MsgType.NoticeDataInDB)

function MsgType.NoticeWrapDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.NoticeWrapDataInDB:_previewListEncode()
    local tb = {}
    for i=1, #self.previewList do
        tb[i] = self.previewList[i]:encode()
    end
    return tb
end
function MsgType.NoticeWrapDataInDB:Encode()
    local tb = {}
    tb.b = self.notice:Encode()
    tb.c = self:_previewListEncode()
    return tb
end

function MsgType.NoticeWrapDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.notice = MsgType.NoticeDataInDB:New()
    self.previewList = {}
    if nil ~= data.b then
        self.notice:Decode(data.b)
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpPreviewListObj = MsgType.PreviewDataInDB:New()
            tmpPreviewListObj:Decode(data.c[i])
            self.previewList[i] = tmpPreviewListObj
        end
    end
    return self
end

function MsgType.NoticeWrapDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.SystemEnterConfig = {
    ID = 0,
    systemID = 0,
    primarySubsystemID = 0,
    secondarySubsystemID = "",
    unlock = "",
    unlockParam = ""
}
MsgType.SystemEnterConfig.__index = MsgType.SystemEnterConfig

function MsgType.SystemEnterConfig:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.SystemEnterConfig:Encode()
    local tb = {}
    if nil ~= self.ID and 0 ~= self.ID then
        tb.b = self.ID
    end
    if nil ~= self.systemID and 0 ~= self.systemID then
        tb.c = self.systemID
    end
    if nil ~= self.primarySubsystemID and 0 ~= self.primarySubsystemID then
        tb.d = self.primarySubsystemID
    end
    if nil ~= self.secondarySubsystemID and string.len(self.secondarySubsystemID) > 0 then
        tb.e = self.secondarySubsystemID
    end
    if nil ~= self.unlock and string.len(self.unlock) > 0 then
        tb.f = self.unlock
    end
    if nil ~= self.unlockParam and string.len(self.unlockParam) > 0 then
        tb.g = self.unlockParam
    end
    return tb
end

function MsgType.SystemEnterConfig:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ID = 0
    self.systemID = 0
    self.primarySubsystemID = 0
    self.secondarySubsystemID = ""
    self.unlock = ""
    self.unlockParam = ""
    if nil ~= data.b then
        self.ID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.systemID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.primarySubsystemID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.secondarySubsystemID = tostring(data.e)
    end
    if nil ~= data.f then
        self.unlock = tostring(data.f)
    end
    if nil ~= data.g then
        self.unlockParam = tostring(data.g)
    end
    return self
end

function MsgType.SystemEnterConfig:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendOptEvent = {
    optType = 0, --enum EFriendOptType
    roleUID = 0,
    roleName = "",
    targetUID = 0
}
MsgType.FriendOptEvent.__index = MsgType.FriendOptEvent

function MsgType.FriendOptEvent:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendOptEvent:Encode()
    local tb = {}
    if nil ~= self.optType and 0 ~= self.optType then
        tb.b = self.optType
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.d = self.roleName
    end
    if nil ~= self.targetUID and 0 ~= self.targetUID then
        tb.e = self.targetUID
    end
    return tb
end

function MsgType.FriendOptEvent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.roleUID = 0
    self.roleName = ""
    self.targetUID = 0
    if nil ~= data.b then
        self.optType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.targetUID = tonumber(data.e) or 0
    end
    return self
end

function MsgType.FriendOptEvent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelTopOptEvent = {
    optType = 0, --enum ELevelTopOptType
    roleUID = 0,
    roleName = "",
    levelID = 0,
    score = 0,
    equipList = {}
}
MsgType.LevelTopOptEvent.__index = MsgType.LevelTopOptEvent
setmetatable(MsgType.LevelTopOptEvent.equipList, MsgType.EquipsInLevelData)

function MsgType.LevelTopOptEvent:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelTopOptEvent:Encode()
    local tb = {}
    if nil ~= self.optType and 0 ~= self.optType then
        tb.b = self.optType
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.d = self.roleName
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.e = self.levelID
    end
    if nil ~= self.score and 0 ~= self.score then
        tb.f = self.score
    end
    tb.g = self.equipList:Encode()
    return tb
end

function MsgType.LevelTopOptEvent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.roleUID = 0
    self.roleName = ""
    self.levelID = 0
    self.score = 0
    self.equipList = MsgType.EquipsInLevelData:New()
    if nil ~= data.b then
        self.optType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.levelID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.score = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipList:Decode(data.g)
    end
    return self
end

function MsgType.LevelTopOptEvent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EChatContOptEventType = {
    ECCOET_NOMAL = 0,
    ECCOET_OFFLINECHAT = 1,
    ECCOET_OFFLINESEND = 2
}

MsgType.ChatContOptEvent = {
    chatType = 0,
    channel = 0,
    eventType = 0, --enum EChatContOptEventType
    chatCont = "",
    sendTime = 0,
    sourceRoleUID = 0,
    sourceRoleName = "",
    targetRoleUID = 0,
    targetRoleName = ""
}
MsgType.ChatContOptEvent.__index = MsgType.ChatContOptEvent

function MsgType.ChatContOptEvent:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ChatContOptEvent:Encode()
    local tb = {}
    if nil ~= self.chatType and 0 ~= self.chatType then
        tb.b = self.chatType
    end
    if nil ~= self.channel and 0 ~= self.channel then
        tb.c = self.channel
    end
    if nil ~= self.eventType and 0 ~= self.eventType then
        tb.d = self.eventType
    end
    if nil ~= self.chatCont and string.len(self.chatCont) > 0 then
        tb.e = self.chatCont
    end
    if nil ~= self.sendTime and 0 ~= self.sendTime then
        tb.f = self.sendTime
    end
    if nil ~= self.sourceRoleUID and 0 ~= self.sourceRoleUID then
        tb.g = self.sourceRoleUID
    end
    if nil ~= self.sourceRoleName and string.len(self.sourceRoleName) > 0 then
        tb.h = self.sourceRoleName
    end
    if nil ~= self.targetRoleUID and 0 ~= self.targetRoleUID then
        tb.i = self.targetRoleUID
    end
    if nil ~= self.targetRoleName and string.len(self.targetRoleName) > 0 then
        tb.j = self.targetRoleName
    end
    return tb
end

function MsgType.ChatContOptEvent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.chatType = 0
    self.channel = 0
    self.eventType = 0
    self.chatCont = ""
    self.sendTime = 0
    self.sourceRoleUID = 0
    self.sourceRoleName = ""
    self.targetRoleUID = 0
    self.targetRoleName = ""
    if nil ~= data.b then
        self.chatType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.channel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.eventType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.chatCont = tostring(data.e)
    end
    if nil ~= data.f then
        self.sendTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sourceRoleUID = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.sourceRoleName = tostring(data.h)
    end
    if nil ~= data.i then
        self.targetRoleUID = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.targetRoleName = tostring(data.j)
    end
    return self
end

function MsgType.ChatContOptEvent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ItemInPayList = {
    itemType = 0,
    count = 0
}
MsgType.ItemInPayList.__index = MsgType.ItemInPayList

function MsgType.ItemInPayList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemInPayList:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.ItemInPayList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ItemInPayList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PayListItem = {
    id = 0,
    moneyType = 0, --enum EPayMoneyType
    money = 0,
    moneyUnit = "",
    orgMoney = 0,
    offCount = 0,
    productID = "",
    productName = "",
    productDesc = "",
    icon = "",
    itemIcon = "",
    banner = 0,
    startTime = 0,
    endTime = 0,
    remainBuyTimes = 0,
    itemList = {}, -- array of MsgType.ItemInPayList
    tip = 0
}
MsgType.PayListItem.__index = MsgType.PayListItem

function MsgType.PayListItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PayListItem:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.PayListItem:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.c = self.moneyType
    end
    if nil ~= self.money and 0 ~= self.money then
        tb.d = self.money
    end
    if nil ~= self.moneyUnit and string.len(self.moneyUnit) > 0 then
        tb.e = self.moneyUnit
    end
    if nil ~= self.orgMoney and 0 ~= self.orgMoney then
        tb.f = self.orgMoney
    end
    if nil ~= self.offCount and 0 ~= self.offCount then
        tb.g = self.offCount
    end
    if nil ~= self.productID and string.len(self.productID) > 0 then
        tb.h = self.productID
    end
    if nil ~= self.productName and string.len(self.productName) > 0 then
        tb.i = self.productName
    end
    if nil ~= self.productDesc and string.len(self.productDesc) > 0 then
        tb.j = self.productDesc
    end
    if nil ~= self.icon and string.len(self.icon) > 0 then
        tb.k = self.icon
    end
    if nil ~= self.itemIcon and string.len(self.itemIcon) > 0 then
        tb.l = self.itemIcon
    end
    if nil ~= self.banner and 0 ~= self.banner then
        tb.m = self.banner
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.n = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.o = self.endTime
    end
    if nil ~= self.remainBuyTimes and 0 ~= self.remainBuyTimes then
        tb.p = self.remainBuyTimes
    end
    tb.q = self:_itemListEncode()
    if nil ~= self.tip and 0 ~= self.tip then
        tb.r = self.tip
    end
    return tb
end

function MsgType.PayListItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.id = 0
    self.moneyType = 0
    self.money = 0
    self.moneyUnit = ""
    self.orgMoney = 0
    self.offCount = 0
    self.productID = ""
    self.productName = ""
    self.productDesc = ""
    self.icon = ""
    self.itemIcon = ""
    self.banner = 0
    self.startTime = 0
    self.endTime = 0
    self.remainBuyTimes = 0
    self.itemList = {}
    self.tip = 0
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.moneyType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.money = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.moneyUnit = tostring(data.e)
    end
    if nil ~= data.f then
        self.orgMoney = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.offCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.productID = tostring(data.h)
    end
    if nil ~= data.i then
        self.productName = tostring(data.i)
    end
    if nil ~= data.j then
        self.productDesc = tostring(data.j)
    end
    if nil ~= data.k then
        self.icon = tostring(data.k)
    end
    if nil ~= data.l then
        self.itemIcon = tostring(data.l)
    end
    if nil ~= data.m then
        self.banner = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.startTime = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.endTime = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.remainBuyTimes = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        for i=1, #data.q do
            local tmpItemListObj = MsgType.ItemInPayList:New()
            tmpItemListObj:Decode(data.q[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.r then
        self.tip = tonumber(data.r) or 0
    end
    return self
end

function MsgType.PayListItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PayItemBuyInfo = {
    id = 0,
    lastBuyTime = 0,
    buyTimes = 0
}
MsgType.PayItemBuyInfo.__index = MsgType.PayItemBuyInfo

function MsgType.PayItemBuyInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PayItemBuyInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.lastBuyTime and 0 ~= self.lastBuyTime then
        tb.c = self.lastBuyTime
    end
    if nil ~= self.buyTimes and 0 ~= self.buyTimes then
        tb.d = self.buyTimes
    end
    return tb
end

function MsgType.PayItemBuyInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.id = 0
    self.lastBuyTime = 0
    self.buyTimes = 0
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastBuyTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.buyTimes = tonumber(data.d) or 0
    end
    return self
end

function MsgType.PayItemBuyInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PayDataInDB = {
    lastRefreshTime = 0,
    payTotalTimes = 0,
    payTotalMoney = 0,
    buyRechargeList = {}, -- array of MsgType.PayItemBuyInfo
    buyItemShopList = {}, -- array of MsgType.PayItemBuyInfo
    buyFestivalList = {}, -- array of MsgType.PayItemBuyInfo
    buySalesList = {} -- array of MsgType.PayItemBuyInfo
}
MsgType.PayDataInDB.__index = MsgType.PayDataInDB

function MsgType.PayDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PayDataInDB:_buyRechargeListEncode()
    local tb = {}
    for i=1, #self.buyRechargeList do
        tb[i] = self.buyRechargeList[i]:encode()
    end
    return tb
end
function MsgType.PayDataInDB:_buyItemShopListEncode()
    local tb = {}
    for i=1, #self.buyItemShopList do
        tb[i] = self.buyItemShopList[i]:encode()
    end
    return tb
end
function MsgType.PayDataInDB:_buyFestivalListEncode()
    local tb = {}
    for i=1, #self.buyFestivalList do
        tb[i] = self.buyFestivalList[i]:encode()
    end
    return tb
end
function MsgType.PayDataInDB:_buySalesListEncode()
    local tb = {}
    for i=1, #self.buySalesList do
        tb[i] = self.buySalesList[i]:encode()
    end
    return tb
end
function MsgType.PayDataInDB:Encode()
    local tb = {}
    if nil ~= self.lastRefreshTime and 0 ~= self.lastRefreshTime then
        tb.b = self.lastRefreshTime
    end
    if nil ~= self.payTotalTimes and 0 ~= self.payTotalTimes then
        tb.c = self.payTotalTimes
    end
    if nil ~= self.payTotalMoney and 0 ~= self.payTotalMoney then
        tb.d = self.payTotalMoney
    end
    tb.e = self:_buyRechargeListEncode()
    tb.f = self:_buyItemShopListEncode()
    tb.g = self:_buyFestivalListEncode()
    tb.h = self:_buySalesListEncode()
    return tb
end

function MsgType.PayDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.lastRefreshTime = 0
    self.payTotalTimes = 0
    self.payTotalMoney = 0
    self.buyRechargeList = {}
    self.buyItemShopList = {}
    self.buyFestivalList = {}
    self.buySalesList = {}
    if nil ~= data.b then
        self.lastRefreshTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.payTotalTimes = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.payTotalMoney = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpBuyRechargeListObj = MsgType.PayItemBuyInfo:New()
            tmpBuyRechargeListObj:Decode(data.e[i])
            self.buyRechargeList[i] = tmpBuyRechargeListObj
        end
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpBuyItemShopListObj = MsgType.PayItemBuyInfo:New()
            tmpBuyItemShopListObj:Decode(data.f[i])
            self.buyItemShopList[i] = tmpBuyItemShopListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpBuyFestivalListObj = MsgType.PayItemBuyInfo:New()
            tmpBuyFestivalListObj:Decode(data.g[i])
            self.buyFestivalList[i] = tmpBuyFestivalListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpBuySalesListObj = MsgType.PayItemBuyInfo:New()
            tmpBuySalesListObj:Decode(data.h[i])
            self.buySalesList[i] = tmpBuySalesListObj
        end
    end
    return self
end

function MsgType.PayDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AccountServerInfo = {
    groupID = 0,
    serverID = 0
}
MsgType.AccountServerInfo.__index = MsgType.AccountServerInfo

function MsgType.AccountServerInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AccountServerInfo:Encode()
    local tb = {}
    if nil ~= self.groupID and 0 ~= self.groupID then
        tb.b = self.groupID
    end
    if nil ~= self.serverID and 0 ~= self.serverID then
        tb.c = self.serverID
    end
    return tb
end

function MsgType.AccountServerInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupID = 0
    self.serverID = 0
    if nil ~= data.b then
        self.groupID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.serverID = tonumber(data.c) or 0
    end
    return self
end

function MsgType.AccountServerInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AccountServerList = {
    lastTime = 0,
    lastGroupID = 0,
    lastServerID = 0,
    serverList = {} -- array of MsgType.AccountServerInfo
}
MsgType.AccountServerList.__index = MsgType.AccountServerList

function MsgType.AccountServerList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AccountServerList:_serverListEncode()
    local tb = {}
    for i=1, #self.serverList do
        tb[i] = self.serverList[i]:encode()
    end
    return tb
end
function MsgType.AccountServerList:Encode()
    local tb = {}
    if nil ~= self.lastTime and 0 ~= self.lastTime then
        tb.b = self.lastTime
    end
    if nil ~= self.lastGroupID and 0 ~= self.lastGroupID then
        tb.c = self.lastGroupID
    end
    if nil ~= self.lastServerID and 0 ~= self.lastServerID then
        tb.d = self.lastServerID
    end
    tb.e = self:_serverListEncode()
    return tb
end

function MsgType.AccountServerList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.lastTime = 0
    self.lastGroupID = 0
    self.lastServerID = 0
    self.serverList = {}
    if nil ~= data.b then
        self.lastTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastGroupID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastServerID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpServerListObj = MsgType.AccountServerInfo:New()
            tmpServerListObj:Decode(data.e[i])
            self.serverList[i] = tmpServerListObj
        end
    end
    return self
end

function MsgType.AccountServerList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ServerListItem = {
    id = 0,
    sid = 0,
    name = "",
    https = 0,
    host = "",
    port = 0,
    status = "",
    flag = 0
}
MsgType.ServerListItem.__index = MsgType.ServerListItem

function MsgType.ServerListItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ServerListItem:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.sid and 0 ~= self.sid then
        tb.c = self.sid
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.d = self.name
    end
    if nil ~= self.https and 0 ~= self.https then
        tb.e = self.https
    end
    if nil ~= self.host and string.len(self.host) > 0 then
        tb.f = self.host
    end
    if nil ~= self.port and 0 ~= self.port then
        tb.g = self.port
    end
    if nil ~= self.status and string.len(self.status) > 0 then
        tb.h = self.status
    end
    if nil ~= self.flag and 0 ~= self.flag then
        tb.i = self.flag
    end
    return tb
end

function MsgType.ServerListItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.id = 0
    self.sid = 0
    self.name = ""
    self.https = 0
    self.host = ""
    self.port = 0
    self.status = ""
    self.flag = 0
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.sid = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.name = tostring(data.d)
    end
    if nil ~= data.e then
        self.https = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.host = tostring(data.f)
    end
    if nil ~= data.g then
        self.port = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.status = tostring(data.h)
    end
    if nil ~= data.i then
        self.flag = tonumber(data.i) or 0
    end
    return self
end

function MsgType.ServerListItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AchieveList = {
    achieveNum = 0,
    listType = 0,
    achieveIDs = {} -- array of number
}
MsgType.AchieveList.__index = MsgType.AchieveList

function MsgType.AchieveList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AchieveList:Encode()
    local tb = {}
    if nil ~= self.achieveNum and 0 ~= self.achieveNum then
        tb.b = self.achieveNum
    end
    if nil ~= self.listType and 0 ~= self.listType then
        tb.c = self.listType
    end
    if nil ~= self.achieveIDs and string.len(self.achieveIDs) > 0 then
        tb.d = self.achieveIDs
    end
    return tb
end

function MsgType.AchieveList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.achieveNum = 0
    self.listType = 0
    self.achieveIDs = {}
    if nil ~= data.b then
        self.achieveNum = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.listType = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.achieveIDs[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.AchieveList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AchieveProgress = {
    achieveID = 0,
    achieveProgress = 0
}
MsgType.AchieveProgress.__index = MsgType.AchieveProgress

function MsgType.AchieveProgress:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AchieveProgress:Encode()
    local tb = {}
    if nil ~= self.achieveID and 0 ~= self.achieveID then
        tb.b = self.achieveID
    end
    if nil ~= self.achieveProgress and 0 ~= self.achieveProgress then
        tb.c = self.achieveProgress
    end
    return tb
end

function MsgType.AchieveProgress:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.achieveID = 0
    self.achieveProgress = 0
    if nil ~= data.b then
        self.achieveID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.achieveProgress = tonumber(data.c) or 0
    end
    return self
end

function MsgType.AchieveProgress:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AchieveProgressList = {
    infoNum = 0,
    achieveProgressList = {} -- array of MsgType.AchieveProgress
}
MsgType.AchieveProgressList.__index = MsgType.AchieveProgressList

function MsgType.AchieveProgressList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AchieveProgressList:_achieveProgressListEncode()
    local tb = {}
    for i=1, #self.achieveProgressList do
        tb[i] = self.achieveProgressList[i]:encode()
    end
    return tb
end
function MsgType.AchieveProgressList:Encode()
    local tb = {}
    if nil ~= self.infoNum and 0 ~= self.infoNum then
        tb.b = self.infoNum
    end
    tb.c = self:_achieveProgressListEncode()
    return tb
end

function MsgType.AchieveProgressList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.infoNum = 0
    self.achieveProgressList = {}
    if nil ~= data.b then
        self.infoNum = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpAchieveProgressListObj = MsgType.AchieveProgress:New()
            tmpAchieveProgressListObj:Decode(data.c[i])
            self.achieveProgressList[i] = tmpAchieveProgressListObj
        end
    end
    return self
end

function MsgType.AchieveProgressList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PersonalLuckyDrawPoolInfo = {
    luckyPoolID = 0,
    freeTimes = 0,
    lastResetTime = 0,
    luckydrawTicketNum = 0,
    exchangeCoinNum = 0
}
MsgType.PersonalLuckyDrawPoolInfo.__index = MsgType.PersonalLuckyDrawPoolInfo

function MsgType.PersonalLuckyDrawPoolInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PersonalLuckyDrawPoolInfo:Encode()
    local tb = {}
    if nil ~= self.luckyPoolID and 0 ~= self.luckyPoolID then
        tb.b = self.luckyPoolID
    end
    if nil ~= self.freeTimes and 0 ~= self.freeTimes then
        tb.c = self.freeTimes
    end
    if nil ~= self.lastResetTime and 0 ~= self.lastResetTime then
        tb.d = self.lastResetTime
    end
    if nil ~= self.luckydrawTicketNum and 0 ~= self.luckydrawTicketNum then
        tb.e = self.luckydrawTicketNum
    end
    if nil ~= self.exchangeCoinNum and 0 ~= self.exchangeCoinNum then
        tb.f = self.exchangeCoinNum
    end
    return tb
end

function MsgType.PersonalLuckyDrawPoolInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.luckyPoolID = 0
    self.freeTimes = 0
    self.lastResetTime = 0
    self.luckydrawTicketNum = 0
    self.exchangeCoinNum = 0
    if nil ~= data.b then
        self.luckyPoolID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.freeTimes = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastResetTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.luckydrawTicketNum = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.exchangeCoinNum = tonumber(data.f) or 0
    end
    return self
end

function MsgType.PersonalLuckyDrawPoolInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.StorySingle = {
    storyID = 0,
    storyStatus = 0 --enum EStoryStatusType
}
MsgType.StorySingle.__index = MsgType.StorySingle

function MsgType.StorySingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.StorySingle:Encode()
    local tb = {}
    if nil ~= self.storyID and 0 ~= self.storyID then
        tb.b = self.storyID
    end
    if nil ~= self.storyStatus and 0 ~= self.storyStatus then
        tb.c = self.storyStatus
    end
    return tb
end

function MsgType.StorySingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.storyID = 0
    self.storyStatus = 0
    if nil ~= data.b then
        self.storyID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.storyStatus = tonumber(data.c) or 0
    end
    return self
end

function MsgType.StorySingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.StoryDataInDB = {
}

MsgType.TaskSingle = {
    taskID = 0,
    taskStatus = 0, --enum ETaskStatusType
    step = 0,
    stepTime = 0
}
MsgType.TaskSingle.__index = MsgType.TaskSingle

function MsgType.TaskSingle:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TaskSingle:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.taskStatus and 0 ~= self.taskStatus then
        tb.c = self.taskStatus
    end
    if nil ~= self.step and 0 ~= self.step then
        tb.d = self.step
    end
    if nil ~= self.stepTime and 0 ~= self.stepTime then
        tb.e = self.stepTime
    end
    return tb
end

function MsgType.TaskSingle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.taskStatus = 0
    self.step = 0
    self.stepTime = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskStatus = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.step = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.stepTime = tonumber(data.e) or 0
    end
    return self
end

function MsgType.TaskSingle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TaskSection = {
    currentSection = 0,
    currentSectionProgress = 0
}
MsgType.TaskSection.__index = MsgType.TaskSection

function MsgType.TaskSection:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TaskSection:Encode()
    local tb = {}
    if nil ~= self.currentSection and 0 ~= self.currentSection then
        tb.b = self.currentSection
    end
    if nil ~= self.currentSectionProgress and 0 ~= self.currentSectionProgress then
        tb.c = self.currentSectionProgress
    end
    return tb
end

function MsgType.TaskSection:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentSection = 0
    self.currentSectionProgress = 0
    if nil ~= data.b then
        self.currentSection = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.currentSectionProgress = tonumber(data.c) or 0
    end
    return self
end

function MsgType.TaskSection:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TaskInfo = {
    taskID = 0,
    taskStar = 0,
    taskTime = 0,
    taskMoney = 0
}
MsgType.TaskInfo.__index = MsgType.TaskInfo

function MsgType.TaskInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TaskInfo:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.taskStar and 0 ~= self.taskStar then
        tb.c = self.taskStar
    end
    if nil ~= self.taskTime and 0 ~= self.taskTime then
        tb.d = self.taskTime
    end
    if nil ~= self.taskMoney and 0 ~= self.taskMoney then
        tb.e = self.taskMoney
    end
    return tb
end

function MsgType.TaskInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.taskStar = 0
    self.taskTime = 0
    self.taskMoney = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskStar = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.taskMoney = tonumber(data.e) or 0
    end
    return self
end

function MsgType.TaskInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TaskDataInDB = {
}

MsgType.InteractionRewardDataInDB = {
    roleUID = 0,
    lastRefreshTime = 0,
    lastPickTime = 0,
    pickTimes = 0
}
MsgType.InteractionRewardDataInDB.__index = MsgType.InteractionRewardDataInDB

function MsgType.InteractionRewardDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.InteractionRewardDataInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.lastRefreshTime and 0 ~= self.lastRefreshTime then
        tb.c = self.lastRefreshTime
    end
    if nil ~= self.lastPickTime and 0 ~= self.lastPickTime then
        tb.d = self.lastPickTime
    end
    if nil ~= self.pickTimes and 0 ~= self.pickTimes then
        tb.e = self.pickTimes
    end
    return tb
end

function MsgType.InteractionRewardDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.lastRefreshTime = 0
    self.lastPickTime = 0
    self.pickTimes = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.lastRefreshTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastPickTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.pickTimes = tonumber(data.e) or 0
    end
    return self
end

function MsgType.InteractionRewardDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoomInDB = {
    roomID = 0,
    objectList = {} -- array of number
}
MsgType.RoomInDB.__index = MsgType.RoomInDB

function MsgType.RoomInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoomInDB:Encode()
    local tb = {}
    if nil ~= self.roomID and 0 ~= self.roomID then
        tb.b = self.roomID
    end
    if nil ~= self.objectList and string.len(self.objectList) > 0 then
        tb.c = self.objectList
    end
    return tb
end

function MsgType.RoomInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roomID = 0
    self.objectList = {}
    if nil ~= data.b then
        self.roomID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.objectList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.RoomInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoomDataInDB = {
}

MsgType.RoomInMsg = {
    roomID = 0,
    roomObjectList = {} -- array of number
}
MsgType.RoomInMsg.__index = MsgType.RoomInMsg

function MsgType.RoomInMsg:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoomInMsg:Encode()
    local tb = {}
    if nil ~= self.roomID and 0 ~= self.roomID then
        tb.b = self.roomID
    end
    if nil ~= self.roomObjectList and string.len(self.roomObjectList) > 0 then
        tb.c = self.roomObjectList
    end
    return tb
end

function MsgType.RoomInMsg:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roomID = 0
    self.roomObjectList = {}
    if nil ~= data.b then
        self.roomID = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.roomObjectList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.RoomInMsg:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.AccountLinkDataInDB = {
    account = "",
    balance = "",
    refreshTime = 0,
    rewardTimes = 0
}
MsgType.AccountLinkDataInDB.__index = MsgType.AccountLinkDataInDB

function MsgType.AccountLinkDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AccountLinkDataInDB:Encode()
    local tb = {}
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.b = self.account
    end
    if nil ~= self.balance and string.len(self.balance) > 0 then
        tb.c = self.balance
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.d = self.refreshTime
    end
    if nil ~= self.rewardTimes and 0 ~= self.rewardTimes then
        tb.e = self.rewardTimes
    end
    return tb
end

function MsgType.AccountLinkDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.balance = ""
    self.refreshTime = 0
    self.rewardTimes = 0
    if nil ~= data.b then
        self.account = tostring(data.b)
    end
    if nil ~= data.c then
        self.balance = tostring(data.c)
    end
    if nil ~= data.d then
        self.refreshTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.rewardTimes = tonumber(data.e) or 0
    end
    return self
end

function MsgType.AccountLinkDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LinkActivityInfoInDB = {
    status = 0, --enum ECoinActivityStatusType
    startTime = 0,
    endTime = 0,
    historyCoin = "",
    totalCoin = "",
    totalCount = 0,
    loopNum = 0,
    rewardMultiple = 0,
    rewardTotalCoin = "",
    rewardCount = 0,
    rewardMean = 0,
    rewardDev = 0
}
MsgType.LinkActivityInfoInDB.__index = MsgType.LinkActivityInfoInDB

function MsgType.LinkActivityInfoInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LinkActivityInfoInDB:Encode()
    local tb = {}
    if nil ~= self.status and 0 ~= self.status then
        tb.b = self.status
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.c = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.d = self.endTime
    end
    if nil ~= self.historyCoin and string.len(self.historyCoin) > 0 then
        tb.e = self.historyCoin
    end
    if nil ~= self.totalCoin and string.len(self.totalCoin) > 0 then
        tb.f = self.totalCoin
    end
    if nil ~= self.totalCount and 0 ~= self.totalCount then
        tb.g = self.totalCount
    end
    if nil ~= self.loopNum and 0 ~= self.loopNum then
        tb.h = self.loopNum
    end
    if nil ~= self.rewardMultiple and 0 ~= self.rewardMultiple then
        tb.i = self.rewardMultiple
    end
    if nil ~= self.rewardTotalCoin and string.len(self.rewardTotalCoin) > 0 then
        tb.j = self.rewardTotalCoin
    end
    if nil ~= self.rewardCount and 0 ~= self.rewardCount then
        tb.k = self.rewardCount
    end
    if nil ~= self.rewardMean and 0 ~= self.rewardMean then
        tb.l = self.rewardMean
    end
    if nil ~= self.rewardDev and 0 ~= self.rewardDev then
        tb.m = self.rewardDev
    end
    return tb
end

function MsgType.LinkActivityInfoInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.status = 0
    self.startTime = 0
    self.endTime = 0
    self.historyCoin = ""
    self.totalCoin = ""
    self.totalCount = 0
    self.loopNum = 0
    self.rewardMultiple = 0
    self.rewardTotalCoin = ""
    self.rewardCount = 0
    self.rewardMean = 0
    self.rewardDev = 0
    if nil ~= data.b then
        self.status = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.startTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.endTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.historyCoin = tostring(data.e)
    end
    if nil ~= data.f then
        self.totalCoin = tostring(data.f)
    end
    if nil ~= data.g then
        self.totalCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.loopNum = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rewardMultiple = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.rewardTotalCoin = tostring(data.j)
    end
    if nil ~= data.k then
        self.rewardCount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.rewardMean = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.rewardDev = tonumber(data.m) or 0
    end
    return self
end

function MsgType.LinkActivityInfoInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LinkActivityInfo = {
    status = 0, --enum ECoinActivityStatusType
    registerCount = 0,
    needRegisterCount = 0,
    startTime = 0,
    endTime = 0,
    nextStartTime = 0,
    nextEndTime = 0,
    totalCoin = 0,
    totalCoinNumber = 0,
    rewardCoinNumber = 0
}
MsgType.LinkActivityInfo.__index = MsgType.LinkActivityInfo

function MsgType.LinkActivityInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LinkActivityInfo:Encode()
    local tb = {}
    if nil ~= self.status and 0 ~= self.status then
        tb.b = self.status
    end
    if nil ~= self.registerCount and 0 ~= self.registerCount then
        tb.c = self.registerCount
    end
    if nil ~= self.needRegisterCount and 0 ~= self.needRegisterCount then
        tb.d = self.needRegisterCount
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.e = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.f = self.endTime
    end
    if nil ~= self.nextStartTime and 0 ~= self.nextStartTime then
        tb.g = self.nextStartTime
    end
    if nil ~= self.nextEndTime and 0 ~= self.nextEndTime then
        tb.h = self.nextEndTime
    end
    if nil ~= self.totalCoin and 0 ~= self.totalCoin then
        tb.i = self.totalCoin
    end
    if nil ~= self.totalCoinNumber and 0 ~= self.totalCoinNumber then
        tb.j = self.totalCoinNumber
    end
    if nil ~= self.rewardCoinNumber and 0 ~= self.rewardCoinNumber then
        tb.k = self.rewardCoinNumber
    end
    return tb
end

function MsgType.LinkActivityInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.status = 0
    self.registerCount = 0
    self.needRegisterCount = 0
    self.startTime = 0
    self.endTime = 0
    self.nextStartTime = 0
    self.nextEndTime = 0
    self.totalCoin = 0
    self.totalCoinNumber = 0
    self.rewardCoinNumber = 0
    if nil ~= data.b then
        self.status = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.registerCount = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.needRegisterCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.startTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.endTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.nextStartTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.nextEndTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.totalCoin = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.totalCoinNumber = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.rewardCoinNumber = tonumber(data.k) or 0
    end
    return self
end

function MsgType.LinkActivityInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RoleCoverRecord = {
    coverTime = 0,
    sDeviceID = "",
    sRoleUID = 0,
    sRoleName = "",
    sGold = 0,
    sAp = 0,
    sLevel = 0,
    sTask = 0,
    tDeviceID = "",
    tRoleUID = 0,
    tRoleName = "",
    tGold = 0,
    tAp = 0,
    tLevel = 0,
    tTask = 0
}
MsgType.RoleCoverRecord.__index = MsgType.RoleCoverRecord

function MsgType.RoleCoverRecord:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleCoverRecord:Encode()
    local tb = {}
    if nil ~= self.coverTime and 0 ~= self.coverTime then
        tb.b = self.coverTime
    end
    if nil ~= self.sDeviceID and string.len(self.sDeviceID) > 0 then
        tb.c = self.sDeviceID
    end
    if nil ~= self.sRoleUID and 0 ~= self.sRoleUID then
        tb.d = self.sRoleUID
    end
    if nil ~= self.sRoleName and string.len(self.sRoleName) > 0 then
        tb.e = self.sRoleName
    end
    if nil ~= self.sGold and 0 ~= self.sGold then
        tb.f = self.sGold
    end
    if nil ~= self.sAp and 0 ~= self.sAp then
        tb.g = self.sAp
    end
    if nil ~= self.sLevel and 0 ~= self.sLevel then
        tb.h = self.sLevel
    end
    if nil ~= self.sTask and 0 ~= self.sTask then
        tb.i = self.sTask
    end
    if nil ~= self.tDeviceID and string.len(self.tDeviceID) > 0 then
        tb.j = self.tDeviceID
    end
    if nil ~= self.tRoleUID and 0 ~= self.tRoleUID then
        tb.k = self.tRoleUID
    end
    if nil ~= self.tRoleName and string.len(self.tRoleName) > 0 then
        tb.l = self.tRoleName
    end
    if nil ~= self.tGold and 0 ~= self.tGold then
        tb.m = self.tGold
    end
    if nil ~= self.tAp and 0 ~= self.tAp then
        tb.n = self.tAp
    end
    if nil ~= self.tLevel and 0 ~= self.tLevel then
        tb.o = self.tLevel
    end
    if nil ~= self.tTask and 0 ~= self.tTask then
        tb.p = self.tTask
    end
    return tb
end

function MsgType.RoleCoverRecord:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.coverTime = 0
    self.sDeviceID = ""
    self.sRoleUID = 0
    self.sRoleName = ""
    self.sGold = 0
    self.sAp = 0
    self.sLevel = 0
    self.sTask = 0
    self.tDeviceID = ""
    self.tRoleUID = 0
    self.tRoleName = ""
    self.tGold = 0
    self.tAp = 0
    self.tLevel = 0
    self.tTask = 0
    if nil ~= data.b then
        self.coverTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.sDeviceID = tostring(data.c)
    end
    if nil ~= data.d then
        self.sRoleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.sRoleName = tostring(data.e)
    end
    if nil ~= data.f then
        self.sGold = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sAp = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.sLevel = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.sTask = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.tDeviceID = tostring(data.j)
    end
    if nil ~= data.k then
        self.tRoleUID = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.tRoleName = tostring(data.l)
    end
    if nil ~= data.m then
        self.tGold = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.tAp = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.tLevel = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.tTask = tonumber(data.p) or 0
    end
    return self
end

function MsgType.RoleCoverRecord:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.LevelCheckData = {
    levelID = 0,
    result = 0,
    money = 0,
    step = 0,
    remainStep = 0,
    moveSteps = "",
    targetSteps = "",
    levelDataSign = "",
    checkSign = ""
}
MsgType.LevelCheckData.__index = MsgType.LevelCheckData

function MsgType.LevelCheckData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelCheckData:Encode()
    local tb = {}
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.b = self.levelID
    end
    if nil ~= self.result and 0 ~= self.result then
        tb.c = self.result
    end
    if nil ~= self.money and 0 ~= self.money then
        tb.d = self.money
    end
    if nil ~= self.step and 0 ~= self.step then
        tb.e = self.step
    end
    if nil ~= self.remainStep and 0 ~= self.remainStep then
        tb.f = self.remainStep
    end
    if nil ~= self.moveSteps and string.len(self.moveSteps) > 0 then
        tb.g = self.moveSteps
    end
    if nil ~= self.targetSteps and string.len(self.targetSteps) > 0 then
        tb.h = self.targetSteps
    end
    if nil ~= self.levelDataSign and string.len(self.levelDataSign) > 0 then
        tb.i = self.levelDataSign
    end
    if nil ~= self.checkSign and string.len(self.checkSign) > 0 then
        tb.j = self.checkSign
    end
    return tb
end

function MsgType.LevelCheckData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelID = 0
    self.result = 0
    self.money = 0
    self.step = 0
    self.remainStep = 0
    self.moveSteps = ""
    self.targetSteps = ""
    self.levelDataSign = ""
    self.checkSign = ""
    if nil ~= data.b then
        self.levelID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.result = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.money = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.step = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainStep = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.moveSteps = tostring(data.g)
    end
    if nil ~= data.h then
        self.targetSteps = tostring(data.h)
    end
    if nil ~= data.i then
        self.levelDataSign = tostring(data.i)
    end
    if nil ~= data.j then
        self.checkSign = tostring(data.j)
    end
    return self
end

function MsgType.LevelCheckData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FriendCastEvent = {
    optType = 0, --enum EFriendOptType
    roleUID = 0,
    targetUID = 0
}
MsgType.FriendCastEvent.__index = MsgType.FriendCastEvent

function MsgType.FriendCastEvent:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FriendCastEvent:Encode()
    local tb = {}
    if nil ~= self.optType and 0 ~= self.optType then
        tb.b = self.optType
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    if nil ~= self.targetUID and 0 ~= self.targetUID then
        tb.d = self.targetUID
    end
    return tb
end

function MsgType.FriendCastEvent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.roleUID = 0
    self.targetUID = 0
    if nil ~= data.b then
        self.optType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.targetUID = tonumber(data.d) or 0
    end
    return self
end

function MsgType.FriendCastEvent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGTestRqst = {
    msgSeq = 0,
    val = 0
}
MsgType.CGTestRqst.__index = MsgType.CGTestRqst

function MsgType.CGTestRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTestRqst:GetCmd()
    return MsgTypeCmd.CG_TestRqst
end
function MsgType.CGTestRqst:GetUrl()
    return "CGTestRqst"
end
function MsgType.CGTestRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.val and 0 ~= self.val then
        tb.c = self.val
    end
    return tb
end

function MsgType.CGTestRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTestRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTestRspd = {
    msgSeq = 0,
    val = 0
}
MsgType.GCTestRspd.__index = MsgType.GCTestRspd

function MsgType.GCTestRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTestRspd:GetCmd()
    return MsgTypeCmd.GC_TestRspd
end
function MsgType.GCTestRspd:GetUrl()
    return "GCTestRspd"
end
function MsgType.GCTestRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.val = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.val = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGLbsMapGetListRqst = {
    msgSeq = 0,
    initFlag = 0,
    location = ""
}
MsgType.CGLbsMapGetListRqst.__index = MsgType.CGLbsMapGetListRqst

function MsgType.CGLbsMapGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapGetListRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapGetListRqst
end
function MsgType.CGLbsMapGetListRqst:GetUrl()
    return "CGLbsMapGetListRqst"
end
function MsgType.CGLbsMapGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.initFlag and 0 ~= self.initFlag then
        tb.c = self.initFlag
    end
    if nil ~= self.location and string.len(self.location) > 0 then
        tb.d = self.location
    end
    return tb
end

function MsgType.CGLbsMapGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapGetListRspd = {
    msgSeq = 0,
    notiType = 0, --enum EPoiListNotiType
    poiList = {} -- array of MsgType.PoiInfoStruct
}
MsgType.GCLbsMapGetListRspd.__index = MsgType.GCLbsMapGetListRspd

function MsgType.GCLbsMapGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapGetListRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapGetListRspd
end
function MsgType.GCLbsMapGetListRspd:GetUrl()
    return "GCLbsMapGetListRspd"
end
function MsgType.GCLbsMapGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.notiType = 0
    self.poiList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.notiType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpPoiListObj = MsgType.PoiInfoStruct:New()
            tmpPoiListObj:Decode(data.d[i])
            self.poiList[i] = tmpPoiListObj
        end
    end
    return self
end


MsgType.CGLbsMapRefreshListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGLbsMapRefreshListRqst.__index = MsgType.CGLbsMapRefreshListRqst

function MsgType.CGLbsMapRefreshListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapRefreshListRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapRefreshListRqst
end
function MsgType.CGLbsMapRefreshListRqst:GetUrl()
    return "CGLbsMapRefreshListRqst"
end
function MsgType.CGLbsMapRefreshListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGLbsMapRefreshListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapRefreshListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapRefreshListRspd = {
    msgSeq = 0,
    errorCode = 0 --enum ELbsMapOptCode
}
MsgType.GCLbsMapRefreshListRspd.__index = MsgType.GCLbsMapRefreshListRspd

function MsgType.GCLbsMapRefreshListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapRefreshListRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapRefreshListRspd
end
function MsgType.GCLbsMapRefreshListRspd:GetUrl()
    return "GCLbsMapRefreshListRspd"
end
function MsgType.GCLbsMapRefreshListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGLbsMapGetStepInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGLbsMapGetStepInfoRqst.__index = MsgType.CGLbsMapGetStepInfoRqst

function MsgType.CGLbsMapGetStepInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapGetStepInfoRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapGetStepInfoRqst
end
function MsgType.CGLbsMapGetStepInfoRqst:GetUrl()
    return "CGLbsMapGetStepInfoRqst"
end
function MsgType.CGLbsMapGetStepInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGLbsMapGetStepInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapGetStepInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapGetStepInfoRspd = {
    msgSeq = 0,
    curStep = 0,
    rewardFlag = 0
}
MsgType.GCLbsMapGetStepInfoRspd.__index = MsgType.GCLbsMapGetStepInfoRspd

function MsgType.GCLbsMapGetStepInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapGetStepInfoRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapGetStepInfoRspd
end
function MsgType.GCLbsMapGetStepInfoRspd:GetUrl()
    return "GCLbsMapGetStepInfoRspd"
end
function MsgType.GCLbsMapGetStepInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curStep = 0
    self.rewardFlag = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.curStep = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGLbsMapUploadStepRqst = {
    msgSeq = 0,
    curStep = 0
}
MsgType.CGLbsMapUploadStepRqst.__index = MsgType.CGLbsMapUploadStepRqst

function MsgType.CGLbsMapUploadStepRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapUploadStepRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapUploadStepRqst
end
function MsgType.CGLbsMapUploadStepRqst:GetUrl()
    return "CGLbsMapUploadStepRqst"
end
function MsgType.CGLbsMapUploadStepRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.curStep and 0 ~= self.curStep then
        tb.c = self.curStep
    end
    return tb
end

function MsgType.CGLbsMapUploadStepRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapUploadStepRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapUploadStepRspd = {
    msgSeq = 0,
    errorCode = 0 --enum ELbsMapOptCode
}
MsgType.GCLbsMapUploadStepRspd.__index = MsgType.GCLbsMapUploadStepRspd

function MsgType.GCLbsMapUploadStepRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapUploadStepRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapUploadStepRspd
end
function MsgType.GCLbsMapUploadStepRspd:GetUrl()
    return "GCLbsMapUploadStepRspd"
end
function MsgType.GCLbsMapUploadStepRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGLbsMapStepRewardRqst = {
    msgSeq = 0,
    rewardIndex = 0
}
MsgType.CGLbsMapStepRewardRqst.__index = MsgType.CGLbsMapStepRewardRqst

function MsgType.CGLbsMapStepRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapStepRewardRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapStepRewardRqst
end
function MsgType.CGLbsMapStepRewardRqst:GetUrl()
    return "CGLbsMapStepRewardRqst"
end
function MsgType.CGLbsMapStepRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rewardIndex and 0 ~= self.rewardIndex then
        tb.c = self.rewardIndex
    end
    return tb
end

function MsgType.CGLbsMapStepRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapStepRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapStepRewardRspd = {
    msgSeq = 0,
    errorCode = 0, --enum ELbsMapOptCode
    rewardFlag = 0
}
MsgType.GCLbsMapStepRewardRspd.__index = MsgType.GCLbsMapStepRewardRspd

function MsgType.GCLbsMapStepRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapStepRewardRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapStepRewardRspd
end
function MsgType.GCLbsMapStepRewardRspd:GetUrl()
    return "GCLbsMapStepRewardRspd"
end
function MsgType.GCLbsMapStepRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.rewardFlag = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGLbsMapUploadLocationRqst = {
    msgSeq = 0,
    location = ""
}
MsgType.CGLbsMapUploadLocationRqst.__index = MsgType.CGLbsMapUploadLocationRqst

function MsgType.CGLbsMapUploadLocationRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLbsMapUploadLocationRqst:GetCmd()
    return MsgTypeCmd.CG_LbsMapUploadLocationRqst
end
function MsgType.CGLbsMapUploadLocationRqst:GetUrl()
    return "CGLbsMapUploadLocationRqst"
end
function MsgType.CGLbsMapUploadLocationRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.location and string.len(self.location) > 0 then
        tb.c = self.location
    end
    return tb
end

function MsgType.CGLbsMapUploadLocationRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLbsMapUploadLocationRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLbsMapUploadLocationRspd = {
    msgSeq = 0,
    errorCode = 0 --enum ELbsMapOptCode
}
MsgType.GCLbsMapUploadLocationRspd.__index = MsgType.GCLbsMapUploadLocationRspd

function MsgType.GCLbsMapUploadLocationRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLbsMapUploadLocationRspd:GetCmd()
    return MsgTypeCmd.GC_LbsMapUploadLocationRspd
end
function MsgType.GCLbsMapUploadLocationRspd:GetUrl()
    return "GCLbsMapUploadLocationRspd"
end
function MsgType.GCLbsMapUploadLocationRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEventGetListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGEventGetListRqst.__index = MsgType.CGEventGetListRqst

function MsgType.CGEventGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventGetListRqst:GetCmd()
    return MsgTypeCmd.CG_EventGetListRqst
end
function MsgType.CGEventGetListRqst:GetUrl()
    return "CGEventGetListRqst"
end
function MsgType.CGEventGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGEventGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventGetListRspd = {
    msgSeq = 0,
    eventList = {} -- array of MsgType.EventDataInMsg
}
MsgType.GCEventGetListRspd.__index = MsgType.GCEventGetListRspd

function MsgType.GCEventGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventGetListRspd:GetCmd()
    return MsgTypeCmd.GC_EventGetListRspd
end
function MsgType.GCEventGetListRspd:GetUrl()
    return "GCEventGetListRspd"
end
function MsgType.GCEventGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpEventListObj = MsgType.EventDataInMsg:New()
            tmpEventListObj:Decode(data.c[i])
            self.eventList[i] = tmpEventListObj
        end
    end
    return self
end


MsgType.CGEventSubmitRqst = {
    msgSeq = 0,
    source = 0, --enum EEventMsgSourceType
    eventid = 0
}
MsgType.CGEventSubmitRqst.__index = MsgType.CGEventSubmitRqst

function MsgType.CGEventSubmitRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventSubmitRqst:GetCmd()
    return MsgTypeCmd.CG_EventSubmitRqst
end
function MsgType.CGEventSubmitRqst:GetUrl()
    return "CGEventSubmitRqst"
end
function MsgType.CGEventSubmitRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.source and 0 ~= self.source then
        tb.c = self.source
    end
    if nil ~= self.eventid and 0 ~= self.eventid then
        tb.d = self.eventid
    end
    return tb
end

function MsgType.CGEventSubmitRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventSubmitRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventSubmitRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EEventOptCode
}
MsgType.GCEventSubmitRspd.__index = MsgType.GCEventSubmitRspd

function MsgType.GCEventSubmitRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventSubmitRspd:GetCmd()
    return MsgTypeCmd.GC_EventSubmitRspd
end
function MsgType.GCEventSubmitRspd:GetUrl()
    return "GCEventSubmitRspd"
end
function MsgType.GCEventSubmitRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEventSelectRqst = {
    msgSeq = 0,
    source = 0, --enum EEventMsgSourceType
    eventid = 0,
    dialogids = {} -- array of number
}
MsgType.CGEventSelectRqst.__index = MsgType.CGEventSelectRqst

function MsgType.CGEventSelectRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventSelectRqst:GetCmd()
    return MsgTypeCmd.CG_EventSelectRqst
end
function MsgType.CGEventSelectRqst:GetUrl()
    return "CGEventSelectRqst"
end
function MsgType.CGEventSelectRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.source and 0 ~= self.source then
        tb.c = self.source
    end
    if nil ~= self.eventid and 0 ~= self.eventid then
        tb.d = self.eventid
    end
    if nil ~= self.dialogids and string.len(self.dialogids) > 0 then
        tb.e = self.dialogids
    end
    return tb
end

function MsgType.CGEventSelectRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventSelectRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventSelectRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EEventOptCode
}
MsgType.GCEventSelectRspd.__index = MsgType.GCEventSelectRspd

function MsgType.GCEventSelectRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventSelectRspd:GetCmd()
    return MsgTypeCmd.GC_EventSelectRspd
end
function MsgType.GCEventSelectRspd:GetUrl()
    return "GCEventSelectRspd"
end
function MsgType.GCEventSelectRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEventResetRqst = {
    msgSeq = 0,
    chapter = 0
}
MsgType.CGEventResetRqst.__index = MsgType.CGEventResetRqst

function MsgType.CGEventResetRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventResetRqst:GetCmd()
    return MsgTypeCmd.CG_EventResetRqst
end
function MsgType.CGEventResetRqst:GetUrl()
    return "CGEventResetRqst"
end
function MsgType.CGEventResetRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chapter and 0 ~= self.chapter then
        tb.c = self.chapter
    end
    return tb
end

function MsgType.CGEventResetRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventResetRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventResetRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EEventOptCode
}
MsgType.GCEventResetRspd.__index = MsgType.GCEventResetRspd

function MsgType.GCEventResetRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventResetRspd:GetCmd()
    return MsgTypeCmd.GC_EventResetRspd
end
function MsgType.GCEventResetRspd:GetUrl()
    return "GCEventResetRspd"
end
function MsgType.GCEventResetRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEventSweepRqst = {
    msgSeq = 0,
    eventid = 0
}
MsgType.CGEventSweepRqst.__index = MsgType.CGEventSweepRqst

function MsgType.CGEventSweepRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventSweepRqst:GetCmd()
    return MsgTypeCmd.CG_EventSweepRqst
end
function MsgType.CGEventSweepRqst:GetUrl()
    return "CGEventSweepRqst"
end
function MsgType.CGEventSweepRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.eventid and 0 ~= self.eventid then
        tb.c = self.eventid
    end
    return tb
end

function MsgType.CGEventSweepRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventSweepRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventSweepRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EEventOptCode
}
MsgType.GCEventSweepRspd.__index = MsgType.GCEventSweepRspd

function MsgType.GCEventSweepRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventSweepRspd:GetCmd()
    return MsgTypeCmd.GC_EventSweepRspd
end
function MsgType.GCEventSweepRspd:GetUrl()
    return "GCEventSweepRspd"
end
function MsgType.GCEventSweepRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEventGetFeelingRqst = {
    msgSeq = 0,
    chapter = 0
}
MsgType.CGEventGetFeelingRqst.__index = MsgType.CGEventGetFeelingRqst

function MsgType.CGEventGetFeelingRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventGetFeelingRqst:GetCmd()
    return MsgTypeCmd.CG_EventGetFeelingRqst
end
function MsgType.CGEventGetFeelingRqst:GetUrl()
    return "CGEventGetFeelingRqst"
end
function MsgType.CGEventGetFeelingRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chapter and 0 ~= self.chapter then
        tb.c = self.chapter
    end
    return tb
end

function MsgType.CGEventGetFeelingRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventGetFeelingRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventGetFeelingRspd = {
    msgSeq = 0,
    chapter = 0,
    resetTimes = 0,
    feelingList = {} -- array of MsgType.FeelingSingle
}
MsgType.GCEventGetFeelingRspd.__index = MsgType.GCEventGetFeelingRspd

function MsgType.GCEventGetFeelingRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventGetFeelingRspd:GetCmd()
    return MsgTypeCmd.GC_EventGetFeelingRspd
end
function MsgType.GCEventGetFeelingRspd:GetUrl()
    return "GCEventGetFeelingRspd"
end
function MsgType.GCEventGetFeelingRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.chapter = 0
    self.resetTimes = 0
    self.feelingList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.chapter = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.resetTimes = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpFeelingListObj = MsgType.FeelingSingle:New()
            tmpFeelingListObj:Decode(data.e[i])
            self.feelingList[i] = tmpFeelingListObj
        end
    end
    return self
end


MsgType.CGEventFeelingRewardRqst = {
    msgSeq = 0,
    chapter = 0,
    npcId = 0,
    rewardIndex = 0
}
MsgType.CGEventFeelingRewardRqst.__index = MsgType.CGEventFeelingRewardRqst

function MsgType.CGEventFeelingRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventFeelingRewardRqst:GetCmd()
    return MsgTypeCmd.CG_EventFeelingRewardRqst
end
function MsgType.CGEventFeelingRewardRqst:GetUrl()
    return "CGEventFeelingRewardRqst"
end
function MsgType.CGEventFeelingRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chapter and 0 ~= self.chapter then
        tb.c = self.chapter
    end
    if nil ~= self.npcId and 0 ~= self.npcId then
        tb.d = self.npcId
    end
    if nil ~= self.rewardIndex and 0 ~= self.rewardIndex then
        tb.e = self.rewardIndex
    end
    return tb
end

function MsgType.CGEventFeelingRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventFeelingRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventFeelingRewardRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EEventOptCode
    chapter = 0,
    npcId = 0,
    rewardIndex = 0
}
MsgType.GCEventFeelingRewardRspd.__index = MsgType.GCEventFeelingRewardRspd

function MsgType.GCEventFeelingRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventFeelingRewardRspd:GetCmd()
    return MsgTypeCmd.GC_EventFeelingRewardRspd
end
function MsgType.GCEventFeelingRewardRspd:GetUrl()
    return "GCEventFeelingRewardRspd"
end
function MsgType.GCEventFeelingRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.chapter = 0
    self.npcId = 0
    self.rewardIndex = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.chapter = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.npcId = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rewardIndex = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGEventResetTimesRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGEventResetTimesRqst.__index = MsgType.CGEventResetTimesRqst

function MsgType.CGEventResetTimesRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEventResetTimesRqst:GetCmd()
    return MsgTypeCmd.CG_EventResetTimesRqst
end
function MsgType.CGEventResetTimesRqst:GetUrl()
    return "CGEventResetTimesRqst"
end
function MsgType.CGEventResetTimesRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGEventResetTimesRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEventResetTimesRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEventResetTimesRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EEventOptCode
    resetTimes = 0
}
MsgType.GCEventResetTimesRspd.__index = MsgType.GCEventResetTimesRspd

function MsgType.GCEventResetTimesRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEventResetTimesRspd:GetCmd()
    return MsgTypeCmd.GC_EventResetTimesRspd
end
function MsgType.GCEventResetTimesRspd:GetUrl()
    return "GCEventResetTimesRspd"
end
function MsgType.GCEventResetTimesRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.resetTimes = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.resetTimes = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGGetLevelInfoRqst = {
    msgSeq = 0,
    source = 0, --enum EEventMsgSourceType
    eventid = 0,
    levelid = 0
}
MsgType.CGGetLevelInfoRqst.__index = MsgType.CGGetLevelInfoRqst

function MsgType.CGGetLevelInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetLevelInfoRqst:GetCmd()
    return MsgTypeCmd.CG_GetLevelInfoRqst
end
function MsgType.CGGetLevelInfoRqst:GetUrl()
    return "CGGetLevelInfoRqst"
end
function MsgType.CGGetLevelInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.source and 0 ~= self.source then
        tb.c = self.source
    end
    if nil ~= self.eventid and 0 ~= self.eventid then
        tb.d = self.eventid
    end
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.e = self.levelid
    end
    return tb
end

function MsgType.CGGetLevelInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetLevelInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGetLevelInfoRspd = {
    msgSeq = 0,
    eventid = 0,
    levelid = 0,
    lastEquipList = {}, -- array of number
    bestEquipList = {}, -- array of number
    godEquipList = {}, -- array of number
    rankList = {} -- array of MsgType.LevelTopSingleInMsg
}
MsgType.GCGetLevelInfoRspd.__index = MsgType.GCGetLevelInfoRspd

function MsgType.GCGetLevelInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGetLevelInfoRspd:GetCmd()
    return MsgTypeCmd.GC_GetLevelInfoRspd
end
function MsgType.GCGetLevelInfoRspd:GetUrl()
    return "GCGetLevelInfoRspd"
end
function MsgType.GCGetLevelInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventid = 0
    self.levelid = 0
    self.lastEquipList = {}
    self.bestEquipList = {}
    self.godEquipList = {}
    self.rankList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.eventid = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.levelid = tonumber(data.d) or 0
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.lastEquipList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.bestEquipList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.godEquipList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpRankListObj = MsgType.LevelTopSingleInMsg:New()
            tmpRankListObj:Decode(data.h[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    return self
end


MsgType.CGCopyTeamRqst = {
    msgSeq = 0,
    levelid = 0,
    enterType = 0, --enum EMapEnterType
    selectItemList = {}, -- array of number
    flag = 0
}
MsgType.CGCopyTeamRqst.__index = MsgType.CGCopyTeamRqst

function MsgType.CGCopyTeamRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCopyTeamRqst:GetCmd()
    return MsgTypeCmd.CG_CopyTeamRqst
end
function MsgType.CGCopyTeamRqst:GetUrl()
    return "CGCopyTeamRqst"
end
function MsgType.CGCopyTeamRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.c = self.levelid
    end
    if nil ~= self.enterType and 0 ~= self.enterType then
        tb.d = self.enterType
    end
    if nil ~= self.selectItemList and string.len(self.selectItemList) > 0 then
        tb.e = self.selectItemList
    end
    if nil ~= self.flag and 0 ~= self.flag then
        tb.f = self.flag
    end
    return tb
end

function MsgType.CGCopyTeamRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCopyTeamRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCopyTeamRspd = {
    msgSeq = 0,
    errorCode = 0, --enum ECopyTeamOptCode
    levelid = 0,
    enterType = 0, --enum EMapEnterType
    selectItemList = {} -- array of number
}
MsgType.GCCopyTeamRspd.__index = MsgType.GCCopyTeamRspd

function MsgType.GCCopyTeamRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCopyTeamRspd:GetCmd()
    return MsgTypeCmd.GC_CopyTeamRspd
end
function MsgType.GCCopyTeamRspd:GetUrl()
    return "GCCopyTeamRspd"
end
function MsgType.GCCopyTeamRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.levelid = 0
    self.enterType = 0
    self.selectItemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.levelid = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.enterType = tonumber(data.e) or 0
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.selectItemList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGUseItemRqst = {
    msgSeq = 0,
    itemType = 0,
    levelID = 0
}
MsgType.CGUseItemRqst.__index = MsgType.CGUseItemRqst

function MsgType.CGUseItemRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUseItemRqst:GetCmd()
    return MsgTypeCmd.CG_UseItemRqst
end
function MsgType.CGUseItemRqst:GetUrl()
    return "CGUseItemRqst"
end
function MsgType.CGUseItemRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.d = self.levelID
    end
    return tb
end

function MsgType.CGUseItemRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUseItemRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUseItemRspd = {
    msgSeq = 0,
    errorCode = 0,
    itemType = 0
}
MsgType.GCUseItemRspd.__index = MsgType.GCUseItemRspd

function MsgType.GCUseItemRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUseItemRspd:GetCmd()
    return MsgTypeCmd.GC_UseItemRspd
end
function MsgType.GCUseItemRspd:GetUrl()
    return "GCUseItemRspd"
end
function MsgType.GCUseItemRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.itemType = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemType = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGGetLevelListRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGGetLevelListRqst.__index = MsgType.CGGetLevelListRqst

function MsgType.CGGetLevelListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetLevelListRqst:GetCmd()
    return MsgTypeCmd.CG_GetLevelListRqst
end
function MsgType.CGGetLevelListRqst:GetUrl()
    return "CGGetLevelListRqst"
end
function MsgType.CGGetLevelListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGGetLevelListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetLevelListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGetLevelListRspd = {
    msgSeq = 0,
    levelList = {}, -- array of number
    difficultyScore = 0
}
MsgType.GCGetLevelListRspd.__index = MsgType.GCGetLevelListRspd

function MsgType.GCGetLevelListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGetLevelListRspd:GetCmd()
    return MsgTypeCmd.GC_GetLevelListRspd
end
function MsgType.GCGetLevelListRspd:GetUrl()
    return "GCGetLevelListRspd"
end
function MsgType.GCGetLevelListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelList = {}
    self.difficultyScore = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.levelList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.d then
        self.difficultyScore = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGFriendGetFriendListRqst = {
    msgSeq = 0,
    getListType = 0, --enum EFriendListType
    rqstParams = ""
}
MsgType.CGFriendGetFriendListRqst.__index = MsgType.CGFriendGetFriendListRqst

function MsgType.CGFriendGetFriendListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGFriendGetFriendListRqst:GetCmd()
    return MsgTypeCmd.CG_FriendGetFriendListRqst
end
function MsgType.CGFriendGetFriendListRqst:GetUrl()
    return "CGFriendGetFriendListRqst"
end
function MsgType.CGFriendGetFriendListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.getListType and 0 ~= self.getListType then
        tb.c = self.getListType
    end
    if nil ~= self.rqstParams and string.len(self.rqstParams) > 0 then
        tb.d = self.rqstParams
    end
    return tb
end

function MsgType.CGFriendGetFriendListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGFriendGetFriendListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCFriendGetFriendListRspd = {
    msgSeq = 0,
    getListType = 0, --enum EFriendListType
    friendList = {}, -- array of MsgType.FriendSingleInMsg
    sendApRemainCount = 0
}
MsgType.GCFriendGetFriendListRspd.__index = MsgType.GCFriendGetFriendListRspd

function MsgType.GCFriendGetFriendListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCFriendGetFriendListRspd:GetCmd()
    return MsgTypeCmd.GC_FriendGetFriendListRspd
end
function MsgType.GCFriendGetFriendListRspd:GetUrl()
    return "GCFriendGetFriendListRspd"
end
function MsgType.GCFriendGetFriendListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.getListType = 0
    self.friendList = {}
    self.sendApRemainCount = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.getListType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpFriendListObj = MsgType.FriendSingleInMsg:New()
            tmpFriendListObj:Decode(data.d[i])
            self.friendList[i] = tmpFriendListObj
        end
    end
    if nil ~= data.e then
        self.sendApRemainCount = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGFansGetFansListRqst = {
    msgSeq = 0,
    getListType = 0 --enum EFansType
}
MsgType.CGFansGetFansListRqst.__index = MsgType.CGFansGetFansListRqst

function MsgType.CGFansGetFansListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGFansGetFansListRqst:GetCmd()
    return MsgTypeCmd.CG_FansGetFansListRqst
end
function MsgType.CGFansGetFansListRqst:GetUrl()
    return "CGFansGetFansListRqst"
end
function MsgType.CGFansGetFansListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.getListType and 0 ~= self.getListType then
        tb.c = self.getListType
    end
    return tb
end

function MsgType.CGFansGetFansListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGFansGetFansListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCFansGetFansListRspd = {
    msgSeq = 0,
    getListType = 0, --enum EFansType
    fansList = {} -- array of MsgType.FansMsg
}
MsgType.GCFansGetFansListRspd.__index = MsgType.GCFansGetFansListRspd

function MsgType.GCFansGetFansListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCFansGetFansListRspd:GetCmd()
    return MsgTypeCmd.GC_FansGetFansListRspd
end
function MsgType.GCFansGetFansListRspd:GetUrl()
    return "GCFansGetFansListRspd"
end
function MsgType.GCFansGetFansListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.getListType = 0
    self.fansList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.getListType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpFansListObj = MsgType.FansMsg:New()
            tmpFansListObj:Decode(data.d[i])
            self.fansList[i] = tmpFansListObj
        end
    end
    return self
end


MsgType.CGFriendOptRqst = {
    msgSeq = 0,
    optType = 0, --enum EFriendOptType
    optID = 0,
    optName = "",
    optIDList = {} -- array of number
}
MsgType.CGFriendOptRqst.__index = MsgType.CGFriendOptRqst

function MsgType.CGFriendOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGFriendOptRqst:GetCmd()
    return MsgTypeCmd.CG_FriendOptRqst
end
function MsgType.CGFriendOptRqst:GetUrl()
    return "CGFriendOptRqst"
end
function MsgType.CGFriendOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    if nil ~= self.optID and 0 ~= self.optID then
        tb.d = self.optID
    end
    if nil ~= self.optName and string.len(self.optName) > 0 then
        tb.e = self.optName
    end
    if nil ~= self.optIDList and string.len(self.optIDList) > 0 then
        tb.f = self.optIDList
    end
    return tb
end

function MsgType.CGFriendOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGFriendOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCFriendOptRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EFriendOptCode
    optType = 0, --enum EFriendOptType
    optID = 0,
    optName = "",
    sendApRemainCount = 0,
    sendApCDTime = 0,
    optIDList = {} -- array of number
}
MsgType.GCFriendOptRspd.__index = MsgType.GCFriendOptRspd

function MsgType.GCFriendOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCFriendOptRspd:GetCmd()
    return MsgTypeCmd.GC_FriendOptRspd
end
function MsgType.GCFriendOptRspd:GetUrl()
    return "GCFriendOptRspd"
end
function MsgType.GCFriendOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.optType = 0
    self.optID = 0
    self.optName = ""
    self.sendApRemainCount = 0
    self.sendApCDTime = 0
    self.optIDList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.optType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.optName = tostring(data.f)
    end
    if nil ~= data.g then
        self.sendApRemainCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.sendApCDTime = tonumber(data.h) or 0
    end
    if nil ~= data.i and #data.i > 0 then
        for i=1, #data.i do
            self.optIDList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGFriendGetEquipModelRqst = {
    msgSeq = 0,
    roleUID = 0
}
MsgType.CGFriendGetEquipModelRqst.__index = MsgType.CGFriendGetEquipModelRqst

function MsgType.CGFriendGetEquipModelRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGFriendGetEquipModelRqst:GetCmd()
    return MsgTypeCmd.CG_FriendGetEquipModelRqst
end
function MsgType.CGFriendGetEquipModelRqst:GetUrl()
    return "CGFriendGetEquipModelRqst"
end
function MsgType.CGFriendGetEquipModelRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    return tb
end

function MsgType.CGFriendGetEquipModelRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGFriendGetEquipModelRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCFriendGetEquipModelRspd = {
    msgSeq = 0,
    roleUID = 0,
    itemList = {} -- array of number
}
MsgType.GCFriendGetEquipModelRspd.__index = MsgType.GCFriendGetEquipModelRspd

function MsgType.GCFriendGetEquipModelRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCFriendGetEquipModelRspd:GetCmd()
    return MsgTypeCmd.GC_FriendGetEquipModelRspd
end
function MsgType.GCFriendGetEquipModelRspd:GetUrl()
    return "GCFriendGetEquipModelRspd"
end
function MsgType.GCFriendGetEquipModelRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.itemList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGFriendGetApDataRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGFriendGetApDataRqst.__index = MsgType.CGFriendGetApDataRqst

function MsgType.CGFriendGetApDataRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGFriendGetApDataRqst:GetCmd()
    return MsgTypeCmd.CG_FriendGetApDataRqst
end
function MsgType.CGFriendGetApDataRqst:GetUrl()
    return "CGFriendGetApDataRqst"
end
function MsgType.CGFriendGetApDataRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGFriendGetApDataRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGFriendGetApDataRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCFriendGetApDataRspd = {
    msgSeq = 0,
    sendApList = {}, -- array of number
    requestApList = {} -- array of number
}
MsgType.GCFriendGetApDataRspd.__index = MsgType.GCFriendGetApDataRspd

function MsgType.GCFriendGetApDataRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCFriendGetApDataRspd:GetCmd()
    return MsgTypeCmd.GC_FriendGetApDataRspd
end
function MsgType.GCFriendGetApDataRspd:GetUrl()
    return "GCFriendGetApDataRspd"
end
function MsgType.GCFriendGetApDataRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.sendApList = {}
    self.requestApList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.sendApList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.requestApList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGPetGetRoomListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPetGetRoomListRqst.__index = MsgType.CGPetGetRoomListRqst

function MsgType.CGPetGetRoomListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetGetRoomListRqst:GetCmd()
    return MsgTypeCmd.CG_PetGetRoomListRqst
end
function MsgType.CGPetGetRoomListRqst:GetUrl()
    return "CGPetGetRoomListRqst"
end
function MsgType.CGPetGetRoomListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPetGetRoomListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetGetRoomListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetGetRoomListRspd = {
    msgSeq = 0,
    roleUID = 0,
    floorList = {}, -- array of MsgType.PetFloorInMsg
    roomList = {}, -- array of MsgType.PetRoomInMsg
    showPetList = {} -- array of MsgType.PetSingleInMsg
}
MsgType.GCPetGetRoomListRspd.__index = MsgType.GCPetGetRoomListRspd

function MsgType.GCPetGetRoomListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetGetRoomListRspd:GetCmd()
    return MsgTypeCmd.GC_PetGetRoomListRspd
end
function MsgType.GCPetGetRoomListRspd:GetUrl()
    return "GCPetGetRoomListRspd"
end
function MsgType.GCPetGetRoomListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.floorList = {}
    self.roomList = {}
    self.showPetList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpFloorListObj = MsgType.PetFloorInMsg:New()
            tmpFloorListObj:Decode(data.d[i])
            self.floorList[i] = tmpFloorListObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRoomListObj = MsgType.PetRoomInMsg:New()
            tmpRoomListObj:Decode(data.e[i])
            self.roomList[i] = tmpRoomListObj
        end
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpShowPetListObj = MsgType.PetSingleInMsg:New()
            tmpShowPetListObj:Decode(data.f[i])
            self.showPetList[i] = tmpShowPetListObj
        end
    end
    return self
end


MsgType.CGPetGetPetListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPetGetPetListRqst.__index = MsgType.CGPetGetPetListRqst

function MsgType.CGPetGetPetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetGetPetListRqst:GetCmd()
    return MsgTypeCmd.CG_PetGetPetListRqst
end
function MsgType.CGPetGetPetListRqst:GetUrl()
    return "CGPetGetPetListRqst"
end
function MsgType.CGPetGetPetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPetGetPetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetGetPetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetGetPetListRspd = {
    msgSeq = 0,
    roleUID = 0,
    petList = {} -- array of MsgType.PetSingleInMsg
}
MsgType.GCPetGetPetListRspd.__index = MsgType.GCPetGetPetListRspd

function MsgType.GCPetGetPetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetGetPetListRspd:GetCmd()
    return MsgTypeCmd.GC_PetGetPetListRspd
end
function MsgType.GCPetGetPetListRspd:GetUrl()
    return "GCPetGetPetListRspd"
end
function MsgType.GCPetGetPetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.petList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.roleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpPetListObj = MsgType.PetSingleInMsg:New()
            tmpPetListObj:Decode(data.d[i])
            self.petList[i] = tmpPetListObj
        end
    end
    return self
end


MsgType.CGPetOptRqst = {
    msgSeq = 0,
    optType = 0, --enum EPetOptType
    optID = 0,
    optPar1 = 0,
    optPar2 = 0
}
MsgType.CGPetOptRqst.__index = MsgType.CGPetOptRqst

function MsgType.CGPetOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetOptRqst:GetCmd()
    return MsgTypeCmd.CG_PetOptRqst
end
function MsgType.CGPetOptRqst:GetUrl()
    return "CGPetOptRqst"
end
function MsgType.CGPetOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    if nil ~= self.optID and 0 ~= self.optID then
        tb.d = self.optID
    end
    if nil ~= self.optPar1 and 0 ~= self.optPar1 then
        tb.e = self.optPar1
    end
    if nil ~= self.optPar2 and 0 ~= self.optPar2 then
        tb.f = self.optPar2
    end
    return tb
end

function MsgType.CGPetOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetOptRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EPetOptCode
    optType = 0, --enum EPetOptType
    optID = 0,
    optPar1 = 0,
    optPar2 = 0,
    optResult1 = 0
}
MsgType.GCPetOptRspd.__index = MsgType.GCPetOptRspd

function MsgType.GCPetOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetOptRspd:GetCmd()
    return MsgTypeCmd.GC_PetOptRspd
end
function MsgType.GCPetOptRspd:GetUrl()
    return "GCPetOptRspd"
end
function MsgType.GCPetOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.optType = 0
    self.optID = 0
    self.optPar1 = 0
    self.optPar2 = 0
    self.optResult1 = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.optType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.optPar1 = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.optPar2 = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.optResult1 = tonumber(data.h) or 0
    end
    return self
end


MsgType.CGShopGetSampleListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGShopGetSampleListRqst.__index = MsgType.CGShopGetSampleListRqst

function MsgType.CGShopGetSampleListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGShopGetSampleListRqst:GetCmd()
    return MsgTypeCmd.CG_ShopGetSampleListRqst
end
function MsgType.CGShopGetSampleListRqst:GetUrl()
    return "CGShopGetSampleListRqst"
end
function MsgType.CGShopGetSampleListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGShopGetSampleListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGShopGetSampleListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCShopGetSampleListRspd = {
    msgSeq = 0,
    shopSampleList = {} -- array of MsgType.ShopSampleInMsg
}
MsgType.GCShopGetSampleListRspd.__index = MsgType.GCShopGetSampleListRspd

function MsgType.GCShopGetSampleListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCShopGetSampleListRspd:GetCmd()
    return MsgTypeCmd.GC_ShopGetSampleListRspd
end
function MsgType.GCShopGetSampleListRspd:GetUrl()
    return "GCShopGetSampleListRspd"
end
function MsgType.GCShopGetSampleListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.shopSampleList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpShopSampleListObj = MsgType.ShopSampleInMsg:New()
            tmpShopSampleListObj:Decode(data.c[i])
            self.shopSampleList[i] = tmpShopSampleListObj
        end
    end
    return self
end


MsgType.CGShopGetGoodsListRqst = {
    msgSeq = 0,
    shopID = 0
}
MsgType.CGShopGetGoodsListRqst.__index = MsgType.CGShopGetGoodsListRqst

function MsgType.CGShopGetGoodsListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGShopGetGoodsListRqst:GetCmd()
    return MsgTypeCmd.CG_ShopGetGoodsListRqst
end
function MsgType.CGShopGetGoodsListRqst:GetUrl()
    return "CGShopGetGoodsListRqst"
end
function MsgType.CGShopGetGoodsListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopID and 0 ~= self.shopID then
        tb.c = self.shopID
    end
    return tb
end

function MsgType.CGShopGetGoodsListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGShopGetGoodsListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCShopGetGoodsListRspd = {
    msgSeq = 0,
    shopID = 0,
    shopGoodsList = {} -- array of MsgType.ShopGoodsInMsg
}
MsgType.GCShopGetGoodsListRspd.__index = MsgType.GCShopGetGoodsListRspd

function MsgType.GCShopGetGoodsListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCShopGetGoodsListRspd:GetCmd()
    return MsgTypeCmd.GC_ShopGetGoodsListRspd
end
function MsgType.GCShopGetGoodsListRspd:GetUrl()
    return "GCShopGetGoodsListRspd"
end
function MsgType.GCShopGetGoodsListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.shopID = 0
    self.shopGoodsList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.shopID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpShopGoodsListObj = MsgType.ShopGoodsInMsg:New()
            tmpShopGoodsListObj:Decode(data.d[i])
            self.shopGoodsList[i] = tmpShopGoodsListObj
        end
    end
    return self
end


MsgType.CGShopGetVipCardListRqst = {
    msgSeq = 0,
    shopID = 0
}
MsgType.CGShopGetVipCardListRqst.__index = MsgType.CGShopGetVipCardListRqst

function MsgType.CGShopGetVipCardListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGShopGetVipCardListRqst:GetCmd()
    return MsgTypeCmd.CG_ShopGetVipCardListRqst
end
function MsgType.CGShopGetVipCardListRqst:GetUrl()
    return "CGShopGetVipCardListRqst"
end
function MsgType.CGShopGetVipCardListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopID and 0 ~= self.shopID then
        tb.c = self.shopID
    end
    return tb
end

function MsgType.CGShopGetVipCardListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGShopGetVipCardListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCShopGetVipCardListRspd = {
    msgSeq = 0,
    shopID = 0,
    vipCardList = {} -- array of MsgType.ShopVipCardInMsg
}
MsgType.GCShopGetVipCardListRspd.__index = MsgType.GCShopGetVipCardListRspd

function MsgType.GCShopGetVipCardListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCShopGetVipCardListRspd:GetCmd()
    return MsgTypeCmd.GC_ShopGetVipCardListRspd
end
function MsgType.GCShopGetVipCardListRspd:GetUrl()
    return "GCShopGetVipCardListRspd"
end
function MsgType.GCShopGetVipCardListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.shopID = 0
    self.vipCardList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.shopID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpVipCardListObj = MsgType.ShopVipCardInMsg:New()
            tmpVipCardListObj:Decode(data.d[i])
            self.vipCardList[i] = tmpVipCardListObj
        end
    end
    return self
end


MsgType.CGShopBuyGoodsRqst = {
    msgSeq = 0,
    shopID = 0,
    shopGoodsGroupID = 0,
    shopGoodsID = 0
}
MsgType.CGShopBuyGoodsRqst.__index = MsgType.CGShopBuyGoodsRqst

function MsgType.CGShopBuyGoodsRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGShopBuyGoodsRqst:GetCmd()
    return MsgTypeCmd.CG_ShopBuyGoodsRqst
end
function MsgType.CGShopBuyGoodsRqst:GetUrl()
    return "CGShopBuyGoodsRqst"
end
function MsgType.CGShopBuyGoodsRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopID and 0 ~= self.shopID then
        tb.c = self.shopID
    end
    if nil ~= self.shopGoodsGroupID and 0 ~= self.shopGoodsGroupID then
        tb.d = self.shopGoodsGroupID
    end
    if nil ~= self.shopGoodsID and 0 ~= self.shopGoodsID then
        tb.e = self.shopGoodsID
    end
    return tb
end

function MsgType.CGShopBuyGoodsRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGShopBuyGoodsRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCShopBuyGoodsRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EShopOptCode
    shopID = 0,
    shopGoodsGroupID = 0,
    shopGoodsID = 0
}
MsgType.GCShopBuyGoodsRspd.__index = MsgType.GCShopBuyGoodsRspd

function MsgType.GCShopBuyGoodsRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCShopBuyGoodsRspd:GetCmd()
    return MsgTypeCmd.GC_ShopBuyGoodsRspd
end
function MsgType.GCShopBuyGoodsRspd:GetUrl()
    return "GCShopBuyGoodsRspd"
end
function MsgType.GCShopBuyGoodsRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.shopID = 0
    self.shopGoodsGroupID = 0
    self.shopGoodsID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.shopID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.shopGoodsGroupID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.shopGoodsID = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGMailGetListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGMailGetListRqst.__index = MsgType.CGMailGetListRqst

function MsgType.CGMailGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMailGetListRqst:GetCmd()
    return MsgTypeCmd.CG_MailGetListRqst
end
function MsgType.CGMailGetListRqst:GetUrl()
    return "CGMailGetListRqst"
end
function MsgType.CGMailGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGMailGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMailGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMailGetListRspd = {
    msgSeq = 0,
    mailSimpleList = {}, -- array of MsgType.MailSimpleInMsg
    senderList = {}, -- array of MsgType.MailSenderSingleInMsg
    remainPickApTimes = 0,
    serverTime = 0
}
MsgType.GCMailGetListRspd.__index = MsgType.GCMailGetListRspd

function MsgType.GCMailGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMailGetListRspd:GetCmd()
    return MsgTypeCmd.GC_MailGetListRspd
end
function MsgType.GCMailGetListRspd:GetUrl()
    return "GCMailGetListRspd"
end
function MsgType.GCMailGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mailSimpleList = {}
    self.senderList = {}
    self.remainPickApTimes = 0
    self.serverTime = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpMailSimpleListObj = MsgType.MailSimpleInMsg:New()
            tmpMailSimpleListObj:Decode(data.c[i])
            self.mailSimpleList[i] = tmpMailSimpleListObj
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpSenderListObj = MsgType.MailSenderSingleInMsg:New()
            tmpSenderListObj:Decode(data.d[i])
            self.senderList[i] = tmpSenderListObj
        end
    end
    if nil ~= data.e then
        self.remainPickApTimes = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.serverTime = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGMailReadRqst = {
    msgSeq = 0,
    mailID = 0
}
MsgType.CGMailReadRqst.__index = MsgType.CGMailReadRqst

function MsgType.CGMailReadRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMailReadRqst:GetCmd()
    return MsgTypeCmd.CG_MailReadRqst
end
function MsgType.CGMailReadRqst:GetUrl()
    return "CGMailReadRqst"
end
function MsgType.CGMailReadRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailID and 0 ~= self.mailID then
        tb.c = self.mailID
    end
    return tb
end

function MsgType.CGMailReadRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMailReadRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMailReadRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EMailOptCode
    mailID = 0,
    mailDetail = {}
}
MsgType.GCMailReadRspd.__index = MsgType.GCMailReadRspd
setmetatable(MsgType.GCMailReadRspd.mailDetail, MsgType.MailDetailInMsg)

function MsgType.GCMailReadRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMailReadRspd:GetCmd()
    return MsgTypeCmd.GC_MailReadRspd
end
function MsgType.GCMailReadRspd:GetUrl()
    return "GCMailReadRspd"
end
function MsgType.GCMailReadRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.mailID = 0
    self.mailDetail = MsgType.MailDetailInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.mailID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.mailDetail:Decode(data.e)
    end
    return self
end


MsgType.CGMailPickAttachmentRqst = {
    msgSeq = 0,
    mailID = 0
}
MsgType.CGMailPickAttachmentRqst.__index = MsgType.CGMailPickAttachmentRqst

function MsgType.CGMailPickAttachmentRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMailPickAttachmentRqst:GetCmd()
    return MsgTypeCmd.CG_MailPickAttachmentRqst
end
function MsgType.CGMailPickAttachmentRqst:GetUrl()
    return "CGMailPickAttachmentRqst"
end
function MsgType.CGMailPickAttachmentRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailID and 0 ~= self.mailID then
        tb.c = self.mailID
    end
    return tb
end

function MsgType.CGMailPickAttachmentRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMailPickAttachmentRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMailPickAttachmentRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EMailOptCode
    mailID = 0,
    remainPickApTimes = 0,
    flag = 0
}
MsgType.GCMailPickAttachmentRspd.__index = MsgType.GCMailPickAttachmentRspd

function MsgType.GCMailPickAttachmentRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMailPickAttachmentRspd:GetCmd()
    return MsgTypeCmd.GC_MailPickAttachmentRspd
end
function MsgType.GCMailPickAttachmentRspd:GetUrl()
    return "GCMailPickAttachmentRspd"
end
function MsgType.GCMailPickAttachmentRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.mailID = 0
    self.remainPickApTimes = 0
    self.flag = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.mailID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.remainPickApTimes = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.flag = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGMailDeleteRqst = {
    msgSeq = 0,
    mailID = 0
}
MsgType.CGMailDeleteRqst.__index = MsgType.CGMailDeleteRqst

function MsgType.CGMailDeleteRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMailDeleteRqst:GetCmd()
    return MsgTypeCmd.CG_MailDeleteRqst
end
function MsgType.CGMailDeleteRqst:GetUrl()
    return "CGMailDeleteRqst"
end
function MsgType.CGMailDeleteRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailID and 0 ~= self.mailID then
        tb.c = self.mailID
    end
    return tb
end

function MsgType.CGMailDeleteRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMailDeleteRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMailDeleteRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EMailOptCode
    mailID = 0
}
MsgType.GCMailDeleteRspd.__index = MsgType.GCMailDeleteRspd

function MsgType.GCMailDeleteRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMailDeleteRspd:GetCmd()
    return MsgTypeCmd.GC_MailDeleteRspd
end
function MsgType.GCMailDeleteRspd:GetUrl()
    return "GCMailDeleteRspd"
end
function MsgType.GCMailDeleteRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.mailID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.mailID = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGRedTipGetDataRqst = {
    msgSeq = 0,
    redTipTypeList = {} -- array of number --enum ERedTipType
}
MsgType.CGRedTipGetDataRqst.__index = MsgType.CGRedTipGetDataRqst

function MsgType.CGRedTipGetDataRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRedTipGetDataRqst:GetCmd()
    return MsgTypeCmd.CG_RedTipGetDataRqst
end
function MsgType.CGRedTipGetDataRqst:GetUrl()
    return "CGRedTipGetDataRqst"
end
function MsgType.CGRedTipGetDataRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.redTipTypeList and string.len(self.redTipTypeList) > 0 then
        tb.c = self.redTipTypeList
    end
    return tb
end

function MsgType.CGRedTipGetDataRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRedTipGetDataRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRedTipGetDataRspd = {
    msgSeq = 0,
    tipList = {} -- array of MsgType.RedTip
}
MsgType.GCRedTipGetDataRspd.__index = MsgType.GCRedTipGetDataRspd

function MsgType.GCRedTipGetDataRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRedTipGetDataRspd:GetCmd()
    return MsgTypeCmd.GC_RedTipGetDataRspd
end
function MsgType.GCRedTipGetDataRspd:GetUrl()
    return "GCRedTipGetDataRspd"
end
function MsgType.GCRedTipGetDataRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.tipList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpTipListObj = MsgType.RedTip:New()
            tmpTipListObj:Decode(data.c[i])
            self.tipList[i] = tmpTipListObj
        end
    end
    return self
end


MsgType.CGRedTipClearTipRqst = {
    msgSeq = 0,
    redTipType = 0 --enum ERedTipType
}
MsgType.CGRedTipClearTipRqst.__index = MsgType.CGRedTipClearTipRqst

function MsgType.CGRedTipClearTipRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRedTipClearTipRqst:GetCmd()
    return MsgTypeCmd.CG_RedTipClearTipRqst
end
function MsgType.CGRedTipClearTipRqst:GetUrl()
    return "CGRedTipClearTipRqst"
end
function MsgType.CGRedTipClearTipRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.redTipType and 0 ~= self.redTipType then
        tb.c = self.redTipType
    end
    return tb
end

function MsgType.CGRedTipClearTipRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRedTipClearTipRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRedTipClearTipRspd = {
    msgSeq = 0,
    nouse = 0
}
MsgType.GCRedTipClearTipRspd.__index = MsgType.GCRedTipClearTipRspd

function MsgType.GCRedTipClearTipRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRedTipClearTipRspd:GetCmd()
    return MsgTypeCmd.GC_RedTipClearTipRspd
end
function MsgType.GCRedTipClearTipRspd:GetUrl()
    return "GCRedTipClearTipRspd"
end
function MsgType.GCRedTipClearTipRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGPayActivityRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPayActivityRqst.__index = MsgType.CGPayActivityRqst

function MsgType.CGPayActivityRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPayActivityRqst:GetCmd()
    return MsgTypeCmd.CG_PayActivityRqst
end
function MsgType.CGPayActivityRqst:GetUrl()
    return "CGPayActivityRqst"
end
function MsgType.CGPayActivityRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPayActivityRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPayActivityRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPayActivityRspd = {
    msgSeq = 0,
    rechargeOpen = 0,
    itemShopStartTime = 0,
    itemShopEndTime = 0,
    itemShopRemainTime = 0,
    festivalStartTime = 0,
    festivalEndTime = 0,
    festivalRemainTime = 0,
    salesStartTime = 0,
    salesEndTime = 0,
    salesRemainTime = 0
}
MsgType.GCPayActivityRspd.__index = MsgType.GCPayActivityRspd

function MsgType.GCPayActivityRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPayActivityRspd:GetCmd()
    return MsgTypeCmd.GC_PayActivityRspd
end
function MsgType.GCPayActivityRspd:GetUrl()
    return "GCPayActivityRspd"
end
function MsgType.GCPayActivityRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.rechargeOpen = 0
    self.itemShopStartTime = 0
    self.itemShopEndTime = 0
    self.itemShopRemainTime = 0
    self.festivalStartTime = 0
    self.festivalEndTime = 0
    self.festivalRemainTime = 0
    self.salesStartTime = 0
    self.salesEndTime = 0
    self.salesRemainTime = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.rechargeOpen = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemShopStartTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemShopEndTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.itemShopRemainTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.festivalStartTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.festivalEndTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.festivalRemainTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.salesStartTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.salesEndTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.salesRemainTime = tonumber(data.l) or 0
    end
    return self
end


MsgType.CGPayListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPayListRqst.__index = MsgType.CGPayListRqst

function MsgType.CGPayListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPayListRqst:GetCmd()
    return MsgTypeCmd.CG_PayListRqst
end
function MsgType.CGPayListRqst:GetUrl()
    return "CGPayListRqst"
end
function MsgType.CGPayListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPayListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPayListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPayListRspd = {
    msgSeq = 0,
    rechargeList = {}, -- array of MsgType.PayListItem
    itemShopList = {}, -- array of MsgType.PayListItem
    festivalList = {}, -- array of MsgType.PayListItem
    salesList = {}, -- array of MsgType.PayListItem
    rechargeOpen = 0
}
MsgType.GCPayListRspd.__index = MsgType.GCPayListRspd

function MsgType.GCPayListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPayListRspd:GetCmd()
    return MsgTypeCmd.GC_PayListRspd
end
function MsgType.GCPayListRspd:GetUrl()
    return "GCPayListRspd"
end
function MsgType.GCPayListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.rechargeList = {}
    self.itemShopList = {}
    self.festivalList = {}
    self.salesList = {}
    self.rechargeOpen = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpRechargeListObj = MsgType.PayListItem:New()
            tmpRechargeListObj:Decode(data.c[i])
            self.rechargeList[i] = tmpRechargeListObj
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpItemShopListObj = MsgType.PayListItem:New()
            tmpItemShopListObj:Decode(data.d[i])
            self.itemShopList[i] = tmpItemShopListObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpFestivalListObj = MsgType.PayListItem:New()
            tmpFestivalListObj:Decode(data.e[i])
            self.festivalList[i] = tmpFestivalListObj
        end
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpSalesListObj = MsgType.PayListItem:New()
            tmpSalesListObj:Decode(data.f[i])
            self.salesList[i] = tmpSalesListObj
        end
    end
    if nil ~= data.g then
        self.rechargeOpen = tonumber(data.g) or 0
    end
    return self
end


MsgType.CGPayItemShopBuyRqst = {
    msgSeq = 0,
    payListType = 0, --enum EPayListType
    id = 0,
    count = 0
}
MsgType.CGPayItemShopBuyRqst.__index = MsgType.CGPayItemShopBuyRqst

function MsgType.CGPayItemShopBuyRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPayItemShopBuyRqst:GetCmd()
    return MsgTypeCmd.CG_PayItemShopBuyRqst
end
function MsgType.CGPayItemShopBuyRqst:GetUrl()
    return "CGPayItemShopBuyRqst"
end
function MsgType.CGPayItemShopBuyRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.payListType and 0 ~= self.payListType then
        tb.c = self.payListType
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.e = self.count
    end
    return tb
end

function MsgType.CGPayItemShopBuyRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPayItemShopBuyRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPayItemShopBuyRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EPayErrorCode
    id = 0,
    count = 0,
    itemList = {} -- array of MsgType.ItemInPayList
}
MsgType.GCPayItemShopBuyRspd.__index = MsgType.GCPayItemShopBuyRspd

function MsgType.GCPayItemShopBuyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPayItemShopBuyRspd:GetCmd()
    return MsgTypeCmd.GC_PayItemShopBuyRspd
end
function MsgType.GCPayItemShopBuyRspd:GetUrl()
    return "GCPayItemShopBuyRspd"
end
function MsgType.GCPayItemShopBuyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.id = 0
    self.count = 0
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.id = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.count = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpItemListObj = MsgType.ItemInPayList:New()
            tmpItemListObj:Decode(data.f[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.CGPayOrderRqst = {
    msgSeq = 0,
    payPlatformType = 0, --enum EPaymentType
    payListType = 0, --enum EPayListType
    id = 0,
    account = "",
    roleUID = 0
}
MsgType.CGPayOrderRqst.__index = MsgType.CGPayOrderRqst

function MsgType.CGPayOrderRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPayOrderRqst:GetCmd()
    return MsgTypeCmd.CG_PayOrderRqst
end
function MsgType.CGPayOrderRqst:GetUrl()
    return "CGPayOrderRqst"
end
function MsgType.CGPayOrderRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.payPlatformType and 0 ~= self.payPlatformType then
        tb.c = self.payPlatformType
    end
    if nil ~= self.payListType and 0 ~= self.payListType then
        tb.d = self.payListType
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.e = self.id
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.f = self.account
    end
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.g = self.roleUID
    end
    return tb
end

function MsgType.CGPayOrderRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPayOrderRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPayOrderRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EPayErrorCode
    jsonStr = ""
}
MsgType.GCPayOrderRspd.__index = MsgType.GCPayOrderRspd

function MsgType.GCPayOrderRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPayOrderRspd:GetCmd()
    return MsgTypeCmd.GC_PayOrderRspd
end
function MsgType.GCPayOrderRspd:GetUrl()
    return "GCPayOrderRspd"
end
function MsgType.GCPayOrderRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.jsonStr = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.jsonStr = tostring(data.d)
    end
    return self
end


MsgType.CGPayBalanceRqst = {
    msgSeq = 0,
    jsonStr = ""
}
MsgType.CGPayBalanceRqst.__index = MsgType.CGPayBalanceRqst

function MsgType.CGPayBalanceRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPayBalanceRqst:GetCmd()
    return MsgTypeCmd.CG_PayBalanceRqst
end
function MsgType.CGPayBalanceRqst:GetUrl()
    return "CGPayBalanceRqst"
end
function MsgType.CGPayBalanceRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.jsonStr and string.len(self.jsonStr) > 0 then
        tb.c = self.jsonStr
    end
    return tb
end

function MsgType.CGPayBalanceRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPayBalanceRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPayBalanceRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EPayErrorCode
}
MsgType.GCPayBalanceRspd.__index = MsgType.GCPayBalanceRspd

function MsgType.GCPayBalanceRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPayBalanceRspd:GetCmd()
    return MsgTypeCmd.GC_PayBalanceRspd
end
function MsgType.GCPayBalanceRspd:GetUrl()
    return "GCPayBalanceRspd"
end
function MsgType.GCPayBalanceRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.GCPaySuccessRspd = {
    msgSeq = 0,
    payListType = 0, --enum EPayListType
    id = 0,
    itemList = {} -- array of MsgType.ItemInPayList
}
MsgType.GCPaySuccessRspd.__index = MsgType.GCPaySuccessRspd

function MsgType.GCPaySuccessRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPaySuccessRspd:GetCmd()
    return MsgTypeCmd.GC_PaySuccessRspd
end
function MsgType.GCPaySuccessRspd:GetUrl()
    return "GCPaySuccessRspd"
end
function MsgType.GCPaySuccessRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.payListType = 0
    self.id = 0
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.payListType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.id = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpItemListObj = MsgType.ItemInPayList:New()
            tmpItemListObj:Decode(data.e[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.CGMapGetInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGMapGetInfoRqst.__index = MsgType.CGMapGetInfoRqst

function MsgType.CGMapGetInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMapGetInfoRqst:GetCmd()
    return MsgTypeCmd.CG_MapGetInfoRqst
end
function MsgType.CGMapGetInfoRqst:GetUrl()
    return "CGMapGetInfoRqst"
end
function MsgType.CGMapGetInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGMapGetInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMapGetInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMapGetInfoRspd = {
    msgSeq = 0,
    mapData = {}
}
MsgType.GCMapGetInfoRspd.__index = MsgType.GCMapGetInfoRspd
setmetatable(MsgType.GCMapGetInfoRspd.mapData, MsgType.MapDataInMsg)

function MsgType.GCMapGetInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMapGetInfoRspd:GetCmd()
    return MsgTypeCmd.GC_MapGetInfoRspd
end
function MsgType.GCMapGetInfoRspd:GetUrl()
    return "GCMapGetInfoRspd"
end
function MsgType.GCMapGetInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mapData = MsgType.MapDataInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.mapData:Decode(data.c)
    end
    return self
end


MsgType.CGMapRollDiceRqst = {
    msgSeq = 0,
    diceType = 0, --enum EMapDiceType
    mapID = 0,
    slotID = 0
}
MsgType.CGMapRollDiceRqst.__index = MsgType.CGMapRollDiceRqst

function MsgType.CGMapRollDiceRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMapRollDiceRqst:GetCmd()
    return MsgTypeCmd.CG_MapRollDiceRqst
end
function MsgType.CGMapRollDiceRqst:GetUrl()
    return "CGMapRollDiceRqst"
end
function MsgType.CGMapRollDiceRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.diceType and 0 ~= self.diceType then
        tb.c = self.diceType
    end
    if nil ~= self.mapID and 0 ~= self.mapID then
        tb.d = self.mapID
    end
    if nil ~= self.slotID and 0 ~= self.slotID then
        tb.e = self.slotID
    end
    return tb
end

function MsgType.CGMapRollDiceRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMapRollDiceRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMapRollDiceRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EMapOptCode
    step = 0,
    diceType = 0, --enum EMapDiceType
    curMapID = 0,
    curSlotID = 0,
    curSlotStatus = 0, --enum EMapSlotEventStatus
    newMap = {} -- array of MsgType.OneMapInMsg
}
MsgType.GCMapRollDiceRspd.__index = MsgType.GCMapRollDiceRspd

function MsgType.GCMapRollDiceRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMapRollDiceRspd:GetCmd()
    return MsgTypeCmd.GC_MapRollDiceRspd
end
function MsgType.GCMapRollDiceRspd:GetUrl()
    return "GCMapRollDiceRspd"
end
function MsgType.GCMapRollDiceRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.step = 0
    self.diceType = 0
    self.curMapID = 0
    self.curSlotID = 0
    self.curSlotStatus = 0
    self.newMap = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.step = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.diceType = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.curMapID = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.curSlotID = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.curSlotStatus = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpNewMapObj = MsgType.OneMapInMsg:New()
            tmpNewMapObj:Decode(data.i[i])
            self.newMap[i] = tmpNewMapObj
        end
    end
    return self
end


MsgType.GCMapUpgradeRspd = {
    msgSeq = 0,
    curMapLevel = 0
}
MsgType.GCMapUpgradeRspd.__index = MsgType.GCMapUpgradeRspd

function MsgType.GCMapUpgradeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMapUpgradeRspd:GetCmd()
    return MsgTypeCmd.GC_MapUpgradeRspd
end
function MsgType.GCMapUpgradeRspd:GetUrl()
    return "GCMapUpgradeRspd"
end
function MsgType.GCMapUpgradeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curMapLevel = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.curMapLevel = tonumber(data.c) or 0
    end
    return self
end


MsgType.GCSrvNotifyRspd = {
    msgSeq = 0,
    notifyType = 0, --enum ESrvNotifyType
    notiParam1 = 0,
    notiParam2 = 0
}
MsgType.GCSrvNotifyRspd.__index = MsgType.GCSrvNotifyRspd

function MsgType.GCSrvNotifyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSrvNotifyRspd:GetCmd()
    return MsgTypeCmd.GC_SrvNotifyRspd
end
function MsgType.GCSrvNotifyRspd:GetUrl()
    return "GCSrvNotifyRspd"
end
function MsgType.GCSrvNotifyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.notifyType = 0
    self.notiParam1 = 0
    self.notiParam2 = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.notifyType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.notiParam1 = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.notiParam2 = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGSyncWebServerInfoRqst = {
    msgSeq = 0,
    webServerHost = "",
    webServerPort = 0,
    account = ""
}
MsgType.CGSyncWebServerInfoRqst.__index = MsgType.CGSyncWebServerInfoRqst

function MsgType.CGSyncWebServerInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSyncWebServerInfoRqst:GetCmd()
    return MsgTypeCmd.CG_SyncWebServerInfoRqst
end
function MsgType.CGSyncWebServerInfoRqst:GetUrl()
    return "CGSyncWebServerInfoRqst"
end
function MsgType.CGSyncWebServerInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.webServerHost and string.len(self.webServerHost) > 0 then
        tb.c = self.webServerHost
    end
    if nil ~= self.webServerPort and 0 ~= self.webServerPort then
        tb.d = self.webServerPort
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.e = self.account
    end
    return tb
end

function MsgType.CGSyncWebServerInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSyncWebServerInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCSyncWebServerInfoRspd = {
    msgSeq = 0,
    webServerHost = "",
    webServerPort = 0
}
MsgType.GCSyncWebServerInfoRspd.__index = MsgType.GCSyncWebServerInfoRspd

function MsgType.GCSyncWebServerInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSyncWebServerInfoRspd:GetCmd()
    return MsgTypeCmd.GC_SyncWebServerInfoRspd
end
function MsgType.GCSyncWebServerInfoRspd:GetUrl()
    return "GCSyncWebServerInfoRspd"
end
function MsgType.GCSyncWebServerInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.webServerHost = ""
    self.webServerPort = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.webServerHost = tostring(data.c)
    end
    if nil ~= data.d then
        self.webServerPort = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGRegisterAccountRqst = {
    msgSeq = 0,
    account = "",
    pwd = ""
}
MsgType.CGRegisterAccountRqst.__index = MsgType.CGRegisterAccountRqst

function MsgType.CGRegisterAccountRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRegisterAccountRqst:GetCmd()
    return MsgTypeCmd.CG_RegisterAccountRqst
end
function MsgType.CGRegisterAccountRqst:GetUrl()
    return "CGRegisterAccountRqst"
end
function MsgType.CGRegisterAccountRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.c = self.account
    end
    if nil ~= self.pwd and string.len(self.pwd) > 0 then
        tb.d = self.pwd
    end
    return tb
end

function MsgType.CGRegisterAccountRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRegisterAccountRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRegisterAccountRspd = {
    msgSeq = 0,
    account = "",
    pwd = "",
    errorCode = 0
}
MsgType.GCRegisterAccountRspd.__index = MsgType.GCRegisterAccountRspd

function MsgType.GCRegisterAccountRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRegisterAccountRspd:GetCmd()
    return MsgTypeCmd.GC_RegisterAccountRspd
end
function MsgType.GCRegisterAccountRspd:GetUrl()
    return "GCRegisterAccountRspd"
end
function MsgType.GCRegisterAccountRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.pwd = ""
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.pwd = tostring(data.d)
    end
    if nil ~= data.e then
        self.errorCode = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGNoticeRqst = {
    msgSeq = 0,
    nouse = 0,
    protoVersion = 0
}
MsgType.CGNoticeRqst.__index = MsgType.CGNoticeRqst

function MsgType.CGNoticeRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGNoticeRqst:GetCmd()
    return MsgTypeCmd.CG_NoticeRqst
end
function MsgType.CGNoticeRqst:GetUrl()
    return "CGNoticeRqst"
end
function MsgType.CGNoticeRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    if nil ~= self.protoVersion and 0 ~= self.protoVersion then
        tb.d = self.protoVersion
    end
    return tb
end

function MsgType.CGNoticeRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGNoticeRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCNoticeRspd = {
    msgSeq = 0,
    srvTime = 0,
    notice = {},
    previewList = {} -- array of MsgType.PreviewDataInMsg
}
MsgType.GCNoticeRspd.__index = MsgType.GCNoticeRspd
setmetatable(MsgType.GCNoticeRspd.notice, MsgType.NoticeData)

function MsgType.GCNoticeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCNoticeRspd:GetCmd()
    return MsgTypeCmd.GC_NoticeRspd
end
function MsgType.GCNoticeRspd:GetUrl()
    return "GCNoticeRspd"
end
function MsgType.GCNoticeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.srvTime = 0
    self.notice = MsgType.NoticeData:New()
    self.previewList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.srvTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.notice:Decode(data.d)
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpPreviewListObj = MsgType.PreviewDataInMsg:New()
            tmpPreviewListObj:Decode(data.e[i])
            self.previewList[i] = tmpPreviewListObj
        end
    end
    return self
end


MsgType.CGAccountRqst = {
    msgSeq = 0,
    platform = 0, --enum EPlatformType
    deviceID = "",
    account = "",
    pwd = "",
    platformUUID = "",
    platformToken = "",
    clientFlag = 0,
    deviceRegion = "",
    protoVersion = 0
}
MsgType.CGAccountRqst.__index = MsgType.CGAccountRqst

function MsgType.CGAccountRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAccountRqst:GetCmd()
    return MsgTypeCmd.CG_AccountRqst
end
function MsgType.CGAccountRqst:GetUrl()
    return "CGAccountRqst"
end
function MsgType.CGAccountRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.deviceID and string.len(self.deviceID) > 0 then
        tb.d = self.deviceID
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.e = self.account
    end
    if nil ~= self.pwd and string.len(self.pwd) > 0 then
        tb.f = self.pwd
    end
    if nil ~= self.platformUUID and string.len(self.platformUUID) > 0 then
        tb.g = self.platformUUID
    end
    if nil ~= self.platformToken and string.len(self.platformToken) > 0 then
        tb.h = self.platformToken
    end
    if nil ~= self.clientFlag and 0 ~= self.clientFlag then
        tb.i = self.clientFlag
    end
    if nil ~= self.deviceRegion and string.len(self.deviceRegion) > 0 then
        tb.j = self.deviceRegion
    end
    if nil ~= self.protoVersion and 0 ~= self.protoVersion then
        tb.k = self.protoVersion
    end
    return tb
end

function MsgType.CGAccountRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAccountRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAccountRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EAccountChkRst
    platform = 0, --enum EPlatformType
    account = "",
    checkToken = "",
    clientFlag = 0,
    srvTime = 0,
    lastServer = 0,
    serverListFlag = 0,
    serverList = {}, -- array of MsgType.ServerListItem
    systemEnterList = {} -- array of MsgType.SystemEnterConfig
}
MsgType.GCAccountRspd.__index = MsgType.GCAccountRspd

function MsgType.GCAccountRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAccountRspd:GetCmd()
    return MsgTypeCmd.GC_AccountRspd
end
function MsgType.GCAccountRspd:GetUrl()
    return "GCAccountRspd"
end
function MsgType.GCAccountRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.platform = 0
    self.account = ""
    self.checkToken = ""
    self.clientFlag = 0
    self.srvTime = 0
    self.lastServer = 0
    self.serverListFlag = 0
    self.serverList = {}
    self.systemEnterList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.platform = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.account = tostring(data.e)
    end
    if nil ~= data.f then
        self.checkToken = tostring(data.f)
    end
    if nil ~= data.g then
        self.clientFlag = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.srvTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.lastServer = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.serverListFlag = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpServerListObj = MsgType.ServerListItem:New()
            tmpServerListObj:Decode(data.k[i])
            self.serverList[i] = tmpServerListObj
        end
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpSystemEnterListObj = MsgType.SystemEnterConfig:New()
            tmpSystemEnterListObj:Decode(data.l[i])
            self.systemEnterList[i] = tmpSystemEnterListObj
        end
    end
    return self
end


MsgType.CGLoginRqst = {
    msgSeq = 0,
    account = "",
    deviceID = "",
    token = "",
    ip = "",
    roleName = "",
    bindEmail = "",
    bindFbAccount = "",
    bindFbName = "",
    bindGoogleAccount = "",
    bindGoogleName = "",
    bindGameCenterAccount = "",
    bindGameCenterName = "",
    deviceRegion = ""
}
MsgType.CGLoginRqst.__index = MsgType.CGLoginRqst

function MsgType.CGLoginRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLoginRqst:GetCmd()
    return MsgTypeCmd.CG_LoginRqst
end
function MsgType.CGLoginRqst:GetUrl()
    return "CGLoginRqst"
end
function MsgType.CGLoginRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.c = self.account
    end
    if nil ~= self.deviceID and string.len(self.deviceID) > 0 then
        tb.d = self.deviceID
    end
    if nil ~= self.token and string.len(self.token) > 0 then
        tb.e = self.token
    end
    if nil ~= self.ip and string.len(self.ip) > 0 then
        tb.f = self.ip
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.g = self.roleName
    end
    if nil ~= self.bindEmail and string.len(self.bindEmail) > 0 then
        tb.h = self.bindEmail
    end
    if nil ~= self.bindFbAccount and string.len(self.bindFbAccount) > 0 then
        tb.i = self.bindFbAccount
    end
    if nil ~= self.bindFbName and string.len(self.bindFbName) > 0 then
        tb.j = self.bindFbName
    end
    if nil ~= self.bindGoogleAccount and string.len(self.bindGoogleAccount) > 0 then
        tb.k = self.bindGoogleAccount
    end
    if nil ~= self.bindGoogleName and string.len(self.bindGoogleName) > 0 then
        tb.l = self.bindGoogleName
    end
    if nil ~= self.bindGameCenterAccount and string.len(self.bindGameCenterAccount) > 0 then
        tb.m = self.bindGameCenterAccount
    end
    if nil ~= self.bindGameCenterName and string.len(self.bindGameCenterName) > 0 then
        tb.n = self.bindGameCenterName
    end
    if nil ~= self.deviceRegion and string.len(self.deviceRegion) > 0 then
        tb.o = self.deviceRegion
    end
    return tb
end

function MsgType.CGLoginRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLoginRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLoginRspd = {
    msgSeq = 0,
    errorCode = 0,
    currentRoleUID = 0,
    roleList = {} -- array of MsgType.DeviceRoleInfo
}
MsgType.GCLoginRspd.__index = MsgType.GCLoginRspd

function MsgType.GCLoginRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLoginRspd:GetCmd()
    return MsgTypeCmd.GC_LoginRspd
end
function MsgType.GCLoginRspd:GetUrl()
    return "GCLoginRspd"
end
function MsgType.GCLoginRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.currentRoleUID = 0
    self.roleList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.currentRoleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRoleListObj = MsgType.DeviceRoleInfo:New()
            tmpRoleListObj:Decode(data.e[i])
            self.roleList[i] = tmpRoleListObj
        end
    end
    return self
end


MsgType.CGRoleCoverRqst = {
    msgSeq = 0,
    fromRoleUID = 0,
    toRoleUID = 0
}
MsgType.CGRoleCoverRqst.__index = MsgType.CGRoleCoverRqst

function MsgType.CGRoleCoverRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRoleCoverRqst:GetCmd()
    return MsgTypeCmd.CG_RoleCoverRqst
end
function MsgType.CGRoleCoverRqst:GetUrl()
    return "CGRoleCoverRqst"
end
function MsgType.CGRoleCoverRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.fromRoleUID and 0 ~= self.fromRoleUID then
        tb.c = self.fromRoleUID
    end
    if nil ~= self.toRoleUID and 0 ~= self.toRoleUID then
        tb.d = self.toRoleUID
    end
    return tb
end

function MsgType.CGRoleCoverRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRoleCoverRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRoleCoverRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCRoleCoverRspd.__index = MsgType.GCRoleCoverRspd

function MsgType.GCRoleCoverRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRoleCoverRspd:GetCmd()
    return MsgTypeCmd.GC_RoleCoverRspd
end
function MsgType.GCRoleCoverRspd:GetUrl()
    return "GCRoleCoverRspd"
end
function MsgType.GCRoleCoverRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGGetRoleDataRqst = {
    msgSeq = 0,
    dataType = 0
}
MsgType.CGGetRoleDataRqst.__index = MsgType.CGGetRoleDataRqst

function MsgType.CGGetRoleDataRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetRoleDataRqst:GetCmd()
    return MsgTypeCmd.CG_GetRoleDataRqst
end
function MsgType.CGGetRoleDataRqst:GetUrl()
    return "CGGetRoleDataRqst"
end
function MsgType.CGGetRoleDataRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.dataType and 0 ~= self.dataType then
        tb.c = self.dataType
    end
    return tb
end

function MsgType.CGGetRoleDataRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetRoleDataRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGetRoleDataRspd = {
    msgSeq = 0,
    errorCode = 0,
    briefInfo = {},
    equipOnList = {} -- array of number
}
MsgType.GCGetRoleDataRspd.__index = MsgType.GCGetRoleDataRspd
setmetatable(MsgType.GCGetRoleDataRspd.briefInfo, MsgType.RoleBriefInfo)

function MsgType.GCGetRoleDataRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGetRoleDataRspd:GetCmd()
    return MsgTypeCmd.GC_GetRoleDataRspd
end
function MsgType.GCGetRoleDataRspd:GetUrl()
    return "GCGetRoleDataRspd"
end
function MsgType.GCGetRoleDataRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.briefInfo = MsgType.RoleBriefInfo:New()
    self.equipOnList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.briefInfo:Decode(data.d)
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.equipOnList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGGetChainAddressRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGGetChainAddressRqst.__index = MsgType.CGGetChainAddressRqst

function MsgType.CGGetChainAddressRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetChainAddressRqst:GetCmd()
    return MsgTypeCmd.CG_GetChainAddressRqst
end
function MsgType.CGGetChainAddressRqst:GetUrl()
    return "CGGetChainAddressRqst"
end
function MsgType.CGGetChainAddressRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGGetChainAddressRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetChainAddressRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGetChainAddressRspd = {
    msgSeq = 0,
    errorCode = 0,
    rpcHost = "",
    rpcPort = 0,
    rpcUser = "",
    rpcPwd = "",
    contractAddress = "",
    isBind = 0,
    masterKey = "",
    masterKeyName = "",
    pathKey = "",
    rawAddress = "",
    bindAddress = ""
}
MsgType.GCGetChainAddressRspd.__index = MsgType.GCGetChainAddressRspd

function MsgType.GCGetChainAddressRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGetChainAddressRspd:GetCmd()
    return MsgTypeCmd.GC_GetChainAddressRspd
end
function MsgType.GCGetChainAddressRspd:GetUrl()
    return "GCGetChainAddressRspd"
end
function MsgType.GCGetChainAddressRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.rpcHost = ""
    self.rpcPort = 0
    self.rpcUser = ""
    self.rpcPwd = ""
    self.contractAddress = ""
    self.isBind = 0
    self.masterKey = ""
    self.masterKeyName = ""
    self.pathKey = ""
    self.rawAddress = ""
    self.bindAddress = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rpcHost = tostring(data.d)
    end
    if nil ~= data.e then
        self.rpcPort = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rpcUser = tostring(data.f)
    end
    if nil ~= data.g then
        self.rpcPwd = tostring(data.g)
    end
    if nil ~= data.h then
        self.contractAddress = tostring(data.h)
    end
    if nil ~= data.i then
        self.isBind = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.masterKey = tostring(data.j)
    end
    if nil ~= data.k then
        self.masterKeyName = tostring(data.k)
    end
    if nil ~= data.l then
        self.pathKey = tostring(data.l)
    end
    if nil ~= data.m then
        self.rawAddress = tostring(data.m)
    end
    if nil ~= data.n then
        self.bindAddress = tostring(data.n)
    end
    return self
end


MsgType.CGSaveChainAddressRqst = {
    msgSeq = 0,
    masterKey = "",
    masterKeyName = "",
    pathKey = "",
    rawAddress = ""
}
MsgType.CGSaveChainAddressRqst.__index = MsgType.CGSaveChainAddressRqst

function MsgType.CGSaveChainAddressRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSaveChainAddressRqst:GetCmd()
    return MsgTypeCmd.CG_SaveChainAddressRqst
end
function MsgType.CGSaveChainAddressRqst:GetUrl()
    return "CGSaveChainAddressRqst"
end
function MsgType.CGSaveChainAddressRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.masterKey and string.len(self.masterKey) > 0 then
        tb.c = self.masterKey
    end
    if nil ~= self.masterKeyName and string.len(self.masterKeyName) > 0 then
        tb.d = self.masterKeyName
    end
    if nil ~= self.pathKey and string.len(self.pathKey) > 0 then
        tb.e = self.pathKey
    end
    if nil ~= self.rawAddress and string.len(self.rawAddress) > 0 then
        tb.f = self.rawAddress
    end
    return tb
end

function MsgType.CGSaveChainAddressRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSaveChainAddressRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCSaveChainAddressRspd = {
    msgSeq = 0,
    errorCode = 0,
    masterKey = "",
    masterKeyName = "",
    pathKey = "",
    rawAddress = ""
}
MsgType.GCSaveChainAddressRspd.__index = MsgType.GCSaveChainAddressRspd

function MsgType.GCSaveChainAddressRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSaveChainAddressRspd:GetCmd()
    return MsgTypeCmd.GC_SaveChainAddressRspd
end
function MsgType.GCSaveChainAddressRspd:GetUrl()
    return "GCSaveChainAddressRspd"
end
function MsgType.GCSaveChainAddressRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.masterKey = ""
    self.masterKeyName = ""
    self.pathKey = ""
    self.rawAddress = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.masterKey = tostring(data.d)
    end
    if nil ~= data.e then
        self.masterKeyName = tostring(data.e)
    end
    if nil ~= data.f then
        self.pathKey = tostring(data.f)
    end
    if nil ~= data.g then
        self.rawAddress = tostring(data.g)
    end
    return self
end


MsgType.CGKeepAliveRqst = {
    msgSeq = 0,
    pingValue = 0
}
MsgType.CGKeepAliveRqst.__index = MsgType.CGKeepAliveRqst

function MsgType.CGKeepAliveRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGKeepAliveRqst:GetCmd()
    return MsgTypeCmd.CG_KeepAliveRqst
end
function MsgType.CGKeepAliveRqst:GetUrl()
    return "CGKeepAliveRqst"
end
function MsgType.CGKeepAliveRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.pingValue and 0 ~= self.pingValue then
        tb.c = self.pingValue
    end
    return tb
end

function MsgType.CGKeepAliveRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGKeepAliveRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCKeepAliveRspd = {
    msgSeq = 0,
    pingValue = 0
}
MsgType.GCKeepAliveRspd.__index = MsgType.GCKeepAliveRspd

function MsgType.GCKeepAliveRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCKeepAliveRspd:GetCmd()
    return MsgTypeCmd.GC_KeepAliveRspd
end
function MsgType.GCKeepAliveRspd:GetUrl()
    return "GCKeepAliveRspd"
end
function MsgType.GCKeepAliveRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.pingValue = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.pingValue = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGCreateRoleRqst = {
    msgSeq = 0,
    roleName = "",
    roleJob = 0
}
MsgType.CGCreateRoleRqst.__index = MsgType.CGCreateRoleRqst

function MsgType.CGCreateRoleRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCreateRoleRqst:GetCmd()
    return MsgTypeCmd.CG_CreateRoleRqst
end
function MsgType.CGCreateRoleRqst:GetUrl()
    return "CGCreateRoleRqst"
end
function MsgType.CGCreateRoleRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.roleJob and 0 ~= self.roleJob then
        tb.d = self.roleJob
    end
    return tb
end

function MsgType.CGCreateRoleRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCreateRoleRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCreateRoleRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCCreateRoleRspd.__index = MsgType.GCCreateRoleRspd

function MsgType.GCCreateRoleRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCreateRoleRspd:GetCmd()
    return MsgTypeCmd.GC_CreateRoleRspd
end
function MsgType.GCCreateRoleRspd:GetUrl()
    return "GCCreateRoleRspd"
end
function MsgType.GCCreateRoleRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.GCRoleBriefInfoRspd = {
    msgSeq = 0,
    briefInfo = {},
    equipOnList = {} -- array of number
}
MsgType.GCRoleBriefInfoRspd.__index = MsgType.GCRoleBriefInfoRspd
setmetatable(MsgType.GCRoleBriefInfoRspd.briefInfo, MsgType.RoleBriefInfo)

function MsgType.GCRoleBriefInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRoleBriefInfoRspd:GetCmd()
    return MsgTypeCmd.GC_RoleBriefInfoRspd
end
function MsgType.GCRoleBriefInfoRspd:GetUrl()
    return "GCRoleBriefInfoRspd"
end
function MsgType.GCRoleBriefInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.briefInfo = MsgType.RoleBriefInfo:New()
    self.equipOnList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.briefInfo:Decode(data.c)
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.equipOnList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.GCEquipInfoRspd = {
    msgSeq = 0,
    unused = false
}
MsgType.GCEquipInfoRspd.__index = MsgType.GCEquipInfoRspd

function MsgType.GCEquipInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEquipInfoRspd:GetCmd()
    return MsgTypeCmd.GC_EquipInfoRspd
end
function MsgType.GCEquipInfoRspd:GetUrl()
    return "GCEquipInfoRspd"
end
function MsgType.GCEquipInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.unused = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.unused = data.c
    end
    return self
end


MsgType.CGGetItemListRqst = {
    msgSeq = 0,
    unused = false
}
MsgType.CGGetItemListRqst.__index = MsgType.CGGetItemListRqst

function MsgType.CGGetItemListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetItemListRqst:GetCmd()
    return MsgTypeCmd.CG_GetItemListRqst
end
function MsgType.CGGetItemListRqst:GetUrl()
    return "CGGetItemListRqst"
end
function MsgType.CGGetItemListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if self.unused then
        tb.c = self.unused
    end
    return tb
end

function MsgType.CGGetItemListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetItemListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGetItemListRspd = {
    msgSeq = 0,
    bagType = 0, --enum EBagType
    itemList = {}, -- array of MsgType.ItemDataDB
    endFlag = false
}
MsgType.GCGetItemListRspd.__index = MsgType.GCGetItemListRspd

function MsgType.GCGetItemListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGetItemListRspd:GetCmd()
    return MsgTypeCmd.GC_GetItemListRspd
end
function MsgType.GCGetItemListRspd:GetUrl()
    return "GCGetItemListRspd"
end
function MsgType.GCGetItemListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.bagType = 0
    self.itemList = {}
    self.endFlag = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.bagType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpItemListObj = MsgType.ItemDataDB:New()
            tmpItemListObj:Decode(data.d[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.e then
        self.endFlag = data.e
    end
    return self
end


MsgType.CGItemFlagRqst = {
    msgSeq = 0,
    itemType = 0,
    itemTypeList = {} -- array of number
}
MsgType.CGItemFlagRqst.__index = MsgType.CGItemFlagRqst

function MsgType.CGItemFlagRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGItemFlagRqst:GetCmd()
    return MsgTypeCmd.CG_ItemFlagRqst
end
function MsgType.CGItemFlagRqst:GetUrl()
    return "CGItemFlagRqst"
end
function MsgType.CGItemFlagRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.itemTypeList and string.len(self.itemTypeList) > 0 then
        tb.d = self.itemTypeList
    end
    return tb
end

function MsgType.CGItemFlagRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGItemFlagRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCItemFlagRspd = {
    msgSeq = 0,
    itemType = 0,
    itemTypeList = {} -- array of number
}
MsgType.GCItemFlagRspd.__index = MsgType.GCItemFlagRspd

function MsgType.GCItemFlagRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCItemFlagRspd:GetCmd()
    return MsgTypeCmd.GC_ItemFlagRspd
end
function MsgType.GCItemFlagRspd:GetUrl()
    return "GCItemFlagRspd"
end
function MsgType.GCItemFlagRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.itemTypeList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.itemType = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.itemTypeList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGTurntableGetInfoRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGTurntableGetInfoRqst.__index = MsgType.CGTurntableGetInfoRqst

function MsgType.CGTurntableGetInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTurntableGetInfoRqst:GetCmd()
    return MsgTypeCmd.CG_TurntableGetInfoRqst
end
function MsgType.CGTurntableGetInfoRqst:GetUrl()
    return "CGTurntableGetInfoRqst"
end
function MsgType.CGTurntableGetInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGTurntableGetInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTurntableGetInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTurntableGetInfoRspd = {
    msgSeq = 0,
    turntableData = {}
}
MsgType.GCTurntableGetInfoRspd.__index = MsgType.GCTurntableGetInfoRspd
setmetatable(MsgType.GCTurntableGetInfoRspd.turntableData, MsgType.TurntableDataInMsg)

function MsgType.GCTurntableGetInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTurntableGetInfoRspd:GetCmd()
    return MsgTypeCmd.GC_TurntableGetInfoRspd
end
function MsgType.GCTurntableGetInfoRspd:GetUrl()
    return "GCTurntableGetInfoRspd"
end
function MsgType.GCTurntableGetInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.turntableData = MsgType.TurntableDataInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.turntableData:Decode(data.c)
    end
    return self
end


MsgType.CGTurntableOptRqst = {
    msgSeq = 0,
    optType = 0 --enum ETurntableOptType
}
MsgType.CGTurntableOptRqst.__index = MsgType.CGTurntableOptRqst

function MsgType.CGTurntableOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTurntableOptRqst:GetCmd()
    return MsgTypeCmd.CG_TurntableOptRqst
end
function MsgType.CGTurntableOptRqst:GetUrl()
    return "CGTurntableOptRqst"
end
function MsgType.CGTurntableOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    return tb
end

function MsgType.CGTurntableOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTurntableOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTurntableOptRspd = {
    msgSeq = 0,
    optType = 0, --enum ETurntableOptType
    errorCode = 0, --enum ETurntableOptCode
    areaID = 0
}
MsgType.GCTurntableOptRspd.__index = MsgType.GCTurntableOptRspd

function MsgType.GCTurntableOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTurntableOptRspd:GetCmd()
    return MsgTypeCmd.GC_TurntableOptRspd
end
function MsgType.GCTurntableOptRspd:GetUrl()
    return "GCTurntableOptRspd"
end
function MsgType.GCTurntableOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.errorCode = 0
    self.areaID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.optType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.areaID = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGWelfareGetInfoRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGWelfareGetInfoRqst.__index = MsgType.CGWelfareGetInfoRqst

function MsgType.CGWelfareGetInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGWelfareGetInfoRqst:GetCmd()
    return MsgTypeCmd.CG_WelfareGetInfoRqst
end
function MsgType.CGWelfareGetInfoRqst:GetUrl()
    return "CGWelfareGetInfoRqst"
end
function MsgType.CGWelfareGetInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGWelfareGetInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGWelfareGetInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCWelfareGetInfoRspd = {
    msgSeq = 0,
    welfareData = {}
}
MsgType.GCWelfareGetInfoRspd.__index = MsgType.GCWelfareGetInfoRspd
setmetatable(MsgType.GCWelfareGetInfoRspd.welfareData, MsgType.WelfareDataInMsg)

function MsgType.GCWelfareGetInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCWelfareGetInfoRspd:GetCmd()
    return MsgTypeCmd.GC_WelfareGetInfoRspd
end
function MsgType.GCWelfareGetInfoRspd:GetUrl()
    return "GCWelfareGetInfoRspd"
end
function MsgType.GCWelfareGetInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.welfareData = MsgType.WelfareDataInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.welfareData:Decode(data.c)
    end
    return self
end


MsgType.CGWelfareOptRqst = {
    msgSeq = 0,
    activityID = 0
}
MsgType.CGWelfareOptRqst.__index = MsgType.CGWelfareOptRqst

function MsgType.CGWelfareOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGWelfareOptRqst:GetCmd()
    return MsgTypeCmd.CG_WelfareOptRqst
end
function MsgType.CGWelfareOptRqst:GetUrl()
    return "CGWelfareOptRqst"
end
function MsgType.CGWelfareOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.c = self.activityID
    end
    return tb
end

function MsgType.CGWelfareOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGWelfareOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCWelfareOptRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EWelfareOptCode
    activityID = 0
}
MsgType.GCWelfareOptRspd.__index = MsgType.GCWelfareOptRspd

function MsgType.GCWelfareOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCWelfareOptRspd:GetCmd()
    return MsgTypeCmd.GC_WelfareOptRspd
end
function MsgType.GCWelfareOptRspd:GetUrl()
    return "GCWelfareOptRspd"
end
function MsgType.GCWelfareOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.activityID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.activityID = tonumber(data.d) or 0
    end
    return self
end


MsgType.CodeItemInfo = {
    itemType = 0,
    count = 0
}
MsgType.CodeItemInfo.__index = MsgType.CodeItemInfo

function MsgType.CodeItemInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CodeItemInfo:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.CodeItemInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.CodeItemInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGGiftActiveCodeRqst = {
    msgSeq = 0,
    activeCode = ""
}
MsgType.CGGiftActiveCodeRqst.__index = MsgType.CGGiftActiveCodeRqst

function MsgType.CGGiftActiveCodeRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGiftActiveCodeRqst:GetCmd()
    return MsgTypeCmd.CG_GiftActiveCodeRqst
end
function MsgType.CGGiftActiveCodeRqst:GetUrl()
    return "CGGiftActiveCodeRqst"
end
function MsgType.CGGiftActiveCodeRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.activeCode and string.len(self.activeCode) > 0 then
        tb.c = self.activeCode
    end
    return tb
end

function MsgType.CGGiftActiveCodeRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGiftActiveCodeRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCGiftActiveCodeRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EGiftActiveCodeErrorCode
    itemList = {} -- array of MsgType.CodeItemInfo
}
MsgType.GCGiftActiveCodeRspd.__index = MsgType.GCGiftActiveCodeRspd

function MsgType.GCGiftActiveCodeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGiftActiveCodeRspd:GetCmd()
    return MsgTypeCmd.GC_GiftActiveCodeRspd
end
function MsgType.GCGiftActiveCodeRspd:GetUrl()
    return "GCGiftActiveCodeRspd"
end
function MsgType.GCGiftActiveCodeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpItemListObj = MsgType.CodeItemInfo:New()
            tmpItemListObj:Decode(data.d[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.CGCityGetInfoRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGCityGetInfoRqst.__index = MsgType.CGCityGetInfoRqst

function MsgType.CGCityGetInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCityGetInfoRqst:GetCmd()
    return MsgTypeCmd.CG_CityGetInfoRqst
end
function MsgType.CGCityGetInfoRqst:GetUrl()
    return "CGCityGetInfoRqst"
end
function MsgType.CGCityGetInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGCityGetInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCityGetInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCityGetInfoRspd = {
    msgSeq = 0,
    cityData = {}
}
MsgType.GCCityGetInfoRspd.__index = MsgType.GCCityGetInfoRspd
setmetatable(MsgType.GCCityGetInfoRspd.cityData, MsgType.CityDataInMsg)

function MsgType.GCCityGetInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCityGetInfoRspd:GetCmd()
    return MsgTypeCmd.GC_CityGetInfoRspd
end
function MsgType.GCCityGetInfoRspd:GetUrl()
    return "GCCityGetInfoRspd"
end
function MsgType.GCCityGetInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.cityData = MsgType.CityDataInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.cityData:Decode(data.c)
    end
    return self
end


MsgType.CGCityOptRqst = {
    msgSeq = 0,
    optType = 0, --enum ECityOptType
    cityID = 0
}
MsgType.CGCityOptRqst.__index = MsgType.CGCityOptRqst

function MsgType.CGCityOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCityOptRqst:GetCmd()
    return MsgTypeCmd.CG_CityOptRqst
end
function MsgType.CGCityOptRqst:GetUrl()
    return "CGCityOptRqst"
end
function MsgType.CGCityOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    if nil ~= self.cityID and 0 ~= self.cityID then
        tb.d = self.cityID
    end
    return tb
end

function MsgType.CGCityOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCityOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCityOptRspd = {
    msgSeq = 0,
    optType = 0, --enum ECityOptType
    cityID = 0,
    errorCode = 0 --enum ECityOptCode
}
MsgType.GCCityOptRspd.__index = MsgType.GCCityOptRspd

function MsgType.GCCityOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCityOptRspd:GetCmd()
    return MsgTypeCmd.GC_CityOptRspd
end
function MsgType.GCCityOptRspd:GetUrl()
    return "GCCityOptRspd"
end
function MsgType.GCCityOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.cityID = 0
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.optType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.cityID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.errorCode = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGModifyDogNameRqst = {
    msgSeq = 0,
    dogName = ""
}
MsgType.CGModifyDogNameRqst.__index = MsgType.CGModifyDogNameRqst

function MsgType.CGModifyDogNameRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGModifyDogNameRqst:GetCmd()
    return MsgTypeCmd.CG_ModifyDogNameRqst
end
function MsgType.CGModifyDogNameRqst:GetUrl()
    return "CGModifyDogNameRqst"
end
function MsgType.CGModifyDogNameRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.dogName and string.len(self.dogName) > 0 then
        tb.c = self.dogName
    end
    return tb
end

function MsgType.CGModifyDogNameRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGModifyDogNameRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCModifyDogNameRspd = {
    msgSeq = 0,
    errorCode = 0,
    dogName = ""
}
MsgType.GCModifyDogNameRspd.__index = MsgType.GCModifyDogNameRspd

function MsgType.GCModifyDogNameRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCModifyDogNameRspd:GetCmd()
    return MsgTypeCmd.GC_ModifyDogNameRspd
end
function MsgType.GCModifyDogNameRspd:GetUrl()
    return "GCModifyDogNameRspd"
end
function MsgType.GCModifyDogNameRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.dogName = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.dogName = tostring(data.d)
    end
    return self
end


MsgType.CGChatRqst = {
    msgSeq = 0,
    chatType = 0, --enum EChatType
    chatCont = "",
    targetRoleUID = 0,
    targetRoleName = ""
}
MsgType.CGChatRqst.__index = MsgType.CGChatRqst

function MsgType.CGChatRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGChatRqst:GetCmd()
    return MsgTypeCmd.CG_ChatRqst
end
function MsgType.CGChatRqst:GetUrl()
    return "CGChatRqst"
end
function MsgType.CGChatRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chatType and 0 ~= self.chatType then
        tb.c = self.chatType
    end
    if nil ~= self.chatCont and string.len(self.chatCont) > 0 then
        tb.d = self.chatCont
    end
    if nil ~= self.targetRoleUID and 0 ~= self.targetRoleUID then
        tb.e = self.targetRoleUID
    end
    if nil ~= self.targetRoleName and string.len(self.targetRoleName) > 0 then
        tb.f = self.targetRoleName
    end
    return tb
end

function MsgType.CGChatRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGChatRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCChatRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EChatErrorCode
    chatType = 0, --enum EChatType
    chatCont = ""
}
MsgType.GCChatRspd.__index = MsgType.GCChatRspd

function MsgType.GCChatRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCChatRspd:GetCmd()
    return MsgTypeCmd.GC_ChatRspd
end
function MsgType.GCChatRspd:GetUrl()
    return "GCChatRspd"
end
function MsgType.GCChatRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.chatType = 0
    self.chatCont = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.chatType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.chatCont = tostring(data.e)
    end
    return self
end


MsgType.GCChatSrvInfoRspd = {
    msgSeq = 0,
    chatSrvHost = "",
    chatSrvPort = 0,
    token = "",
    webServerID = 0
}
MsgType.GCChatSrvInfoRspd.__index = MsgType.GCChatSrvInfoRspd

function MsgType.GCChatSrvInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCChatSrvInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ChatSrvInfoRspd
end
function MsgType.GCChatSrvInfoRspd:GetUrl()
    return "GCChatSrvInfoRspd"
end
function MsgType.GCChatSrvInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.chatSrvHost = ""
    self.chatSrvPort = 0
    self.token = ""
    self.webServerID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.chatSrvHost = tostring(data.c)
    end
    if nil ~= data.d then
        self.chatSrvPort = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.token = tostring(data.e)
    end
    if nil ~= data.f then
        self.webServerID = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGChatChannelInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGChatChannelInfoRqst.__index = MsgType.CGChatChannelInfoRqst

function MsgType.CGChatChannelInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGChatChannelInfoRqst:GetCmd()
    return MsgTypeCmd.CG_ChatChannelInfoRqst
end
function MsgType.CGChatChannelInfoRqst:GetUrl()
    return "CGChatChannelInfoRqst"
end
function MsgType.CGChatChannelInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGChatChannelInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGChatChannelInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCChatChannelInfoRspd = {
    msgSeq = 0,
    channel = 0,
    lastChannel = 0,
    channelList = {} -- array of MsgType.ChatChannelInfo
}
MsgType.GCChatChannelInfoRspd.__index = MsgType.GCChatChannelInfoRspd

function MsgType.GCChatChannelInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCChatChannelInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ChatChannelInfoRspd
end
function MsgType.GCChatChannelInfoRspd:GetUrl()
    return "GCChatChannelInfoRspd"
end
function MsgType.GCChatChannelInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.channel = 0
    self.lastChannel = 0
    self.channelList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.channel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastChannel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpChannelListObj = MsgType.ChatChannelInfo:New()
            tmpChannelListObj:Decode(data.e[i])
            self.channelList[i] = tmpChannelListObj
        end
    end
    return self
end


MsgType.CGChatChgChannelRqst = {
    msgSeq = 0,
    channel = 0
}
MsgType.CGChatChgChannelRqst.__index = MsgType.CGChatChgChannelRqst

function MsgType.CGChatChgChannelRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGChatChgChannelRqst:GetCmd()
    return MsgTypeCmd.CG_ChatChgChannelRqst
end
function MsgType.CGChatChgChannelRqst:GetUrl()
    return "CGChatChgChannelRqst"
end
function MsgType.CGChatChgChannelRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.channel and 0 ~= self.channel then
        tb.c = self.channel
    end
    return tb
end

function MsgType.CGChatChgChannelRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGChatChgChannelRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCChatChgChannelRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EChatErrorCode
    channel = 0
}
MsgType.GCChatChgChannelRspd.__index = MsgType.GCChatChgChannelRspd

function MsgType.GCChatChgChannelRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCChatChgChannelRspd:GetCmd()
    return MsgTypeCmd.GC_ChatChgChannelRspd
end
function MsgType.GCChatChgChannelRspd:GetUrl()
    return "GCChatChgChannelRspd"
end
function MsgType.GCChatChgChannelRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.channel = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.channel = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGDanceBallGetBallListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGDanceBallGetBallListRqst.__index = MsgType.CGDanceBallGetBallListRqst

function MsgType.CGDanceBallGetBallListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGDanceBallGetBallListRqst:GetCmd()
    return MsgTypeCmd.CG_DanceBallGetBallListRqst
end
function MsgType.CGDanceBallGetBallListRqst:GetUrl()
    return "CGDanceBallGetBallListRqst"
end
function MsgType.CGDanceBallGetBallListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGDanceBallGetBallListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGDanceBallGetBallListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCDanceBallGetBallListRspd = {
    msgSeq = 0,
    roleBallInfo = {},
    ballList = {} -- array of MsgType.DanceBallInMsg
}
MsgType.GCDanceBallGetBallListRspd.__index = MsgType.GCDanceBallGetBallListRspd
setmetatable(MsgType.GCDanceBallGetBallListRspd.roleBallInfo, MsgType.RoleDanceBallInfoInMsg)

function MsgType.GCDanceBallGetBallListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCDanceBallGetBallListRspd:GetCmd()
    return MsgTypeCmd.GC_DanceBallGetBallListRspd
end
function MsgType.GCDanceBallGetBallListRspd:GetUrl()
    return "GCDanceBallGetBallListRspd"
end
function MsgType.GCDanceBallGetBallListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleBallInfo = MsgType.RoleDanceBallInfoInMsg:New()
    self.ballList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.roleBallInfo:Decode(data.c)
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpBallListObj = MsgType.DanceBallInMsg:New()
            tmpBallListObj:Decode(data.d[i])
            self.ballList[i] = tmpBallListObj
        end
    end
    return self
end


MsgType.CGDanceBallGetServerInfoRqst = {
    msgSeq = 0,
    reason = 0 --enum EDanceBallGetServerReason
}
MsgType.CGDanceBallGetServerInfoRqst.__index = MsgType.CGDanceBallGetServerInfoRqst

function MsgType.CGDanceBallGetServerInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGDanceBallGetServerInfoRqst:GetCmd()
    return MsgTypeCmd.CG_DanceBallGetServerInfoRqst
end
function MsgType.CGDanceBallGetServerInfoRqst:GetUrl()
    return "CGDanceBallGetServerInfoRqst"
end
function MsgType.CGDanceBallGetServerInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.reason and 0 ~= self.reason then
        tb.c = self.reason
    end
    return tb
end

function MsgType.CGDanceBallGetServerInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGDanceBallGetServerInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCDanceBallGetServerInfoRspd = {
    msgSeq = 0,
    mapServerHost = "",
    mapServerPort = 0,
    token = ""
}
MsgType.GCDanceBallGetServerInfoRspd.__index = MsgType.GCDanceBallGetServerInfoRspd

function MsgType.GCDanceBallGetServerInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCDanceBallGetServerInfoRspd:GetCmd()
    return MsgTypeCmd.GC_DanceBallGetServerInfoRspd
end
function MsgType.GCDanceBallGetServerInfoRspd:GetUrl()
    return "GCDanceBallGetServerInfoRspd"
end
function MsgType.GCDanceBallGetServerInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.mapServerHost = ""
    self.mapServerPort = 0
    self.token = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.mapServerHost = tostring(data.c)
    end
    if nil ~= data.d then
        self.mapServerPort = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.token = tostring(data.e)
    end
    return self
end


MsgType.CGPeekPlayerInfoRqst = {
    msgSeq = 0,
    roleUID = 0
}
MsgType.CGPeekPlayerInfoRqst.__index = MsgType.CGPeekPlayerInfoRqst

function MsgType.CGPeekPlayerInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPeekPlayerInfoRqst:GetCmd()
    return MsgTypeCmd.CG_PeekPlayerInfoRqst
end
function MsgType.CGPeekPlayerInfoRqst:GetUrl()
    return "CGPeekPlayerInfoRqst"
end
function MsgType.CGPeekPlayerInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.c = self.roleUID
    end
    return tb
end

function MsgType.CGPeekPlayerInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPeekPlayerInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPeekPlayerInfoRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EPeekPlayerInfoCode
    roleUID = 0,
    roleName = "",
    roleLevel = 0,
    danceCompany = "",
    equipCollect = 0,
    musicCollect = 0,
    danceCollect = 0,
    petCollect = 0,
    totalLevelCount = 0,
    portraitID = 0
}
MsgType.GCPeekPlayerInfoRspd.__index = MsgType.GCPeekPlayerInfoRspd

function MsgType.GCPeekPlayerInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPeekPlayerInfoRspd:GetCmd()
    return MsgTypeCmd.GC_PeekPlayerInfoRspd
end
function MsgType.GCPeekPlayerInfoRspd:GetUrl()
    return "GCPeekPlayerInfoRspd"
end
function MsgType.GCPeekPlayerInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.roleUID = 0
    self.roleName = ""
    self.roleLevel = 0
    self.danceCompany = ""
    self.equipCollect = 0
    self.musicCollect = 0
    self.danceCollect = 0
    self.petCollect = 0
    self.totalLevelCount = 0
    self.portraitID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.roleName = tostring(data.e)
    end
    if nil ~= data.f then
        self.roleLevel = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.danceCompany = tostring(data.g)
    end
    if nil ~= data.h then
        self.equipCollect = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.musicCollect = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.danceCollect = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.petCollect = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.totalLevelCount = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.portraitID = tonumber(data.m) or 0
    end
    return self
end


MsgType.GCDisplayItemListRspd = {
    msgSeq = 0,
    itemList = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCDisplayItemListRspd.__index = MsgType.GCDisplayItemListRspd

function MsgType.GCDisplayItemListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCDisplayItemListRspd:GetCmd()
    return MsgTypeCmd.GC_DisplayItemListRspd
end
function MsgType.GCDisplayItemListRspd:GetUrl()
    return "GCDisplayItemListRspd"
end
function MsgType.GCDisplayItemListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpItemListObj = MsgType.ItemDisplayerInfo:New()
            tmpItemListObj:Decode(data.c[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.GCUpdateItemInfoRspd = {
    msgSeq = 0,
    bagType = 0, --enum EBagType
    itemData = {}
}
MsgType.GCUpdateItemInfoRspd.__index = MsgType.GCUpdateItemInfoRspd
setmetatable(MsgType.GCUpdateItemInfoRspd.itemData, MsgType.ItemDataDB)

function MsgType.GCUpdateItemInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUpdateItemInfoRspd:GetCmd()
    return MsgTypeCmd.GC_UpdateItemInfoRspd
end
function MsgType.GCUpdateItemInfoRspd:GetUrl()
    return "GCUpdateItemInfoRspd"
end
function MsgType.GCUpdateItemInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.bagType = 0
    self.itemData = MsgType.ItemDataDB:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.bagType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemData:Decode(data.d)
    end
    return self
end


MsgType.CGMoveItemRqst = {
    msgSeq = 0,
    srcBagType = 0, --enum EBagType
    srcParam = 0,
    destBagType = 0, --enum EBagType
    destParam = 0
}
MsgType.CGMoveItemRqst.__index = MsgType.CGMoveItemRqst

function MsgType.CGMoveItemRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGMoveItemRqst:GetCmd()
    return MsgTypeCmd.CG_MoveItemRqst
end
function MsgType.CGMoveItemRqst:GetUrl()
    return "CGMoveItemRqst"
end
function MsgType.CGMoveItemRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.srcBagType and 0 ~= self.srcBagType then
        tb.c = self.srcBagType
    end
    if nil ~= self.srcParam and 0 ~= self.srcParam then
        tb.d = self.srcParam
    end
    if nil ~= self.destBagType and 0 ~= self.destBagType then
        tb.e = self.destBagType
    end
    if nil ~= self.destParam and 0 ~= self.destParam then
        tb.f = self.destParam
    end
    return tb
end

function MsgType.CGMoveItemRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGMoveItemRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCMoveItemRspd = {
    msgSeq = 0,
    srcBagType = 0, --enum EBagType
    srcParam = 0,
    destBagType = 0, --enum EBagType
    destParam = 0,
    rstCode = 0 --enum EItemOptCode
}
MsgType.GCMoveItemRspd.__index = MsgType.GCMoveItemRspd

function MsgType.GCMoveItemRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMoveItemRspd:GetCmd()
    return MsgTypeCmd.GC_MoveItemRspd
end
function MsgType.GCMoveItemRspd:GetUrl()
    return "GCMoveItemRspd"
end
function MsgType.GCMoveItemRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.srcBagType = 0
    self.srcParam = 0
    self.destBagType = 0
    self.destParam = 0
    self.rstCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.srcBagType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.srcParam = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.destBagType = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.destParam = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rstCode = tonumber(data.g) or 0
    end
    return self
end


MsgType.GCObjEventChangeRspd = {
    msgSeq = 0,
    eventType = 0, --enum EObjEvent
    chgVal = 0,
    originVal = 0,
    reason = 0
}
MsgType.GCObjEventChangeRspd.__index = MsgType.GCObjEventChangeRspd

function MsgType.GCObjEventChangeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCObjEventChangeRspd:GetCmd()
    return MsgTypeCmd.GC_ObjEventChangeRspd
end
function MsgType.GCObjEventChangeRspd:GetUrl()
    return "GCObjEventChangeRspd"
end
function MsgType.GCObjEventChangeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventType = 0
    self.chgVal = 0
    self.originVal = 0
    self.reason = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.eventType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.chgVal = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.originVal = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.reason = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGSaveMirrorSchemeRqst = {
    msgSeq = 0,
    itemList = {}, -- array of number
    clientFlag = 0
}
MsgType.CGSaveMirrorSchemeRqst.__index = MsgType.CGSaveMirrorSchemeRqst

function MsgType.CGSaveMirrorSchemeRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSaveMirrorSchemeRqst:GetCmd()
    return MsgTypeCmd.CG_SaveMirrorSchemeRqst
end
function MsgType.CGSaveMirrorSchemeRqst:GetUrl()
    return "CGSaveMirrorSchemeRqst"
end
function MsgType.CGSaveMirrorSchemeRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemList and string.len(self.itemList) > 0 then
        tb.c = self.itemList
    end
    if nil ~= self.clientFlag and 0 ~= self.clientFlag then
        tb.d = self.clientFlag
    end
    return tb
end

function MsgType.CGSaveMirrorSchemeRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSaveMirrorSchemeRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCSaveMirrorSchemeRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EItemOptCode
    clientFlag = 0
}
MsgType.GCSaveMirrorSchemeRspd.__index = MsgType.GCSaveMirrorSchemeRspd

function MsgType.GCSaveMirrorSchemeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSaveMirrorSchemeRspd:GetCmd()
    return MsgTypeCmd.GC_SaveMirrorSchemeRspd
end
function MsgType.GCSaveMirrorSchemeRspd:GetUrl()
    return "GCSaveMirrorSchemeRspd"
end
function MsgType.GCSaveMirrorSchemeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.clientFlag = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.clientFlag = tonumber(data.d) or 0
    end
    return self
end


MsgType.GCMirrorSchemeInfoRspd = {
    msgSeq = 0,
    itemList = {} -- array of number
}
MsgType.GCMirrorSchemeInfoRspd.__index = MsgType.GCMirrorSchemeInfoRspd

function MsgType.GCMirrorSchemeInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCMirrorSchemeInfoRspd:GetCmd()
    return MsgTypeCmd.GC_MirrorSchemeInfoRspd
end
function MsgType.GCMirrorSchemeInfoRspd:GetUrl()
    return "GCMirrorSchemeInfoRspd"
end
function MsgType.GCMirrorSchemeInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.itemList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.GCEquipOnsRspd = {
    msgSeq = 0,
    itemList = {} -- array of number
}
MsgType.GCEquipOnsRspd.__index = MsgType.GCEquipOnsRspd

function MsgType.GCEquipOnsRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEquipOnsRspd:GetCmd()
    return MsgTypeCmd.GC_EquipOnsRspd
end
function MsgType.GCEquipOnsRspd:GetUrl()
    return "GCEquipOnsRspd"
end
function MsgType.GCEquipOnsRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.itemList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.GCSingleCopyEquipPropertyRspd = {
    msgSeq = 0,
    equipProperty = {}, -- array of number
    basePropertyScore = {} -- array of number
}
MsgType.GCSingleCopyEquipPropertyRspd.__index = MsgType.GCSingleCopyEquipPropertyRspd

function MsgType.GCSingleCopyEquipPropertyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSingleCopyEquipPropertyRspd:GetCmd()
    return MsgTypeCmd.GC_SingleCopyEquipPropertyRspd
end
function MsgType.GCSingleCopyEquipPropertyRspd:GetUrl()
    return "GCSingleCopyEquipPropertyRspd"
end
function MsgType.GCSingleCopyEquipPropertyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.equipProperty = {}
    self.basePropertyScore = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.equipProperty[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.basePropertyScore[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGCalcScoreSingleCopyRqst = {
    msgSeq = 0,
    levelid = 0,
    enterType = 0, --enum EMapEnterType
    singleCopyCalcType = 0, --enum ESingleCopyCalcType
    resultInfo = {},
    offlineFlag = 0,
    difficultyScore = 0,
    curSeed = 0,
    isAdEnd = 0,
    chkData = {}
}
MsgType.CGCalcScoreSingleCopyRqst.__index = MsgType.CGCalcScoreSingleCopyRqst
setmetatable(MsgType.CGCalcScoreSingleCopyRqst.resultInfo, MsgType.SingleCopyResultInfo)
setmetatable(MsgType.CGCalcScoreSingleCopyRqst.chkData, MsgType.LevelCheckData)

function MsgType.CGCalcScoreSingleCopyRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCalcScoreSingleCopyRqst:GetCmd()
    return MsgTypeCmd.CG_CalcScoreSingleCopyRqst
end
function MsgType.CGCalcScoreSingleCopyRqst:GetUrl()
    return "CGCalcScoreSingleCopyRqst"
end
function MsgType.CGCalcScoreSingleCopyRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.c = self.levelid
    end
    if nil ~= self.enterType and 0 ~= self.enterType then
        tb.d = self.enterType
    end
    if nil ~= self.singleCopyCalcType and 0 ~= self.singleCopyCalcType then
        tb.e = self.singleCopyCalcType
    end
    tb.f = self.resultInfo:Encode()
    if nil ~= self.offlineFlag and 0 ~= self.offlineFlag then
        tb.g = self.offlineFlag
    end
    if nil ~= self.difficultyScore and 0 ~= self.difficultyScore then
        tb.h = self.difficultyScore
    end
    if nil ~= self.curSeed and 0 ~= self.curSeed then
        tb.i = self.curSeed
    end
    if nil ~= self.isAdEnd and 0 ~= self.isAdEnd then
        tb.j = self.isAdEnd
    end
    tb.k = self.chkData:Encode()
    return tb
end

function MsgType.CGCalcScoreSingleCopyRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCalcScoreSingleCopyRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCalcScoreSingleCopyRspd = {
    msgSeq = 0,
    levelid = 0,
    errorCode = 0, --enum ECopyTeamOptCode
    finalScore = 0,
    gold = 0
}
MsgType.GCCalcScoreSingleCopyRspd.__index = MsgType.GCCalcScoreSingleCopyRspd

function MsgType.GCCalcScoreSingleCopyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCalcScoreSingleCopyRspd:GetCmd()
    return MsgTypeCmd.GC_CalcScoreSingleCopyRspd
end
function MsgType.GCCalcScoreSingleCopyRspd:GetUrl()
    return "GCCalcScoreSingleCopyRspd"
end
function MsgType.GCCalcScoreSingleCopyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelid = 0
    self.errorCode = 0
    self.finalScore = 0
    self.gold = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.levelid = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.finalScore = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.gold = tonumber(data.f) or 0
    end
    return self
end


MsgType.GCPlayerLevelupRspd = {
    msgSeq = 0,
    curLevel = 0
}
MsgType.GCPlayerLevelupRspd.__index = MsgType.GCPlayerLevelupRspd

function MsgType.GCPlayerLevelupRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPlayerLevelupRspd:GetCmd()
    return MsgTypeCmd.GC_PlayerLevelupRspd
end
function MsgType.GCPlayerLevelupRspd:GetUrl()
    return "GCPlayerLevelupRspd"
end
function MsgType.GCPlayerLevelupRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curLevel = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.curLevel = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGModifyRoleNameRqst = {
    msgSeq = 0,
    roleName = ""
}
MsgType.CGModifyRoleNameRqst.__index = MsgType.CGModifyRoleNameRqst

function MsgType.CGModifyRoleNameRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGModifyRoleNameRqst:GetCmd()
    return MsgTypeCmd.CG_ModifyRoleNameRqst
end
function MsgType.CGModifyRoleNameRqst:GetUrl()
    return "CGModifyRoleNameRqst"
end
function MsgType.CGModifyRoleNameRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    return tb
end

function MsgType.CGModifyRoleNameRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGModifyRoleNameRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCModifyRoleNameRspd = {
    msgSeq = 0,
    errorCode = 0,
    roleName = ""
}
MsgType.GCModifyRoleNameRspd.__index = MsgType.GCModifyRoleNameRspd

function MsgType.GCModifyRoleNameRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCModifyRoleNameRspd:GetCmd()
    return MsgTypeCmd.GC_ModifyRoleNameRspd
end
function MsgType.GCModifyRoleNameRspd:GetUrl()
    return "GCModifyRoleNameRspd"
end
function MsgType.GCModifyRoleNameRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.roleName = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleName = tostring(data.d)
    end
    return self
end


MsgType.CGSetPortraitRqst = {
    msgSeq = 0,
    portraitID = 0
}
MsgType.CGSetPortraitRqst.__index = MsgType.CGSetPortraitRqst

function MsgType.CGSetPortraitRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSetPortraitRqst:GetCmd()
    return MsgTypeCmd.CG_SetPortraitRqst
end
function MsgType.CGSetPortraitRqst:GetUrl()
    return "CGSetPortraitRqst"
end
function MsgType.CGSetPortraitRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.c = self.portraitID
    end
    return tb
end

function MsgType.CGSetPortraitRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSetPortraitRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCSetPortraitRspd = {
    msgSeq = 0,
    errorCode = 0,
    portraitID = 0
}
MsgType.GCSetPortraitRspd.__index = MsgType.GCSetPortraitRspd

function MsgType.GCSetPortraitRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSetPortraitRspd:GetCmd()
    return MsgTypeCmd.GC_SetPortraitRspd
end
function MsgType.GCSetPortraitRspd:GetUrl()
    return "GCSetPortraitRspd"
end
function MsgType.GCSetPortraitRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.portraitID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.portraitID = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGOperateBackgroundRqst = {
    msgSeq = 0,
    optType = 0, --enum EBackgroundOptType
    optBackgroundID = 0
}
MsgType.CGOperateBackgroundRqst.__index = MsgType.CGOperateBackgroundRqst

function MsgType.CGOperateBackgroundRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGOperateBackgroundRqst:GetCmd()
    return MsgTypeCmd.CG_OperateBackgroundRqst
end
function MsgType.CGOperateBackgroundRqst:GetUrl()
    return "CGOperateBackgroundRqst"
end
function MsgType.CGOperateBackgroundRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    if nil ~= self.optBackgroundID and 0 ~= self.optBackgroundID then
        tb.d = self.optBackgroundID
    end
    return tb
end

function MsgType.CGOperateBackgroundRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGOperateBackgroundRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCOperateBackgroundRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EBackgroundOptCode
    optType = 0, --enum EBackgroundOptType
    optBackgroundID = 0,
    backgroundList = {} -- array of number
}
MsgType.GCOperateBackgroundRspd.__index = MsgType.GCOperateBackgroundRspd

function MsgType.GCOperateBackgroundRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCOperateBackgroundRspd:GetCmd()
    return MsgTypeCmd.GC_OperateBackgroundRspd
end
function MsgType.GCOperateBackgroundRspd:GetUrl()
    return "GCOperateBackgroundRspd"
end
function MsgType.GCOperateBackgroundRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.optType = 0
    self.optBackgroundID = 0
    self.backgroundList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.optType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optBackgroundID = tonumber(data.e) or 0
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.backgroundList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGSynchInfoRqst = {
    msgSeq = 0,
    unused = 0
}
MsgType.CGSynchInfoRqst.__index = MsgType.CGSynchInfoRqst

function MsgType.CGSynchInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSynchInfoRqst:GetCmd()
    return MsgTypeCmd.CG_SynchInfoRqst
end
function MsgType.CGSynchInfoRqst:GetUrl()
    return "CGSynchInfoRqst"
end
function MsgType.CGSynchInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unused and 0 ~= self.unused then
        tb.c = self.unused
    end
    return tb
end

function MsgType.CGSynchInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSynchInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.CGCommonBuyRqst = {
    msgSeq = 0,
    itemType = 0,
    count = 0,
    levelID = 0
}
MsgType.CGCommonBuyRqst.__index = MsgType.CGCommonBuyRqst

function MsgType.CGCommonBuyRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCommonBuyRqst:GetCmd()
    return MsgTypeCmd.CG_CommonBuyRqst
end
function MsgType.CGCommonBuyRqst:GetUrl()
    return "CGCommonBuyRqst"
end
function MsgType.CGCommonBuyRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.d = self.count
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.e = self.levelID
    end
    return tb
end

function MsgType.CGCommonBuyRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCommonBuyRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCommonBuyRspd = {
    msgSeq = 0,
    errorCode = 0,
    itemType = 0,
    count = 0
}
MsgType.GCCommonBuyRspd.__index = MsgType.GCCommonBuyRspd

function MsgType.GCCommonBuyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCommonBuyRspd:GetCmd()
    return MsgTypeCmd.GC_CommonBuyRspd
end
function MsgType.GCCommonBuyRspd:GetUrl()
    return "GCCommonBuyRspd"
end
function MsgType.GCCommonBuyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.itemType = 0
    self.count = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.count = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGActionPointInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGActionPointInfoRqst.__index = MsgType.CGActionPointInfoRqst

function MsgType.CGActionPointInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActionPointInfoRqst:GetCmd()
    return MsgTypeCmd.CG_ActionPointInfoRqst
end
function MsgType.CGActionPointInfoRqst:GetUrl()
    return "CGActionPointInfoRqst"
end
function MsgType.CGActionPointInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGActionPointInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActionPointInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActionPointInfoRspd = {
    msgSeq = 0,
    actionPointdata = {},
    ugcActionPointData = {}
}
MsgType.GCActionPointInfoRspd.__index = MsgType.GCActionPointInfoRspd
setmetatable(MsgType.GCActionPointInfoRspd.actionPointdata, MsgType.ActionPointDataClient)
setmetatable(MsgType.GCActionPointInfoRspd.ugcActionPointData, MsgType.ActionPointDataClient)

function MsgType.GCActionPointInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActionPointInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ActionPointInfoRspd
end
function MsgType.GCActionPointInfoRspd:GetUrl()
    return "GCActionPointInfoRspd"
end
function MsgType.GCActionPointInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.actionPointdata = MsgType.ActionPointDataClient:New()
    self.ugcActionPointData = MsgType.ActionPointDataClient:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.actionPointdata:Decode(data.c)
    end
    if nil ~= data.d then
        self.ugcActionPointData:Decode(data.d)
    end
    return self
end


MsgType.CGSpecialBuyRqst = {
    msgSeq = 0,
    specialType = 0, --enum ESpecialBuyType
    specialOption = 0,
    levelID = 0
}
MsgType.CGSpecialBuyRqst.__index = MsgType.CGSpecialBuyRqst

function MsgType.CGSpecialBuyRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGSpecialBuyRqst:GetCmd()
    return MsgTypeCmd.CG_SpecialBuyRqst
end
function MsgType.CGSpecialBuyRqst:GetUrl()
    return "CGSpecialBuyRqst"
end
function MsgType.CGSpecialBuyRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.specialType and 0 ~= self.specialType then
        tb.c = self.specialType
    end
    if nil ~= self.specialOption and 0 ~= self.specialOption then
        tb.d = self.specialOption
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.e = self.levelID
    end
    return tb
end

function MsgType.CGSpecialBuyRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGSpecialBuyRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCSpecialBuyRspd = {
    msgSeq = 0,
    specialType = 0, --enum ESpecialBuyType
    specialOption = 0,
    errorCode = 0,
    levelID = 0,
    addStep = 0
}
MsgType.GCSpecialBuyRspd.__index = MsgType.GCSpecialBuyRspd

function MsgType.GCSpecialBuyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCSpecialBuyRspd:GetCmd()
    return MsgTypeCmd.GC_SpecialBuyRspd
end
function MsgType.GCSpecialBuyRspd:GetUrl()
    return "GCSpecialBuyRspd"
end
function MsgType.GCSpecialBuyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.specialType = 0
    self.specialOption = 0
    self.errorCode = 0
    self.levelID = 0
    self.addStep = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.specialType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.specialOption = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.errorCode = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.levelID = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.addStep = tonumber(data.g) or 0
    end
    return self
end


MsgType.GCGoldenHandInfoRspd = {
    msgSeq = 0,
    goldenHandData = {}
}
MsgType.GCGoldenHandInfoRspd.__index = MsgType.GCGoldenHandInfoRspd
setmetatable(MsgType.GCGoldenHandInfoRspd.goldenHandData, MsgType.GoldenHandData)

function MsgType.GCGoldenHandInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCGoldenHandInfoRspd:GetCmd()
    return MsgTypeCmd.GC_GoldenHandInfoRspd
end
function MsgType.GCGoldenHandInfoRspd:GetUrl()
    return "GCGoldenHandInfoRspd"
end
function MsgType.GCGoldenHandInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.goldenHandData = MsgType.GoldenHandData:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.goldenHandData:Decode(data.c)
    end
    return self
end


MsgType.CGNewFeedbackRqst = {
    msgSeq = 0,
    feedbackData = {}
}
MsgType.CGNewFeedbackRqst.__index = MsgType.CGNewFeedbackRqst
setmetatable(MsgType.CGNewFeedbackRqst.feedbackData, MsgType.FeedbackDataInMsg)

function MsgType.CGNewFeedbackRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGNewFeedbackRqst:GetCmd()
    return MsgTypeCmd.CG_NewFeedbackRqst
end
function MsgType.CGNewFeedbackRqst:GetUrl()
    return "CGNewFeedbackRqst"
end
function MsgType.CGNewFeedbackRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self.feedbackData:Encode()
    return tb
end

function MsgType.CGNewFeedbackRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGNewFeedbackRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCNewFeedbackRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCNewFeedbackRspd.__index = MsgType.GCNewFeedbackRspd

function MsgType.GCNewFeedbackRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCNewFeedbackRspd:GetCmd()
    return MsgTypeCmd.GC_NewFeedbackRspd
end
function MsgType.GCNewFeedbackRspd:GetUrl()
    return "GCNewFeedbackRspd"
end
function MsgType.GCNewFeedbackRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGReformEquipRqst = {
    msgSeq = 0,
    reformType = 0, --enum EEquipReformType
    designId = 0,
    repeatNums = 0
}
MsgType.CGReformEquipRqst.__index = MsgType.CGReformEquipRqst

function MsgType.CGReformEquipRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGReformEquipRqst:GetCmd()
    return MsgTypeCmd.CG_ReformEquipRqst
end
function MsgType.CGReformEquipRqst:GetUrl()
    return "CGReformEquipRqst"
end
function MsgType.CGReformEquipRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.reformType and 0 ~= self.reformType then
        tb.c = self.reformType
    end
    if nil ~= self.designId and 0 ~= self.designId then
        tb.d = self.designId
    end
    if nil ~= self.repeatNums and 0 ~= self.repeatNums then
        tb.e = self.repeatNums
    end
    return tb
end

function MsgType.CGReformEquipRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGReformEquipRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCReformEquipRspd = {
    msgSeq = 0,
    reformType = 0, --enum EEquipReformType
    designId = 0,
    repeatNums = 0,
    errorCode = 0,
    getItems = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCReformEquipRspd.__index = MsgType.GCReformEquipRspd

function MsgType.GCReformEquipRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCReformEquipRspd:GetCmd()
    return MsgTypeCmd.GC_ReformEquipRspd
end
function MsgType.GCReformEquipRspd:GetUrl()
    return "GCReformEquipRspd"
end
function MsgType.GCReformEquipRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.reformType = 0
    self.designId = 0
    self.repeatNums = 0
    self.errorCode = 0
    self.getItems = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.reformType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.designId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.repeatNums = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.errorCode = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpGetItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpGetItemsObj:Decode(data.g[i])
            self.getItems[i] = tmpGetItemsObj
        end
    end
    return self
end


MsgType.CGRebuildEquipRqst = {
    msgSeq = 0,
    rebuildId = 0,
    elements = {} -- array of number
}
MsgType.CGRebuildEquipRqst.__index = MsgType.CGRebuildEquipRqst

function MsgType.CGRebuildEquipRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRebuildEquipRqst:GetCmd()
    return MsgTypeCmd.CG_RebuildEquipRqst
end
function MsgType.CGRebuildEquipRqst:GetUrl()
    return "CGRebuildEquipRqst"
end
function MsgType.CGRebuildEquipRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rebuildId and 0 ~= self.rebuildId then
        tb.c = self.rebuildId
    end
    if nil ~= self.elements and string.len(self.elements) > 0 then
        tb.d = self.elements
    end
    return tb
end

function MsgType.CGRebuildEquipRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRebuildEquipRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRebuildEquipRspd = {
    msgSeq = 0,
    rebuildId = 0,
    elements = {}, -- array of number
    errorCode = 0,
    getItems = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCRebuildEquipRspd.__index = MsgType.GCRebuildEquipRspd

function MsgType.GCRebuildEquipRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRebuildEquipRspd:GetCmd()
    return MsgTypeCmd.GC_RebuildEquipRspd
end
function MsgType.GCRebuildEquipRspd:GetUrl()
    return "GCRebuildEquipRspd"
end
function MsgType.GCRebuildEquipRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.rebuildId = 0
    self.elements = {}
    self.errorCode = 0
    self.getItems = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.rebuildId = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.elements[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.e then
        self.errorCode = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpGetItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpGetItemsObj:Decode(data.f[i])
            self.getItems[i] = tmpGetItemsObj
        end
    end
    return self
end


MsgType.CGGetDesignInfoRqst = {
    msgSeq = 0,
    unused = false
}
MsgType.CGGetDesignInfoRqst.__index = MsgType.CGGetDesignInfoRqst

function MsgType.CGGetDesignInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetDesignInfoRqst:GetCmd()
    return MsgTypeCmd.CG_GetDesignInfoRqst
end
function MsgType.CGGetDesignInfoRqst:GetUrl()
    return "CGGetDesignInfoRqst"
end
function MsgType.CGGetDesignInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if self.unused then
        tb.c = self.unused
    end
    return tb
end

function MsgType.CGGetDesignInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetDesignInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEquipCollectInfoRspd = {
    msgSeq = 0,
    collectNum = 0
}
MsgType.GCEquipCollectInfoRspd.__index = MsgType.GCEquipCollectInfoRspd

function MsgType.GCEquipCollectInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEquipCollectInfoRspd:GetCmd()
    return MsgTypeCmd.GC_EquipCollectInfoRspd
end
function MsgType.GCEquipCollectInfoRspd:GetUrl()
    return "GCEquipCollectInfoRspd"
end
function MsgType.GCEquipCollectInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.collectNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.collectNum = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGBlackMarketGetGoodsListRqst = {
    msgSeq = 0,
    blackMarketId = 0
}
MsgType.CGBlackMarketGetGoodsListRqst.__index = MsgType.CGBlackMarketGetGoodsListRqst

function MsgType.CGBlackMarketGetGoodsListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGBlackMarketGetGoodsListRqst:GetCmd()
    return MsgTypeCmd.CG_BlackMarketGetGoodsListRqst
end
function MsgType.CGBlackMarketGetGoodsListRqst:GetUrl()
    return "CGBlackMarketGetGoodsListRqst"
end
function MsgType.CGBlackMarketGetGoodsListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.blackMarketId and 0 ~= self.blackMarketId then
        tb.c = self.blackMarketId
    end
    return tb
end

function MsgType.CGBlackMarketGetGoodsListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGBlackMarketGetGoodsListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCBlackMarketGetGoodsListRspd = {
    msgSeq = 0,
    blackMarketId = 0,
    leftTime = 0,
    blackMarketDropIds = {}, -- array of number
    errorCode = 0
}
MsgType.GCBlackMarketGetGoodsListRspd.__index = MsgType.GCBlackMarketGetGoodsListRspd

function MsgType.GCBlackMarketGetGoodsListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCBlackMarketGetGoodsListRspd:GetCmd()
    return MsgTypeCmd.GC_BlackMarketGetGoodsListRspd
end
function MsgType.GCBlackMarketGetGoodsListRspd:GetUrl()
    return "GCBlackMarketGetGoodsListRspd"
end
function MsgType.GCBlackMarketGetGoodsListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.blackMarketId = 0
    self.leftTime = 0
    self.blackMarketDropIds = {}
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.blackMarketId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.leftTime = tonumber(data.d) or 0
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.blackMarketDropIds[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.f then
        self.errorCode = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGBlackMarketBuyGoodsRqst = {
    msgSeq = 0,
    blackMarketId = 0,
    blackMarketDropIds = {} -- array of number
}
MsgType.CGBlackMarketBuyGoodsRqst.__index = MsgType.CGBlackMarketBuyGoodsRqst

function MsgType.CGBlackMarketBuyGoodsRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGBlackMarketBuyGoodsRqst:GetCmd()
    return MsgTypeCmd.CG_BlackMarketBuyGoodsRqst
end
function MsgType.CGBlackMarketBuyGoodsRqst:GetUrl()
    return "CGBlackMarketBuyGoodsRqst"
end
function MsgType.CGBlackMarketBuyGoodsRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.blackMarketId and 0 ~= self.blackMarketId then
        tb.c = self.blackMarketId
    end
    if nil ~= self.blackMarketDropIds and string.len(self.blackMarketDropIds) > 0 then
        tb.d = self.blackMarketDropIds
    end
    return tb
end

function MsgType.CGBlackMarketBuyGoodsRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGBlackMarketBuyGoodsRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCBlackMarketBuyGoodsRspd = {
    msgSeq = 0,
    blackMarketId = 0,
    errorCode = 0
}
MsgType.GCBlackMarketBuyGoodsRspd.__index = MsgType.GCBlackMarketBuyGoodsRspd

function MsgType.GCBlackMarketBuyGoodsRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCBlackMarketBuyGoodsRspd:GetCmd()
    return MsgTypeCmd.GC_BlackMarketBuyGoodsRspd
end
function MsgType.GCBlackMarketBuyGoodsRspd:GetUrl()
    return "GCBlackMarketBuyGoodsRspd"
end
function MsgType.GCBlackMarketBuyGoodsRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.blackMarketId = 0
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.blackMarketId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGBlackMarketRetryGameRqst = {
    msgSeq = 0,
    unusedArg = 0
}
MsgType.CGBlackMarketRetryGameRqst.__index = MsgType.CGBlackMarketRetryGameRqst

function MsgType.CGBlackMarketRetryGameRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGBlackMarketRetryGameRqst:GetCmd()
    return MsgTypeCmd.CG_BlackMarketRetryGameRqst
end
function MsgType.CGBlackMarketRetryGameRqst:GetUrl()
    return "CGBlackMarketRetryGameRqst"
end
function MsgType.CGBlackMarketRetryGameRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unusedArg and 0 ~= self.unusedArg then
        tb.c = self.unusedArg
    end
    return tb
end

function MsgType.CGBlackMarketRetryGameRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGBlackMarketRetryGameRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCBlackMarketRetryGameRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCBlackMarketRetryGameRspd.__index = MsgType.GCBlackMarketRetryGameRspd

function MsgType.GCBlackMarketRetryGameRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCBlackMarketRetryGameRspd:GetCmd()
    return MsgTypeCmd.GC_BlackMarketRetryGameRspd
end
function MsgType.GCBlackMarketRetryGameRspd:GetUrl()
    return "GCBlackMarketRetryGameRspd"
end
function MsgType.GCBlackMarketRetryGameRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGBlackMarketReturnDiscountRqst = {
    msgSeq = 0,
    discountRate = 0
}
MsgType.CGBlackMarketReturnDiscountRqst.__index = MsgType.CGBlackMarketReturnDiscountRqst

function MsgType.CGBlackMarketReturnDiscountRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGBlackMarketReturnDiscountRqst:GetCmd()
    return MsgTypeCmd.CG_BlackMarketReturnDiscountRqst
end
function MsgType.CGBlackMarketReturnDiscountRqst:GetUrl()
    return "CGBlackMarketReturnDiscountRqst"
end
function MsgType.CGBlackMarketReturnDiscountRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.discountRate and 0 ~= self.discountRate then
        tb.c = self.discountRate
    end
    return tb
end

function MsgType.CGBlackMarketReturnDiscountRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGBlackMarketReturnDiscountRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCBlackMarketReturnDiscountRspd = {
    msgSeq = 0,
    discountRate = 0,
    errorCode = 0
}
MsgType.GCBlackMarketReturnDiscountRspd.__index = MsgType.GCBlackMarketReturnDiscountRspd

function MsgType.GCBlackMarketReturnDiscountRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCBlackMarketReturnDiscountRspd:GetCmd()
    return MsgTypeCmd.GC_BlackMarketReturnDiscountRspd
end
function MsgType.GCBlackMarketReturnDiscountRspd:GetUrl()
    return "GCBlackMarketReturnDiscountRspd"
end
function MsgType.GCBlackMarketReturnDiscountRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.discountRate = 0
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.discountRate = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGAchieveInfoRqst = {
    msgSeq = 0,
    reqAchieveStatus = 0 --enum EAchieveStatus
}
MsgType.CGAchieveInfoRqst.__index = MsgType.CGAchieveInfoRqst

function MsgType.CGAchieveInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAchieveInfoRqst:GetCmd()
    return MsgTypeCmd.CG_AchieveInfoRqst
end
function MsgType.CGAchieveInfoRqst:GetUrl()
    return "CGAchieveInfoRqst"
end
function MsgType.CGAchieveInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.reqAchieveStatus and 0 ~= self.reqAchieveStatus then
        tb.c = self.reqAchieveStatus
    end
    return tb
end

function MsgType.CGAchieveInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAchieveInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAchieveInfoRspd = {
    msgSeq = 0,
    optRst = 0, --enum EAchieveQueryOptCode
    achieveStatus = 0, --enum EAchieveStatus
    isEndOfList = false,
    achieveList = {}
}
MsgType.GCAchieveInfoRspd.__index = MsgType.GCAchieveInfoRspd
setmetatable(MsgType.GCAchieveInfoRspd.achieveList, MsgType.AchieveList)

function MsgType.GCAchieveInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAchieveInfoRspd:GetCmd()
    return MsgTypeCmd.GC_AchieveInfoRspd
end
function MsgType.GCAchieveInfoRspd:GetUrl()
    return "GCAchieveInfoRspd"
end
function MsgType.GCAchieveInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optRst = 0
    self.achieveStatus = 0
    self.isEndOfList = false
    self.achieveList = MsgType.AchieveList:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.optRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.achieveStatus = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isEndOfList = data.e
    end
    if nil ~= data.f then
        self.achieveList:Decode(data.f)
    end
    return self
end


MsgType.GCAchieveProgressInfoRspd = {
    msgSeq = 0,
    optRst = 0, --enum EAchieveQueryOptCode
    isEndOfList = false,
    achieveProgressInfoList = {}
}
MsgType.GCAchieveProgressInfoRspd.__index = MsgType.GCAchieveProgressInfoRspd
setmetatable(MsgType.GCAchieveProgressInfoRspd.achieveProgressInfoList, MsgType.AchieveProgressList)

function MsgType.GCAchieveProgressInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAchieveProgressInfoRspd:GetCmd()
    return MsgTypeCmd.GC_AchieveProgressInfoRspd
end
function MsgType.GCAchieveProgressInfoRspd:GetUrl()
    return "GCAchieveProgressInfoRspd"
end
function MsgType.GCAchieveProgressInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optRst = 0
    self.isEndOfList = false
    self.achieveProgressInfoList = MsgType.AchieveProgressList:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.optRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isEndOfList = data.d
    end
    if nil ~= data.e then
        self.achieveProgressInfoList:Decode(data.e)
    end
    return self
end


MsgType.CGAchieveRewardRqst = {
    msgSeq = 0,
    achieveID = 0
}
MsgType.CGAchieveRewardRqst.__index = MsgType.CGAchieveRewardRqst

function MsgType.CGAchieveRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAchieveRewardRqst:GetCmd()
    return MsgTypeCmd.CG_AchieveRewardRqst
end
function MsgType.CGAchieveRewardRqst:GetUrl()
    return "CGAchieveRewardRqst"
end
function MsgType.CGAchieveRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.achieveID and 0 ~= self.achieveID then
        tb.c = self.achieveID
    end
    return tb
end

function MsgType.CGAchieveRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAchieveRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAchieveRewardRspd = {
    msgSeq = 0,
    achieveRewardRst = 0, --enum EAchieveRewardOpCode
    achieveID = 0,
    rewardItemID = 0,
    rewardItemNum = 0
}
MsgType.GCAchieveRewardRspd.__index = MsgType.GCAchieveRewardRspd

function MsgType.GCAchieveRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAchieveRewardRspd:GetCmd()
    return MsgTypeCmd.GC_AchieveRewardRspd
end
function MsgType.GCAchieveRewardRspd:GetUrl()
    return "GCAchieveRewardRspd"
end
function MsgType.GCAchieveRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.achieveRewardRst = 0
    self.achieveID = 0
    self.rewardItemID = 0
    self.rewardItemNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.achieveRewardRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.achieveID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.rewardItemID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rewardItemNum = tonumber(data.f) or 0
    end
    return self
end


MsgType.GCAchieveStatusChangeRspd = {
    msgSeq = 0,
    achieveID = 0,
    newStatus = 0 --enum EAchieveStatus
}
MsgType.GCAchieveStatusChangeRspd.__index = MsgType.GCAchieveStatusChangeRspd

function MsgType.GCAchieveStatusChangeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAchieveStatusChangeRspd:GetCmd()
    return MsgTypeCmd.GC_AchieveStatusChangeRspd
end
function MsgType.GCAchieveStatusChangeRspd:GetUrl()
    return "GCAchieveStatusChangeRspd"
end
function MsgType.GCAchieveStatusChangeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.achieveID = 0
    self.newStatus = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.achieveID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.newStatus = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGLuckyDrawPoolInfoRqst = {
    msgSeq = 0,
    unused = 0
}
MsgType.CGLuckyDrawPoolInfoRqst.__index = MsgType.CGLuckyDrawPoolInfoRqst

function MsgType.CGLuckyDrawPoolInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLuckyDrawPoolInfoRqst:GetCmd()
    return MsgTypeCmd.CG_LuckyDrawPoolInfoRqst
end
function MsgType.CGLuckyDrawPoolInfoRqst:GetUrl()
    return "CGLuckyDrawPoolInfoRqst"
end
function MsgType.CGLuckyDrawPoolInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unused and 0 ~= self.unused then
        tb.c = self.unused
    end
    return tb
end

function MsgType.CGLuckyDrawPoolInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLuckyDrawPoolInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLuckyDrawPoolInfoRspd = {
    msgSeq = 0,
    luckydrawPoolInfoQryRst = 0, --enum ELuckyDrawPoolQryRst
    availablePoolIDList = {} -- array of number
}
MsgType.GCLuckyDrawPoolInfoRspd.__index = MsgType.GCLuckyDrawPoolInfoRspd

function MsgType.GCLuckyDrawPoolInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLuckyDrawPoolInfoRspd:GetCmd()
    return MsgTypeCmd.GC_LuckyDrawPoolInfoRspd
end
function MsgType.GCLuckyDrawPoolInfoRspd:GetUrl()
    return "GCLuckyDrawPoolInfoRspd"
end
function MsgType.GCLuckyDrawPoolInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.luckydrawPoolInfoQryRst = 0
    self.availablePoolIDList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.luckydrawPoolInfoQryRst = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.availablePoolIDList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGLuckyDrawPersonalInfoRqst = {
    msgSeq = 0,
    unused = 0
}
MsgType.CGLuckyDrawPersonalInfoRqst.__index = MsgType.CGLuckyDrawPersonalInfoRqst

function MsgType.CGLuckyDrawPersonalInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLuckyDrawPersonalInfoRqst:GetCmd()
    return MsgTypeCmd.CG_LuckyDrawPersonalInfoRqst
end
function MsgType.CGLuckyDrawPersonalInfoRqst:GetUrl()
    return "CGLuckyDrawPersonalInfoRqst"
end
function MsgType.CGLuckyDrawPersonalInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unused and 0 ~= self.unused then
        tb.c = self.unused
    end
    return tb
end

function MsgType.CGLuckyDrawPersonalInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLuckyDrawPersonalInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLuckyDrawPersonalInfoRspd = {
    msgSeq = 0,
    luckydrawPersonalInfoQryRst = 0, --enum ELuckyDrawPersonalInfoQryRst
    personalLuckyDrawInfoList = {} -- array of MsgType.PersonalLuckyDrawPoolInfo
}
MsgType.GCLuckyDrawPersonalInfoRspd.__index = MsgType.GCLuckyDrawPersonalInfoRspd

function MsgType.GCLuckyDrawPersonalInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLuckyDrawPersonalInfoRspd:GetCmd()
    return MsgTypeCmd.GC_LuckyDrawPersonalInfoRspd
end
function MsgType.GCLuckyDrawPersonalInfoRspd:GetUrl()
    return "GCLuckyDrawPersonalInfoRspd"
end
function MsgType.GCLuckyDrawPersonalInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.luckydrawPersonalInfoQryRst = 0
    self.personalLuckyDrawInfoList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.luckydrawPersonalInfoQryRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpPersonalLuckyDrawInfoListObj = MsgType.PersonalLuckyDrawPoolInfo:New()
            tmpPersonalLuckyDrawInfoListObj:Decode(data.d[i])
            self.personalLuckyDrawInfoList[i] = tmpPersonalLuckyDrawInfoListObj
        end
    end
    return self
end


MsgType.CGLuckyDrawOpRqst = {
    msgSeq = 0,
    luckyPoolID = 0,
    luckydrawOpType = 0, --enum ELuckyDrawOpType
    luckydrawTimesType = 0, --enum ELuckyDrawTimesType
    expectConsumeNum = 0
}
MsgType.CGLuckyDrawOpRqst.__index = MsgType.CGLuckyDrawOpRqst

function MsgType.CGLuckyDrawOpRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLuckyDrawOpRqst:GetCmd()
    return MsgTypeCmd.CG_LuckyDrawOpRqst
end
function MsgType.CGLuckyDrawOpRqst:GetUrl()
    return "CGLuckyDrawOpRqst"
end
function MsgType.CGLuckyDrawOpRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.luckyPoolID and 0 ~= self.luckyPoolID then
        tb.c = self.luckyPoolID
    end
    if nil ~= self.luckydrawOpType and 0 ~= self.luckydrawOpType then
        tb.d = self.luckydrawOpType
    end
    if nil ~= self.luckydrawTimesType and 0 ~= self.luckydrawTimesType then
        tb.e = self.luckydrawTimesType
    end
    if nil ~= self.expectConsumeNum and 0 ~= self.expectConsumeNum then
        tb.f = self.expectConsumeNum
    end
    return tb
end

function MsgType.CGLuckyDrawOpRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLuckyDrawOpRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLuckyDrawOpRspd = {
    msgSeq = 0,
    luckydrawOpRst = 0, --enum ELuckyDrawOpRst
    luckyPoolID = 0,
    luckydrawOpType = 0, --enum ELuckyDrawOpType
    luckydrawTimesType = 0, --enum ELuckyDrawTimesType
    consumeNum = 0
}
MsgType.GCLuckyDrawOpRspd.__index = MsgType.GCLuckyDrawOpRspd

function MsgType.GCLuckyDrawOpRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLuckyDrawOpRspd:GetCmd()
    return MsgTypeCmd.GC_LuckyDrawOpRspd
end
function MsgType.GCLuckyDrawOpRspd:GetUrl()
    return "GCLuckyDrawOpRspd"
end
function MsgType.GCLuckyDrawOpRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.luckydrawOpRst = 0
    self.luckyPoolID = 0
    self.luckydrawOpType = 0
    self.luckydrawTimesType = 0
    self.consumeNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.luckydrawOpRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.luckyPoolID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.luckydrawOpType = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.luckydrawTimesType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.consumeNum = tonumber(data.g) or 0
    end
    return self
end


MsgType.CGLuckyDrawExchangeRqst = {
    msgSeq = 0,
    luckyPoolID = 0,
    expectConsumeNum = 0,
    tgtItemTypeID = 0,
    expectGainNum = 0
}
MsgType.CGLuckyDrawExchangeRqst.__index = MsgType.CGLuckyDrawExchangeRqst

function MsgType.CGLuckyDrawExchangeRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGLuckyDrawExchangeRqst:GetCmd()
    return MsgTypeCmd.CG_LuckyDrawExchangeRqst
end
function MsgType.CGLuckyDrawExchangeRqst:GetUrl()
    return "CGLuckyDrawExchangeRqst"
end
function MsgType.CGLuckyDrawExchangeRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.luckyPoolID and 0 ~= self.luckyPoolID then
        tb.c = self.luckyPoolID
    end
    if nil ~= self.expectConsumeNum and 0 ~= self.expectConsumeNum then
        tb.d = self.expectConsumeNum
    end
    if nil ~= self.tgtItemTypeID and 0 ~= self.tgtItemTypeID then
        tb.e = self.tgtItemTypeID
    end
    if nil ~= self.expectGainNum and 0 ~= self.expectGainNum then
        tb.f = self.expectGainNum
    end
    return tb
end

function MsgType.CGLuckyDrawExchangeRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGLuckyDrawExchangeRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCLuckyDrawExchangeRspd = {
    msgSeq = 0,
    luckydrawExchangeRst = 0, --enum ELuckyDrawExchangeRst
    luckyPoolID = 0,
    consumeNum = 0,
    tgtItemTypeID = 0,
    gainNum = 0
}
MsgType.GCLuckyDrawExchangeRspd.__index = MsgType.GCLuckyDrawExchangeRspd

function MsgType.GCLuckyDrawExchangeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCLuckyDrawExchangeRspd:GetCmd()
    return MsgTypeCmd.GC_LuckyDrawExchangeRspd
end
function MsgType.GCLuckyDrawExchangeRspd:GetUrl()
    return "GCLuckyDrawExchangeRspd"
end
function MsgType.GCLuckyDrawExchangeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.luckydrawExchangeRst = 0
    self.luckyPoolID = 0
    self.consumeNum = 0
    self.tgtItemTypeID = 0
    self.gainNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.luckydrawExchangeRst = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.luckyPoolID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.consumeNum = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.tgtItemTypeID = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.gainNum = tonumber(data.g) or 0
    end
    return self
end


MsgType.CGActivityEnterRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGActivityEnterRqst.__index = MsgType.CGActivityEnterRqst

function MsgType.CGActivityEnterRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActivityEnterRqst:GetCmd()
    return MsgTypeCmd.CG_ActivityEnterRqst
end
function MsgType.CGActivityEnterRqst:GetUrl()
    return "CGActivityEnterRqst"
end
function MsgType.CGActivityEnterRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGActivityEnterRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActivityEnterRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActivityEnterRspd = {
    msgSeq = 0,
    isInTime = false,
    remainingTime = 0,
    isPassedLevel = false
}
MsgType.GCActivityEnterRspd.__index = MsgType.GCActivityEnterRspd

function MsgType.GCActivityEnterRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActivityEnterRspd:GetCmd()
    return MsgTypeCmd.GC_ActivityEnterRspd
end
function MsgType.GCActivityEnterRspd:GetUrl()
    return "GCActivityEnterRspd"
end
function MsgType.GCActivityEnterRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isInTime = false
    self.remainingTime = 0
    self.isPassedLevel = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isInTime = data.c
    end
    if nil ~= data.d then
        self.remainingTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isPassedLevel = data.e
    end
    return self
end


MsgType.CGCurrentChapterLevelRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGCurrentChapterLevelRqst.__index = MsgType.CGCurrentChapterLevelRqst

function MsgType.CGCurrentChapterLevelRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCurrentChapterLevelRqst:GetCmd()
    return MsgTypeCmd.CG_CurrentChapterLevelRqst
end
function MsgType.CGCurrentChapterLevelRqst:GetUrl()
    return "CGCurrentChapterLevelRqst"
end
function MsgType.CGCurrentChapterLevelRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGCurrentChapterLevelRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCurrentChapterLevelRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCurrentChapterLevelRspd = {
    msgSeq = 0,
    actionPointDataClient = {},
    breakthroughData = {},
    isAllSuccess = false,
    isLastLevel = false
}
MsgType.GCCurrentChapterLevelRspd.__index = MsgType.GCCurrentChapterLevelRspd
setmetatable(MsgType.GCCurrentChapterLevelRspd.actionPointDataClient, MsgType.ActionPointDataClient)
setmetatable(MsgType.GCCurrentChapterLevelRspd.breakthroughData, MsgType.BreakthroughData)

function MsgType.GCCurrentChapterLevelRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCurrentChapterLevelRspd:GetCmd()
    return MsgTypeCmd.GC_CurrentChapterLevelRspd
end
function MsgType.GCCurrentChapterLevelRspd:GetUrl()
    return "GCCurrentChapterLevelRspd"
end
function MsgType.GCCurrentChapterLevelRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.actionPointDataClient = MsgType.ActionPointDataClient:New()
    self.breakthroughData = MsgType.BreakthroughData:New()
    self.isAllSuccess = false
    self.isLastLevel = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.actionPointDataClient:Decode(data.c)
    end
    if nil ~= data.d then
        self.breakthroughData:Decode(data.d)
    end
    if nil ~= data.e then
        self.isAllSuccess = data.e
    end
    if nil ~= data.f then
        self.isLastLevel = data.f
    end
    return self
end


MsgType.CGChapterLevelResultRqst = {
    msgSeq = 0,
    chapterID = 0,
    levelID = 0,
    isSuccess = false
}
MsgType.CGChapterLevelResultRqst.__index = MsgType.CGChapterLevelResultRqst

function MsgType.CGChapterLevelResultRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGChapterLevelResultRqst:GetCmd()
    return MsgTypeCmd.CG_ChapterLevelResultRqst
end
function MsgType.CGChapterLevelResultRqst:GetUrl()
    return "CGChapterLevelResultRqst"
end
function MsgType.CGChapterLevelResultRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chapterID and 0 ~= self.chapterID then
        tb.c = self.chapterID
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.d = self.levelID
    end
    if self.isSuccess then
        tb.e = self.isSuccess
    end
    return tb
end

function MsgType.CGChapterLevelResultRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGChapterLevelResultRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCChapterLevelResultRspd = {
    msgSeq = 0,
    canToNext = false,
    isAllSuccess = false
}
MsgType.GCChapterLevelResultRspd.__index = MsgType.GCChapterLevelResultRspd

function MsgType.GCChapterLevelResultRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCChapterLevelResultRspd:GetCmd()
    return MsgTypeCmd.GC_ChapterLevelResultRspd
end
function MsgType.GCChapterLevelResultRspd:GetUrl()
    return "GCChapterLevelResultRspd"
end
function MsgType.GCChapterLevelResultRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.canToNext = false
    self.isAllSuccess = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.canToNext = data.c
    end
    if nil ~= data.d then
        self.isAllSuccess = data.d
    end
    return self
end


MsgType.CGReceiveRewardRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGReceiveRewardRqst.__index = MsgType.CGReceiveRewardRqst

function MsgType.CGReceiveRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGReceiveRewardRqst:GetCmd()
    return MsgTypeCmd.CG_ReceiveRewardRqst
end
function MsgType.CGReceiveRewardRqst:GetUrl()
    return "CGReceiveRewardRqst"
end
function MsgType.CGReceiveRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGReceiveRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGReceiveRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCReceiveRewardRspd = {
    msgSeq = 0,
    isSuccess = false
}
MsgType.GCReceiveRewardRspd.__index = MsgType.GCReceiveRewardRspd

function MsgType.GCReceiveRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCReceiveRewardRspd:GetCmd()
    return MsgTypeCmd.GC_ReceiveRewardRspd
end
function MsgType.GCReceiveRewardRspd:GetUrl()
    return "GCReceiveRewardRspd"
end
function MsgType.GCReceiveRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    return self
end


MsgType.CGStoryGetRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGStoryGetRqst.__index = MsgType.CGStoryGetRqst

function MsgType.CGStoryGetRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGStoryGetRqst:GetCmd()
    return MsgTypeCmd.CG_StoryGetRqst
end
function MsgType.CGStoryGetRqst:GetUrl()
    return "CGStoryGetRqst"
end
function MsgType.CGStoryGetRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGStoryGetRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGStoryGetRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCStoryGetRspd = {
    msgSeq = 0,
    storyID = 0,
    nextTaskList = {} -- array of number
}
MsgType.GCStoryGetRspd.__index = MsgType.GCStoryGetRspd

function MsgType.GCStoryGetRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCStoryGetRspd:GetCmd()
    return MsgTypeCmd.GC_StoryGetRspd
end
function MsgType.GCStoryGetRspd:GetUrl()
    return "GCStoryGetRspd"
end
function MsgType.GCStoryGetRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.storyID = 0
    self.nextTaskList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.storyID = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.nextTaskList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGStoryFinishRqst = {
    msgSeq = 0,
    storyID = 0
}
MsgType.CGStoryFinishRqst.__index = MsgType.CGStoryFinishRqst

function MsgType.CGStoryFinishRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGStoryFinishRqst:GetCmd()
    return MsgTypeCmd.CG_StoryFinishRqst
end
function MsgType.CGStoryFinishRqst:GetUrl()
    return "CGStoryFinishRqst"
end
function MsgType.CGStoryFinishRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.storyID and 0 ~= self.storyID then
        tb.c = self.storyID
    end
    return tb
end

function MsgType.CGStoryFinishRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGStoryFinishRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCStoryFinishRspd = {
    msgSeq = 0,
    isSuccess = 0
}
MsgType.GCStoryFinishRspd.__index = MsgType.GCStoryFinishRspd

function MsgType.GCStoryFinishRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCStoryFinishRspd:GetCmd()
    return MsgTypeCmd.GC_StoryFinishRspd
end
function MsgType.GCStoryFinishRspd:GetUrl()
    return "GCStoryFinishRspd"
end
function MsgType.GCStoryFinishRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGTaskGetListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGTaskGetListRqst.__index = MsgType.CGTaskGetListRqst

function MsgType.CGTaskGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTaskGetListRqst:GetCmd()
    return MsgTypeCmd.CG_TaskGetListRqst
end
function MsgType.CGTaskGetListRqst:GetUrl()
    return "CGTaskGetListRqst"
end
function MsgType.CGTaskGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGTaskGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTaskGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTaskGetListRspd = {
    msgSeq = 0,
    taskList = {} -- array of MsgType.TaskInfo
}
MsgType.GCTaskGetListRspd.__index = MsgType.GCTaskGetListRspd

function MsgType.GCTaskGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskGetListRspd:GetCmd()
    return MsgTypeCmd.GC_TaskGetListRspd
end
function MsgType.GCTaskGetListRspd:GetUrl()
    return "GCTaskGetListRspd"
end
function MsgType.GCTaskGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpTaskListObj = MsgType.TaskInfo:New()
            tmpTaskListObj:Decode(data.c[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end


MsgType.CGTaskProcessRqst = {
    msgSeq = 0,
    taskID = 0
}
MsgType.CGTaskProcessRqst.__index = MsgType.CGTaskProcessRqst

function MsgType.CGTaskProcessRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTaskProcessRqst:GetCmd()
    return MsgTypeCmd.CG_TaskProcessRqst
end
function MsgType.CGTaskProcessRqst:GetUrl()
    return "CGTaskProcessRqst"
end
function MsgType.CGTaskProcessRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.c = self.taskID
    end
    return tb
end

function MsgType.CGTaskProcessRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTaskProcessRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTaskProcessRspd = {
    msgSeq = 0,
    errorCode = 0, --enum ETaskOptCode
    taskInfo = {}
}
MsgType.GCTaskProcessRspd.__index = MsgType.GCTaskProcessRspd
setmetatable(MsgType.GCTaskProcessRspd.taskInfo, MsgType.TaskInfo)

function MsgType.GCTaskProcessRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskProcessRspd:GetCmd()
    return MsgTypeCmd.GC_TaskProcessRspd
end
function MsgType.GCTaskProcessRspd:GetUrl()
    return "GCTaskProcessRspd"
end
function MsgType.GCTaskProcessRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.taskInfo = MsgType.TaskInfo:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskInfo:Decode(data.d)
    end
    return self
end


MsgType.CGTaskFinishRqst = {
    msgSeq = 0,
    taskID = 0,
    costMoneyFlag = 0
}
MsgType.CGTaskFinishRqst.__index = MsgType.CGTaskFinishRqst

function MsgType.CGTaskFinishRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTaskFinishRqst:GetCmd()
    return MsgTypeCmd.CG_TaskFinishRqst
end
function MsgType.CGTaskFinishRqst:GetUrl()
    return "CGTaskFinishRqst"
end
function MsgType.CGTaskFinishRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.c = self.taskID
    end
    if nil ~= self.costMoneyFlag and 0 ~= self.costMoneyFlag then
        tb.d = self.costMoneyFlag
    end
    return tb
end

function MsgType.CGTaskFinishRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTaskFinishRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTaskFinishRspd = {
    msgSeq = 0,
    errorCode = 0, --enum ETaskOptCode
    taskID = 0
}
MsgType.GCTaskFinishRspd.__index = MsgType.GCTaskFinishRspd

function MsgType.GCTaskFinishRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskFinishRspd:GetCmd()
    return MsgTypeCmd.GC_TaskFinishRspd
end
function MsgType.GCTaskFinishRspd:GetUrl()
    return "GCTaskFinishRspd"
end
function MsgType.GCTaskFinishRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.taskID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskID = tonumber(data.d) or 0
    end
    return self
end


MsgType.GCTaskNewTaskRspd = {
    msgSeq = 0,
    taskInfo = {}
}
MsgType.GCTaskNewTaskRspd.__index = MsgType.GCTaskNewTaskRspd
setmetatable(MsgType.GCTaskNewTaskRspd.taskInfo, MsgType.TaskInfo)

function MsgType.GCTaskNewTaskRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskNewTaskRspd:GetCmd()
    return MsgTypeCmd.GC_TaskNewTaskRspd
end
function MsgType.GCTaskNewTaskRspd:GetUrl()
    return "GCTaskNewTaskRspd"
end
function MsgType.GCTaskNewTaskRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskInfo = MsgType.TaskInfo:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.taskInfo:Decode(data.c)
    end
    return self
end


MsgType.GCTaskDeleteTaskRspd = {
    msgSeq = 0,
    taskID = 0
}
MsgType.GCTaskDeleteTaskRspd.__index = MsgType.GCTaskDeleteTaskRspd

function MsgType.GCTaskDeleteTaskRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskDeleteTaskRspd:GetCmd()
    return MsgTypeCmd.GC_TaskDeleteTaskRspd
end
function MsgType.GCTaskDeleteTaskRspd:GetUrl()
    return "GCTaskDeleteTaskRspd"
end
function MsgType.GCTaskDeleteTaskRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.taskID = tonumber(data.c) or 0
    end
    return self
end


MsgType.GCTaskSectionRspd = {
    msgSeq = 0,
    currentSection = 0,
    currentSectionProgress = 0,
    currentSectionTaskNum = 0
}
MsgType.GCTaskSectionRspd.__index = MsgType.GCTaskSectionRspd

function MsgType.GCTaskSectionRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskSectionRspd:GetCmd()
    return MsgTypeCmd.GC_TaskSectionRspd
end
function MsgType.GCTaskSectionRspd:GetUrl()
    return "GCTaskSectionRspd"
end
function MsgType.GCTaskSectionRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentSection = 0
    self.currentSectionProgress = 0
    self.currentSectionTaskNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.currentSection = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.currentSectionProgress = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.currentSectionTaskNum = tonumber(data.e) or 0
    end
    return self
end


MsgType.GCTaskFinishedListRspd = {
    msgSeq = 0,
    finishedList = {} -- array of number
}
MsgType.GCTaskFinishedListRspd.__index = MsgType.GCTaskFinishedListRspd

function MsgType.GCTaskFinishedListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTaskFinishedListRspd:GetCmd()
    return MsgTypeCmd.GC_TaskFinishedListRspd
end
function MsgType.GCTaskFinishedListRspd:GetUrl()
    return "GCTaskFinishedListRspd"
end
function MsgType.GCTaskFinishedListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.finishedList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.finishedList[i] = tonumber(data.e[i] )
        end
    end
    return self
end


MsgType.CGInteractionRewardGetInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGInteractionRewardGetInfoRqst.__index = MsgType.CGInteractionRewardGetInfoRqst

function MsgType.CGInteractionRewardGetInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGInteractionRewardGetInfoRqst:GetCmd()
    return MsgTypeCmd.CG_InteractionRewardGetInfoRqst
end
function MsgType.CGInteractionRewardGetInfoRqst:GetUrl()
    return "CGInteractionRewardGetInfoRqst"
end
function MsgType.CGInteractionRewardGetInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGInteractionRewardGetInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGInteractionRewardGetInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCInteractionRewardGetInfoRspd = {
    msgSeq = 0,
    canReward = 0,
    canRewardObject = 0,
    nextRewardTime = 0
}
MsgType.GCInteractionRewardGetInfoRspd.__index = MsgType.GCInteractionRewardGetInfoRspd

function MsgType.GCInteractionRewardGetInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCInteractionRewardGetInfoRspd:GetCmd()
    return MsgTypeCmd.GC_InteractionRewardGetInfoRspd
end
function MsgType.GCInteractionRewardGetInfoRspd:GetUrl()
    return "GCInteractionRewardGetInfoRspd"
end
function MsgType.GCInteractionRewardGetInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.canReward = 0
    self.canRewardObject = 0
    self.nextRewardTime = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.canReward = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.canRewardObject = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.nextRewardTime = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGInteractionRewardPickRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGInteractionRewardPickRqst.__index = MsgType.CGInteractionRewardPickRqst

function MsgType.CGInteractionRewardPickRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGInteractionRewardPickRqst:GetCmd()
    return MsgTypeCmd.CG_InteractionRewardPickRqst
end
function MsgType.CGInteractionRewardPickRqst:GetUrl()
    return "CGInteractionRewardPickRqst"
end
function MsgType.CGInteractionRewardPickRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGInteractionRewardPickRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGInteractionRewardPickRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCInteractionRewardPickRspd = {
    msgSeq = 0,
    isSuccess = 0,
    nextRewardTime = 0,
    rewardList = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCInteractionRewardPickRspd.__index = MsgType.GCInteractionRewardPickRspd

function MsgType.GCInteractionRewardPickRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCInteractionRewardPickRspd:GetCmd()
    return MsgTypeCmd.GC_InteractionRewardPickRspd
end
function MsgType.GCInteractionRewardPickRspd:GetUrl()
    return "GCInteractionRewardPickRspd"
end
function MsgType.GCInteractionRewardPickRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    self.nextRewardTime = 0
    self.rewardList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.nextRewardTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRewardListObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardListObj:Decode(data.e[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.CGRoomCurrentRoomRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGRoomCurrentRoomRqst.__index = MsgType.CGRoomCurrentRoomRqst

function MsgType.CGRoomCurrentRoomRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRoomCurrentRoomRqst:GetCmd()
    return MsgTypeCmd.CG_RoomCurrentRoomRqst
end
function MsgType.CGRoomCurrentRoomRqst:GetUrl()
    return "CGRoomCurrentRoomRqst"
end
function MsgType.CGRoomCurrentRoomRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGRoomCurrentRoomRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRoomCurrentRoomRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRoomCurrentRoomRspd = {
    msgSeq = 0,
    currentRoom = {}
}
MsgType.GCRoomCurrentRoomRspd.__index = MsgType.GCRoomCurrentRoomRspd
setmetatable(MsgType.GCRoomCurrentRoomRspd.currentRoom, MsgType.RoomInMsg)

function MsgType.GCRoomCurrentRoomRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRoomCurrentRoomRspd:GetCmd()
    return MsgTypeCmd.GC_RoomCurrentRoomRspd
end
function MsgType.GCRoomCurrentRoomRspd:GetUrl()
    return "GCRoomCurrentRoomRspd"
end
function MsgType.GCRoomCurrentRoomRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentRoom = MsgType.RoomInMsg:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.currentRoom:Decode(data.c)
    end
    return self
end


MsgType.CGRoomGetListRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGRoomGetListRqst.__index = MsgType.CGRoomGetListRqst

function MsgType.CGRoomGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGRoomGetListRqst:GetCmd()
    return MsgTypeCmd.CG_RoomGetListRqst
end
function MsgType.CGRoomGetListRqst:GetUrl()
    return "CGRoomGetListRqst"
end
function MsgType.CGRoomGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGRoomGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGRoomGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCRoomGetListRspd = {
    msgSeq = 0,
    currentRoomID = 0,
    roomList = {} -- array of MsgType.RoomInMsg
}
MsgType.GCRoomGetListRspd.__index = MsgType.GCRoomGetListRspd

function MsgType.GCRoomGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRoomGetListRspd:GetCmd()
    return MsgTypeCmd.GC_RoomGetListRspd
end
function MsgType.GCRoomGetListRspd:GetUrl()
    return "GCRoomGetListRspd"
end
function MsgType.GCRoomGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.currentRoomID = 0
    self.roomList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.currentRoomID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpRoomListObj = MsgType.RoomInMsg:New()
            tmpRoomListObj:Decode(data.d[i])
            self.roomList[i] = tmpRoomListObj
        end
    end
    return self
end


MsgType.GCRoomEventRspd = {
    msgSeq = 0,
    roomOrObject = 0, --enum ETaskRewardType
    src = 0,
    dest = 0
}
MsgType.GCRoomEventRspd.__index = MsgType.GCRoomEventRspd

function MsgType.GCRoomEventRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCRoomEventRspd:GetCmd()
    return MsgTypeCmd.GC_RoomEventRspd
end
function MsgType.GCRoomEventRspd:GetUrl()
    return "GCRoomEventRspd"
end
function MsgType.GCRoomEventRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roomOrObject = 0
    self.src = 0
    self.dest = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.roomOrObject = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.src = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.dest = tonumber(data.e) or 0
    end
    return self
end


MsgType.ItemGatherConfigInfo = {
    activityID = 0,
    beginTime = 0,
    endTime = 0,
    title = "",
    image = "",
    gatherItem = {},
    awardList = {}, -- array of MsgType.ItemDisplayerInfo
    level = 0
}
MsgType.ItemGatherConfigInfo.__index = MsgType.ItemGatherConfigInfo
setmetatable(MsgType.ItemGatherConfigInfo.gatherItem, MsgType.ItemDisplayerInfo)

function MsgType.ItemGatherConfigInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemGatherConfigInfo:_awardListEncode()
    local tb = {}
    for i=1, #self.awardList do
        tb[i] = self.awardList[i]:encode()
    end
    return tb
end
function MsgType.ItemGatherConfigInfo:Encode()
    local tb = {}
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.b = self.activityID
    end
    if nil ~= self.beginTime and 0 ~= self.beginTime then
        tb.c = self.beginTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.d = self.endTime
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.e = self.title
    end
    if nil ~= self.image and string.len(self.image) > 0 then
        tb.f = self.image
    end
    tb.g = self.gatherItem:Encode()
    tb.h = self:_awardListEncode()
    if nil ~= self.level and 0 ~= self.level then
        tb.i = self.level
    end
    return tb
end

function MsgType.ItemGatherConfigInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.activityID = 0
    self.beginTime = 0
    self.endTime = 0
    self.title = ""
    self.image = ""
    self.gatherItem = MsgType.ItemDisplayerInfo:New()
    self.awardList = {}
    self.level = 0
    if nil ~= data.b then
        self.activityID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.beginTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.endTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.title = tostring(data.e)
    end
    if nil ~= data.f then
        self.image = tostring(data.f)
    end
    if nil ~= data.g then
        self.gatherItem:Decode(data.g)
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpAwardListObj = MsgType.ItemDisplayerInfo:New()
            tmpAwardListObj:Decode(data.h[i])
            self.awardList[i] = tmpAwardListObj
        end
    end
    if nil ~= data.i then
        self.level = tonumber(data.i) or 0
    end
    return self
end

function MsgType.ItemGatherConfigInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UserItemGatherInfo = {
    activityID = 0,
    beginTime = 0,
    endTime = 0,
    gatherInfo = {},
    needgatherInfo = {},
    awardList = {}, -- array of MsgType.ItemDisplayerInfo
    isHasGetAward = 0
}
MsgType.UserItemGatherInfo.__index = MsgType.UserItemGatherInfo
setmetatable(MsgType.UserItemGatherInfo.gatherInfo, MsgType.ItemDisplayerInfo)
setmetatable(MsgType.UserItemGatherInfo.needgatherInfo, MsgType.ItemDisplayerInfo)

function MsgType.UserItemGatherInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UserItemGatherInfo:_awardListEncode()
    local tb = {}
    for i=1, #self.awardList do
        tb[i] = self.awardList[i]:encode()
    end
    return tb
end
function MsgType.UserItemGatherInfo:Encode()
    local tb = {}
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.b = self.activityID
    end
    if nil ~= self.beginTime and 0 ~= self.beginTime then
        tb.c = self.beginTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.d = self.endTime
    end
    tb.e = self.gatherInfo:Encode()
    tb.f = self.needgatherInfo:Encode()
    tb.g = self:_awardListEncode()
    if nil ~= self.isHasGetAward and 0 ~= self.isHasGetAward then
        tb.h = self.isHasGetAward
    end
    return tb
end

function MsgType.UserItemGatherInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.activityID = 0
    self.beginTime = 0
    self.endTime = 0
    self.gatherInfo = MsgType.ItemDisplayerInfo:New()
    self.needgatherInfo = MsgType.ItemDisplayerInfo:New()
    self.awardList = {}
    self.isHasGetAward = 0
    if nil ~= data.b then
        self.activityID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.beginTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.endTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.gatherInfo:Decode(data.e)
    end
    if nil ~= data.f then
        self.needgatherInfo:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpAwardListObj = MsgType.ItemDisplayerInfo:New()
            tmpAwardListObj:Decode(data.g[i])
            self.awardList[i] = tmpAwardListObj
        end
    end
    if nil ~= data.h then
        self.isHasGetAward = tonumber(data.h) or 0
    end
    return self
end

function MsgType.UserItemGatherInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGItemGatherActivityInfoRqst = {
    msgSeq = 0,
}
MsgType.CGItemGatherActivityInfoRqst.__index = MsgType.CGItemGatherActivityInfoRqst

function MsgType.CGItemGatherActivityInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGItemGatherActivityInfoRqst:GetCmd()
    return MsgTypeCmd.CG_ItemGatherActivityInfoRqst
end
function MsgType.CGItemGatherActivityInfoRqst:GetUrl()
    return "CGItemGatherActivityInfoRqst"
end
function MsgType.CGItemGatherActivityInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.CGItemGatherActivityInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGItemGatherActivityInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.WateredLevelRewardInfo = {
    levelid = 0,
    hasGetAward = 0
}
MsgType.WateredLevelRewardInfo.__index = MsgType.WateredLevelRewardInfo

function MsgType.WateredLevelRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WateredLevelRewardInfo:Encode()
    local tb = {}
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.b = self.levelid
    end
    if nil ~= self.hasGetAward and 0 ~= self.hasGetAward then
        tb.c = self.hasGetAward
    end
    return tb
end

function MsgType.WateredLevelRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelid = 0
    self.hasGetAward = 0
    if nil ~= data.b then
        self.levelid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.hasGetAward = tonumber(data.c) or 0
    end
    return self
end

function MsgType.WateredLevelRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.WateredRadishInfo = {
    beginTime = 0,
    endTime = 0,
    ap0LastTime = 0,
    levelid = 0,
    ap = 0,
    rewards = {}, -- array of MsgType.WateredLevelRewardInfo
    firstFlag = 0
}
MsgType.WateredRadishInfo.__index = MsgType.WateredRadishInfo

function MsgType.WateredRadishInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WateredRadishInfo:_rewardsEncode()
    local tb = {}
    for i=1, #self.rewards do
        tb[i] = self.rewards[i]:encode()
    end
    return tb
end
function MsgType.WateredRadishInfo:Encode()
    local tb = {}
    if nil ~= self.beginTime and 0 ~= self.beginTime then
        tb.b = self.beginTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.c = self.endTime
    end
    if nil ~= self.ap0LastTime and 0 ~= self.ap0LastTime then
        tb.d = self.ap0LastTime
    end
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.e = self.levelid
    end
    if nil ~= self.ap and 0 ~= self.ap then
        tb.f = self.ap
    end
    tb.g = self:_rewardsEncode()
    if nil ~= self.firstFlag and 0 ~= self.firstFlag then
        tb.h = self.firstFlag
    end
    return tb
end

function MsgType.WateredRadishInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.beginTime = 0
    self.endTime = 0
    self.ap0LastTime = 0
    self.levelid = 0
    self.ap = 0
    self.rewards = {}
    self.firstFlag = 0
    if nil ~= data.b then
        self.beginTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.endTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ap0LastTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.levelid = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.ap = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardsObj = MsgType.WateredLevelRewardInfo:New()
            tmpRewardsObj:Decode(data.g[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    if nil ~= data.h then
        self.firstFlag = tonumber(data.h) or 0
    end
    return self
end

function MsgType.WateredRadishInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGWateredRadishInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGWateredRadishInfoRqst.__index = MsgType.CGWateredRadishInfoRqst

function MsgType.CGWateredRadishInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGWateredRadishInfoRqst:GetCmd()
    return MsgTypeCmd.CG_WateredRadishInfoRqst
end
function MsgType.CGWateredRadishInfoRqst:GetUrl()
    return "CGWateredRadishInfoRqst"
end
function MsgType.CGWateredRadishInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGWateredRadishInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGWateredRadishInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.WateredRewardInfo = {
    levelid = 0,
    rewardStatus = 0,
    itemList = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.WateredRewardInfo.__index = MsgType.WateredRewardInfo

function MsgType.WateredRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WateredRewardInfo:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.WateredRewardInfo:Encode()
    local tb = {}
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.b = self.levelid
    end
    if nil ~= self.rewardStatus and 0 ~= self.rewardStatus then
        tb.c = self.rewardStatus
    end
    tb.d = self:_itemListEncode()
    return tb
end

function MsgType.WateredRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelid = 0
    self.rewardStatus = 0
    self.itemList = {}
    if nil ~= data.b then
        self.levelid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.rewardStatus = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpItemListObj = MsgType.ItemDisplayerInfo:New()
            tmpItemListObj:Decode(data.d[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end

function MsgType.WateredRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GCWateredRadishInfoRspd = {
    msgSeq = 0,
    errorCode = 0, --enum WateredOptCode
    isOpen = 0,
    remainTime = 0,
    levelid = 0,
    ap = 0,
    apRemainTime = 0,
    rewards = {}, -- array of MsgType.WateredRewardInfo
    firstFlag = 0
}
MsgType.GCWateredRadishInfoRspd.__index = MsgType.GCWateredRadishInfoRspd

function MsgType.GCWateredRadishInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCWateredRadishInfoRspd:GetCmd()
    return MsgTypeCmd.GC_WateredRadishInfoRspd
end
function MsgType.GCWateredRadishInfoRspd:GetUrl()
    return "GCWateredRadishInfoRspd"
end
function MsgType.GCWateredRadishInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.isOpen = 0
    self.remainTime = 0
    self.levelid = 0
    self.ap = 0
    self.apRemainTime = 0
    self.rewards = {}
    self.firstFlag = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isOpen = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.remainTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.levelid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.ap = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.apRemainTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardsObj = MsgType.WateredRewardInfo:New()
            tmpRewardsObj:Decode(data.i[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    if nil ~= data.j then
        self.firstFlag = tonumber(data.j) or 0
    end
    return self
end


MsgType.CGWateredRadishRewardRqst = {
    msgSeq = 0,
}
MsgType.CGWateredRadishRewardRqst.__index = MsgType.CGWateredRadishRewardRqst

function MsgType.CGWateredRadishRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGWateredRadishRewardRqst:GetCmd()
    return MsgTypeCmd.CG_WateredRadishRewardRqst
end
function MsgType.CGWateredRadishRewardRqst:GetUrl()
    return "CGWateredRadishRewardRqst"
end
function MsgType.CGWateredRadishRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.CGWateredRadishRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGWateredRadishRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCWateredRadishRewardRspd = {
    msgSeq = 0,
    errorCode = 0 --enum WateredOptCode
}
MsgType.GCWateredRadishRewardRspd.__index = MsgType.GCWateredRadishRewardRspd

function MsgType.GCWateredRadishRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCWateredRadishRewardRspd:GetCmd()
    return MsgTypeCmd.GC_WateredRadishRewardRspd
end
function MsgType.GCWateredRadishRewardRspd:GetUrl()
    return "GCWateredRadishRewardRspd"
end
function MsgType.GCWateredRadishRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGWateredRadishFlagRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGWateredRadishFlagRqst.__index = MsgType.CGWateredRadishFlagRqst

function MsgType.CGWateredRadishFlagRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGWateredRadishFlagRqst:GetCmd()
    return MsgTypeCmd.CG_WateredRadishFlagRqst
end
function MsgType.CGWateredRadishFlagRqst:GetUrl()
    return "CGWateredRadishFlagRqst"
end
function MsgType.CGWateredRadishFlagRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGWateredRadishFlagRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGWateredRadishFlagRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCWateredRadishFlagRspd = {
    msgSeq = 0,
    errorCode = 0 --enum WateredOptCode
}
MsgType.GCWateredRadishFlagRspd.__index = MsgType.GCWateredRadishFlagRspd

function MsgType.GCWateredRadishFlagRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCWateredRadishFlagRspd:GetCmd()
    return MsgTypeCmd.GC_WateredRadishFlagRspd
end
function MsgType.GCWateredRadishFlagRspd:GetUrl()
    return "GCWateredRadishFlagRspd"
end
function MsgType.GCWateredRadishFlagRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.ItemGatherInfo = {
    type = 0,
    num = 0
}
MsgType.ItemGatherInfo.__index = MsgType.ItemGatherInfo

function MsgType.ItemGatherInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemGatherInfo:Encode()
    local tb = {}
    if nil ~= self.type and 0 ~= self.type then
        tb.b = self.type
    end
    if nil ~= self.num and 0 ~= self.num then
        tb.c = self.num
    end
    return tb
end

function MsgType.ItemGatherInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.type = 0
    self.num = 0
    if nil ~= data.b then
        self.type = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.num = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ItemGatherInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GCItemGatherActivityInfoRspd = {
    msgSeq = 0,
    isSuccess = 0,
    errorCode = 0,
    remainTime = 0,
    isHasGetAward = 0,
    gatherInfo = {},
    needgatherInfo = {},
    awardList = {}, -- array of MsgType.ItemDisplayerInfo
    isOpen = 0
}
MsgType.GCItemGatherActivityInfoRspd.__index = MsgType.GCItemGatherActivityInfoRspd
setmetatable(MsgType.GCItemGatherActivityInfoRspd.gatherInfo, MsgType.ItemDisplayerInfo)
setmetatable(MsgType.GCItemGatherActivityInfoRspd.needgatherInfo, MsgType.ItemDisplayerInfo)

function MsgType.GCItemGatherActivityInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCItemGatherActivityInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ItemGatherActivityInfoRspd
end
function MsgType.GCItemGatherActivityInfoRspd:GetUrl()
    return "GCItemGatherActivityInfoRspd"
end
function MsgType.GCItemGatherActivityInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    self.errorCode = 0
    self.remainTime = 0
    self.isHasGetAward = 0
    self.gatherInfo = MsgType.ItemDisplayerInfo:New()
    self.needgatherInfo = MsgType.ItemDisplayerInfo:New()
    self.awardList = {}
    self.isOpen = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.remainTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isHasGetAward = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.gatherInfo:Decode(data.g)
    end
    if nil ~= data.h then
        self.needgatherInfo:Decode(data.h)
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpAwardListObj = MsgType.ItemDisplayerInfo:New()
            tmpAwardListObj:Decode(data.i[i])
            self.awardList[i] = tmpAwardListObj
        end
    end
    if nil ~= data.j then
        self.isOpen = tonumber(data.j) or 0
    end
    return self
end


MsgType.CGItemGatherGetAwardRqst = {
    msgSeq = 0,
}
MsgType.CGItemGatherGetAwardRqst.__index = MsgType.CGItemGatherGetAwardRqst

function MsgType.CGItemGatherGetAwardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGItemGatherGetAwardRqst:GetCmd()
    return MsgTypeCmd.CG_ItemGatherGetAwardRqst
end
function MsgType.CGItemGatherGetAwardRqst:GetUrl()
    return "CGItemGatherGetAwardRqst"
end
function MsgType.CGItemGatherGetAwardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.CGItemGatherGetAwardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGItemGatherGetAwardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCItemGatherGetAwardRspd = {
    msgSeq = 0,
    isSuccess = 0,
    errorCode = 0
}
MsgType.GCItemGatherGetAwardRspd.__index = MsgType.GCItemGatherGetAwardRspd

function MsgType.GCItemGatherGetAwardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCItemGatherGetAwardRspd:GetCmd()
    return MsgTypeCmd.GC_ItemGatherGetAwardRspd
end
function MsgType.GCItemGatherGetAwardRspd:GetUrl()
    return "GCItemGatherGetAwardRspd"
end
function MsgType.GCItemGatherGetAwardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.PetActivityData = {
    roleUID = 0,
    endTime = 0,
    passCount = 0,
    gotRewardIDList = {} -- array of number
}
MsgType.PetActivityData.__index = MsgType.PetActivityData

function MsgType.PetActivityData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetActivityData:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.c = self.endTime
    end
    if nil ~= self.passCount and 0 ~= self.passCount then
        tb.d = self.passCount
    end
    if nil ~= self.gotRewardIDList and string.len(self.gotRewardIDList) > 0 then
        tb.e = self.gotRewardIDList
    end
    return tb
end

function MsgType.PetActivityData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.endTime = 0
    self.passCount = 0
    self.gotRewardIDList = {}
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.endTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.passCount = tonumber(data.d) or 0
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.gotRewardIDList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.PetActivityData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PetActivityReward = {
    id = 0,
    condition = 0,
    rewardIDList = {}, -- array of number
    rewardNumberList = {} -- array of number
}
MsgType.PetActivityReward.__index = MsgType.PetActivityReward

function MsgType.PetActivityReward:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PetActivityReward:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.condition and 0 ~= self.condition then
        tb.c = self.condition
    end
    if nil ~= self.rewardIDList and string.len(self.rewardIDList) > 0 then
        tb.d = self.rewardIDList
    end
    if nil ~= self.rewardNumberList and string.len(self.rewardNumberList) > 0 then
        tb.e = self.rewardNumberList
    end
    return tb
end

function MsgType.PetActivityReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.id = 0
    self.condition = 0
    self.rewardIDList = {}
    self.rewardNumberList = {}
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.condition = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.rewardIDList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.rewardNumberList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.PetActivityReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGPetActivityEnterInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPetActivityEnterInfoRqst.__index = MsgType.CGPetActivityEnterInfoRqst

function MsgType.CGPetActivityEnterInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetActivityEnterInfoRqst:GetCmd()
    return MsgTypeCmd.CG_PetActivityEnterInfoRqst
end
function MsgType.CGPetActivityEnterInfoRqst:GetUrl()
    return "CGPetActivityEnterInfoRqst"
end
function MsgType.CGPetActivityEnterInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPetActivityEnterInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetActivityEnterInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetActivityEnterInfoRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    isOpen = false,
    remainingTime = 0
}
MsgType.GCPetActivityEnterInfoRspd.__index = MsgType.GCPetActivityEnterInfoRspd

function MsgType.GCPetActivityEnterInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetActivityEnterInfoRspd:GetCmd()
    return MsgTypeCmd.GC_PetActivityEnterInfoRspd
end
function MsgType.GCPetActivityEnterInfoRspd:GetUrl()
    return "GCPetActivityEnterInfoRspd"
end
function MsgType.GCPetActivityEnterInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.isOpen = false
    self.remainingTime = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isOpen = data.e
    end
    if nil ~= data.f then
        self.remainingTime = tonumber(data.f) or 0
    end
    return self
end


MsgType.CGPetActivityPlayerInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGPetActivityPlayerInfoRqst.__index = MsgType.CGPetActivityPlayerInfoRqst

function MsgType.CGPetActivityPlayerInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetActivityPlayerInfoRqst:GetCmd()
    return MsgTypeCmd.CG_PetActivityPlayerInfoRqst
end
function MsgType.CGPetActivityPlayerInfoRqst:GetUrl()
    return "CGPetActivityPlayerInfoRqst"
end
function MsgType.CGPetActivityPlayerInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGPetActivityPlayerInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetActivityPlayerInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetActivityPlayerInfoRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    petActivityInfo = {},
    rewardList = {} -- array of MsgType.PetActivityReward
}
MsgType.GCPetActivityPlayerInfoRspd.__index = MsgType.GCPetActivityPlayerInfoRspd
setmetatable(MsgType.GCPetActivityPlayerInfoRspd.petActivityInfo, MsgType.PetActivityData)

function MsgType.GCPetActivityPlayerInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetActivityPlayerInfoRspd:GetCmd()
    return MsgTypeCmd.GC_PetActivityPlayerInfoRspd
end
function MsgType.GCPetActivityPlayerInfoRspd:GetUrl()
    return "GCPetActivityPlayerInfoRspd"
end
function MsgType.GCPetActivityPlayerInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.petActivityInfo = MsgType.PetActivityData:New()
    self.rewardList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.petActivityInfo:Decode(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.PetActivityReward:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.CGPetActivityRewardRqst = {
    msgSeq = 0,
    rewardID = 0
}
MsgType.CGPetActivityRewardRqst.__index = MsgType.CGPetActivityRewardRqst

function MsgType.CGPetActivityRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGPetActivityRewardRqst:GetCmd()
    return MsgTypeCmd.CG_PetActivityRewardRqst
end
function MsgType.CGPetActivityRewardRqst:GetUrl()
    return "CGPetActivityRewardRqst"
end
function MsgType.CGPetActivityRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rewardID and 0 ~= self.rewardID then
        tb.c = self.rewardID
    end
    return tb
end

function MsgType.CGPetActivityRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGPetActivityRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCPetActivityRewardRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    isGetSuccess = false,
    petActivityInfo = {}
}
MsgType.GCPetActivityRewardRspd.__index = MsgType.GCPetActivityRewardRspd
setmetatable(MsgType.GCPetActivityRewardRspd.petActivityInfo, MsgType.PetActivityData)

function MsgType.GCPetActivityRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCPetActivityRewardRspd:GetCmd()
    return MsgTypeCmd.GC_PetActivityRewardRspd
end
function MsgType.GCPetActivityRewardRspd:GetUrl()
    return "GCPetActivityRewardRspd"
end
function MsgType.GCPetActivityRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.isGetSuccess = false
    self.petActivityInfo = MsgType.PetActivityData:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isGetSuccess = data.e
    end
    if nil ~= data.f then
        self.petActivityInfo:Decode(data.f)
    end
    return self
end


MsgType.AllActivityData = {
    roleUID = 0,
    activityDataList = {} -- array of MsgType.OneActivityData
}
MsgType.AllActivityData.__index = MsgType.AllActivityData

function MsgType.AllActivityData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AllActivityData:_activityDataListEncode()
    local tb = {}
    for i=1, #self.activityDataList do
        tb[i] = self.activityDataList[i]:encode()
    end
    return tb
end
function MsgType.AllActivityData:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    tb.c = self:_activityDataListEncode()
    return tb
end

function MsgType.AllActivityData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.activityDataList = {}
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpActivityDataListObj = MsgType.OneActivityData:New()
            tmpActivityDataListObj:Decode(data.c[i])
            self.activityDataList[i] = tmpActivityDataListObj
        end
    end
    return self
end

function MsgType.AllActivityData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.OneActivityData = {
    type = 0,
    secondType = 0,
    endTime = 0,
    isFirstIn = false,
    clothesNo = 0,
    lastClothesNo = 0,
    gotRewardIDList = {}, -- array of number
    rewardStatusList = {} -- array of MsgType.RewardStatus
}
MsgType.OneActivityData.__index = MsgType.OneActivityData

function MsgType.OneActivityData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneActivityData:_rewardStatusListEncode()
    local tb = {}
    for i=1, #self.rewardStatusList do
        tb[i] = self.rewardStatusList[i]:encode()
    end
    return tb
end
function MsgType.OneActivityData:Encode()
    local tb = {}
    if nil ~= self.type and 0 ~= self.type then
        tb.b = self.type
    end
    if nil ~= self.secondType and 0 ~= self.secondType then
        tb.c = self.secondType
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.d = self.endTime
    end
    if self.isFirstIn then
        tb.e = self.isFirstIn
    end
    if nil ~= self.clothesNo and 0 ~= self.clothesNo then
        tb.f = self.clothesNo
    end
    if nil ~= self.lastClothesNo and 0 ~= self.lastClothesNo then
        tb.g = self.lastClothesNo
    end
    if nil ~= self.gotRewardIDList and string.len(self.gotRewardIDList) > 0 then
        tb.h = self.gotRewardIDList
    end
    tb.i = self:_rewardStatusListEncode()
    return tb
end

function MsgType.OneActivityData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.type = 0
    self.secondType = 0
    self.endTime = 0
    self.isFirstIn = false
    self.clothesNo = 0
    self.lastClothesNo = 0
    self.gotRewardIDList = {}
    self.rewardStatusList = {}
    if nil ~= data.b then
        self.type = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.secondType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.endTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isFirstIn = data.e
    end
    if nil ~= data.f then
        self.clothesNo = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.lastClothesNo = tonumber(data.g) or 0
    end
    if nil ~= data.h and #data.h > 0 then
        for i=1, #data.h do
            self.gotRewardIDList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardStatusListObj = MsgType.RewardStatus:New()
            tmpRewardStatusListObj:Decode(data.i[i])
            self.rewardStatusList[i] = tmpRewardStatusListObj
        end
    end
    return self
end

function MsgType.OneActivityData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.RewardStatus = {
    suit = 0,
    count = 0
}
MsgType.RewardStatus.__index = MsgType.RewardStatus

function MsgType.RewardStatus:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RewardStatus:Encode()
    local tb = {}
    if nil ~= self.suit and 0 ~= self.suit then
        tb.b = self.suit
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.RewardStatus:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.suit = 0
    self.count = 0
    if nil ~= data.b then
        self.suit = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.RewardStatus:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGActivityOpenInfoRqst = {
    msgSeq = 0,
    type = 0
}
MsgType.CGActivityOpenInfoRqst.__index = MsgType.CGActivityOpenInfoRqst

function MsgType.CGActivityOpenInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActivityOpenInfoRqst:GetCmd()
    return MsgTypeCmd.CG_ActivityOpenInfoRqst
end
function MsgType.CGActivityOpenInfoRqst:GetUrl()
    return "CGActivityOpenInfoRqst"
end
function MsgType.CGActivityOpenInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.CGActivityOpenInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActivityOpenInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActivityOpenInfoRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EActivityOptCode
    isOpen = false,
    remainingTime = 0,
    isCoinOpen = false,
    coinRemainingTime = 0,
    type = 0 --enum EActivityType
}
MsgType.GCActivityOpenInfoRspd.__index = MsgType.GCActivityOpenInfoRspd

function MsgType.GCActivityOpenInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActivityOpenInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ActivityOpenInfoRspd
end
function MsgType.GCActivityOpenInfoRspd:GetUrl()
    return "GCActivityOpenInfoRspd"
end
function MsgType.GCActivityOpenInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.isOpen = false
    self.remainingTime = 0
    self.isCoinOpen = false
    self.coinRemainingTime = 0
    self.type = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isOpen = data.d
    end
    if nil ~= data.e then
        self.remainingTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isCoinOpen = data.f
    end
    if nil ~= data.g then
        self.coinRemainingTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.type = tonumber(data.h) or 0
    end
    return self
end


MsgType.CGActivityPlayerInfoRqst = {
    msgSeq = 0,
    nouse = 0,
    type = 0
}
MsgType.CGActivityPlayerInfoRqst.__index = MsgType.CGActivityPlayerInfoRqst

function MsgType.CGActivityPlayerInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActivityPlayerInfoRqst:GetCmd()
    return MsgTypeCmd.CG_ActivityPlayerInfoRqst
end
function MsgType.CGActivityPlayerInfoRqst:GetUrl()
    return "CGActivityPlayerInfoRqst"
end
function MsgType.CGActivityPlayerInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    return tb
end

function MsgType.CGActivityPlayerInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActivityPlayerInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActivityPlayerInfoRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EActivityOptCode
    activityData = {}
}
MsgType.GCActivityPlayerInfoRspd.__index = MsgType.GCActivityPlayerInfoRspd
setmetatable(MsgType.GCActivityPlayerInfoRspd.activityData, MsgType.OneActivityData)

function MsgType.GCActivityPlayerInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActivityPlayerInfoRspd:GetCmd()
    return MsgTypeCmd.GC_ActivityPlayerInfoRspd
end
function MsgType.GCActivityPlayerInfoRspd:GetUrl()
    return "GCActivityPlayerInfoRspd"
end
function MsgType.GCActivityPlayerInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.activityData = MsgType.OneActivityData:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.activityData:Decode(data.d)
    end
    return self
end


MsgType.CGActivityBuyRqst = {
    msgSeq = 0,
    itemID = 0,
    type = 0
}
MsgType.CGActivityBuyRqst.__index = MsgType.CGActivityBuyRqst

function MsgType.CGActivityBuyRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActivityBuyRqst:GetCmd()
    return MsgTypeCmd.CG_ActivityBuyRqst
end
function MsgType.CGActivityBuyRqst:GetUrl()
    return "CGActivityBuyRqst"
end
function MsgType.CGActivityBuyRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemID and 0 ~= self.itemID then
        tb.c = self.itemID
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    return tb
end

function MsgType.CGActivityBuyRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActivityBuyRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActivityBuyRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EActivityOptCode
    isBuySuccess = false
}
MsgType.GCActivityBuyRspd.__index = MsgType.GCActivityBuyRspd

function MsgType.GCActivityBuyRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActivityBuyRspd:GetCmd()
    return MsgTypeCmd.GC_ActivityBuyRspd
end
function MsgType.GCActivityBuyRspd:GetUrl()
    return "GCActivityBuyRspd"
end
function MsgType.GCActivityBuyRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.isBuySuccess = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isBuySuccess = data.d
    end
    return self
end


MsgType.CGActivityLevelFinishRqst = {
    msgSeq = 0,
    type = 0,
    levelID = 0
}
MsgType.CGActivityLevelFinishRqst.__index = MsgType.CGActivityLevelFinishRqst

function MsgType.CGActivityLevelFinishRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGActivityLevelFinishRqst:GetCmd()
    return MsgTypeCmd.CG_ActivityLevelFinishRqst
end
function MsgType.CGActivityLevelFinishRqst:GetUrl()
    return "CGActivityLevelFinishRqst"
end
function MsgType.CGActivityLevelFinishRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.d = self.levelID
    end
    return tb
end

function MsgType.CGActivityLevelFinishRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGActivityLevelFinishRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCActivityLevelFinishRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EActivityOptCode
    isFinishSuccess = false
}
MsgType.GCActivityLevelFinishRspd.__index = MsgType.GCActivityLevelFinishRspd

function MsgType.GCActivityLevelFinishRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCActivityLevelFinishRspd:GetCmd()
    return MsgTypeCmd.GC_ActivityLevelFinishRspd
end
function MsgType.GCActivityLevelFinishRspd:GetUrl()
    return "GCActivityLevelFinishRspd"
end
function MsgType.GCActivityLevelFinishRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.isFinishSuccess = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isFinishSuccess = data.d
    end
    return self
end


MsgType.CGGetAllActivityInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGGetAllActivityInfoRqst.__index = MsgType.CGGetAllActivityInfoRqst

function MsgType.CGGetAllActivityInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGGetAllActivityInfoRqst:GetCmd()
    return MsgTypeCmd.CG_GetAllActivityInfoRqst
end
function MsgType.CGGetAllActivityInfoRqst:GetUrl()
    return "CGGetAllActivityInfoRqst"
end
function MsgType.CGGetAllActivityInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGGetAllActivityInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGGetAllActivityInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.CoinTaskInDB = {
    taskID = 0,
    taskStep = 0
}
MsgType.CoinTaskInDB.__index = MsgType.CoinTaskInDB

function MsgType.CoinTaskInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CoinTaskInDB:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.taskStep and 0 ~= self.taskStep then
        tb.c = self.taskStep
    end
    return tb
end

function MsgType.CoinTaskInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.taskStep = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskStep = tonumber(data.c) or 0
    end
    return self
end

function MsgType.CoinTaskInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CoinDataInDB = {
}

MsgType.CoinTask = {
    taskID = 0,
    taskType = 0,
    taskTarget = 0,
    taskPriority = 0,
    taskLanguage = 0,
    taskStep = 0
}
MsgType.CoinTask.__index = MsgType.CoinTask

function MsgType.CoinTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CoinTask:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.taskType and 0 ~= self.taskType then
        tb.c = self.taskType
    end
    if nil ~= self.taskTarget and 0 ~= self.taskTarget then
        tb.d = self.taskTarget
    end
    if nil ~= self.taskPriority and 0 ~= self.taskPriority then
        tb.e = self.taskPriority
    end
    if nil ~= self.taskLanguage and 0 ~= self.taskLanguage then
        tb.f = self.taskLanguage
    end
    if nil ~= self.taskStep and 0 ~= self.taskStep then
        tb.g = self.taskStep
    end
    return tb
end

function MsgType.CoinTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.taskType = 0
    self.taskTarget = 0
    self.taskPriority = 0
    self.taskLanguage = 0
    self.taskStep = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskTarget = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.taskPriority = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.taskLanguage = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskStep = tonumber(data.g) or 0
    end
    return self
end

function MsgType.CoinTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGCoinActivityInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGCoinActivityInfoRqst.__index = MsgType.CGCoinActivityInfoRqst

function MsgType.CGCoinActivityInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCoinActivityInfoRqst:GetCmd()
    return MsgTypeCmd.CG_CoinActivityInfoRqst
end
function MsgType.CGCoinActivityInfoRqst:GetUrl()
    return "CGCoinActivityInfoRqst"
end
function MsgType.CGCoinActivityInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGCoinActivityInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCoinActivityInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCoinActivityInfoRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    isOpen = false,
    keyCount = 0,
    taskList = {} -- array of MsgType.CoinTask
}
MsgType.GCCoinActivityInfoRspd.__index = MsgType.GCCoinActivityInfoRspd

function MsgType.GCCoinActivityInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCoinActivityInfoRspd:GetCmd()
    return MsgTypeCmd.GC_CoinActivityInfoRspd
end
function MsgType.GCCoinActivityInfoRspd:GetUrl()
    return "GCCoinActivityInfoRspd"
end
function MsgType.GCCoinActivityInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.isOpen = false
    self.keyCount = 0
    self.taskList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isOpen = data.e
    end
    if nil ~= data.f then
        self.keyCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpTaskListObj = MsgType.CoinTask:New()
            tmpTaskListObj:Decode(data.g[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end


MsgType.CGCoinEnterRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGCoinEnterRqst.__index = MsgType.CGCoinEnterRqst

function MsgType.CGCoinEnterRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCoinEnterRqst:GetCmd()
    return MsgTypeCmd.CG_CoinEnterRqst
end
function MsgType.CGCoinEnterRqst:GetUrl()
    return "CGCoinEnterRqst"
end
function MsgType.CGCoinEnterRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGCoinEnterRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCoinEnterRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCoinEnterRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.GCCoinEnterRspd.__index = MsgType.GCCoinEnterRspd

function MsgType.GCCoinEnterRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCoinEnterRspd:GetCmd()
    return MsgTypeCmd.GC_CoinEnterRspd
end
function MsgType.GCCoinEnterRspd:GetUrl()
    return "GCCoinEnterRspd"
end
function MsgType.GCCoinEnterRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.CGCoinFinishedRqst = {
    msgSeq = 0,
    nouse = 0,
    isSuccess = false
}
MsgType.CGCoinFinishedRqst.__index = MsgType.CGCoinFinishedRqst

function MsgType.CGCoinFinishedRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCoinFinishedRqst:GetCmd()
    return MsgTypeCmd.CG_CoinFinishedRqst
end
function MsgType.CGCoinFinishedRqst:GetUrl()
    return "CGCoinFinishedRqst"
end
function MsgType.CGCoinFinishedRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    if self.isSuccess then
        tb.d = self.isSuccess
    end
    return tb
end

function MsgType.CGCoinFinishedRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCoinFinishedRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCoinFinishedRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    coinNum = "",
    goldNum = 0
}
MsgType.GCCoinFinishedRspd.__index = MsgType.GCCoinFinishedRspd

function MsgType.GCCoinFinishedRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCoinFinishedRspd:GetCmd()
    return MsgTypeCmd.GC_CoinFinishedRspd
end
function MsgType.GCCoinFinishedRspd:GetUrl()
    return "GCCoinFinishedRspd"
end
function MsgType.GCCoinFinishedRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.coinNum = ""
    self.goldNum = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.coinNum = tostring(data.e)
    end
    if nil ~= data.f then
        self.goldNum = tonumber(data.f) or 0
    end
    return self
end


MsgType.AdDataInDB = {
    curCount = 0,
    refreshTime = 0
}
MsgType.AdDataInDB.__index = MsgType.AdDataInDB

function MsgType.AdDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.AdDataInDB:Encode()
    local tb = {}
    if nil ~= self.curCount and 0 ~= self.curCount then
        tb.b = self.curCount
    end
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.c = self.refreshTime
    end
    return tb
end

function MsgType.AdDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curCount = 0
    self.refreshTime = 0
    if nil ~= data.b then
        self.curCount = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.refreshTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.AdDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ItemInAdReward = {
    itemID = 0,
    itemNum = 0
}
MsgType.ItemInAdReward.__index = MsgType.ItemInAdReward

function MsgType.ItemInAdReward:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ItemInAdReward:Encode()
    local tb = {}
    if nil ~= self.itemID and 0 ~= self.itemID then
        tb.b = self.itemID
    end
    if nil ~= self.itemNum and 0 ~= self.itemNum then
        tb.c = self.itemNum
    end
    return tb
end

function MsgType.ItemInAdReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemID = 0
    self.itemNum = 0
    if nil ~= data.b then
        self.itemID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemNum = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ItemInAdReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGAdInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGAdInfoRqst.__index = MsgType.CGAdInfoRqst

function MsgType.CGAdInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAdInfoRqst:GetCmd()
    return MsgTypeCmd.CG_AdInfoRqst
end
function MsgType.CGAdInfoRqst:GetUrl()
    return "CGAdInfoRqst"
end
function MsgType.CGAdInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGAdInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAdInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAdInfoRspd = {
    msgSeq = 0,
    curCount = 0,
    maxCount = 0,
    rewardItem = {}
}
MsgType.GCAdInfoRspd.__index = MsgType.GCAdInfoRspd
setmetatable(MsgType.GCAdInfoRspd.rewardItem, MsgType.ItemInAdReward)

function MsgType.GCAdInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAdInfoRspd:GetCmd()
    return MsgTypeCmd.GC_AdInfoRspd
end
function MsgType.GCAdInfoRspd:GetUrl()
    return "GCAdInfoRspd"
end
function MsgType.GCAdInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.curCount = 0
    self.maxCount = 0
    self.rewardItem = MsgType.ItemInAdReward:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.curCount = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.maxCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.rewardItem:Decode(data.e)
    end
    return self
end


MsgType.CGAdRewardRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGAdRewardRqst.__index = MsgType.CGAdRewardRqst

function MsgType.CGAdRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAdRewardRqst:GetCmd()
    return MsgTypeCmd.CG_AdRewardRqst
end
function MsgType.CGAdRewardRqst:GetUrl()
    return "CGAdRewardRqst"
end
function MsgType.CGAdRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGAdRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAdRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAdRewardRspd = {
    msgSeq = 0,
    errorCode = 0,
    curCount = 0,
    maxCount = 0,
    rewardItem = {}
}
MsgType.GCAdRewardRspd.__index = MsgType.GCAdRewardRspd
setmetatable(MsgType.GCAdRewardRspd.rewardItem, MsgType.ItemInAdReward)

function MsgType.GCAdRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAdRewardRspd:GetCmd()
    return MsgTypeCmd.GC_AdRewardRspd
end
function MsgType.GCAdRewardRspd:GetUrl()
    return "GCAdRewardRspd"
end
function MsgType.GCAdRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.curCount = 0
    self.maxCount = 0
    self.rewardItem = MsgType.ItemInAdReward:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.curCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.maxCount = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.CGCoinTaskEventRqst = {
    msgSeq = 0,
    taskType = 0, --enum ECoinTaskType
    taskParam = 0
}
MsgType.CGCoinTaskEventRqst.__index = MsgType.CGCoinTaskEventRqst

function MsgType.CGCoinTaskEventRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCoinTaskEventRqst:GetCmd()
    return MsgTypeCmd.CG_CoinTaskEventRqst
end
function MsgType.CGCoinTaskEventRqst:GetUrl()
    return "CGCoinTaskEventRqst"
end
function MsgType.CGCoinTaskEventRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskType and 0 ~= self.taskType then
        tb.c = self.taskType
    end
    if nil ~= self.taskParam and 0 ~= self.taskParam then
        tb.d = self.taskParam
    end
    return tb
end

function MsgType.CGCoinTaskEventRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCoinTaskEventRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCoinTaskEventRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCCoinTaskEventRspd.__index = MsgType.GCCoinTaskEventRspd

function MsgType.GCCoinTaskEventRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCoinTaskEventRspd:GetCmd()
    return MsgTypeCmd.GC_CoinTaskEventRspd
end
function MsgType.GCCoinTaskEventRspd:GetUrl()
    return "GCCoinTaskEventRspd"
end
function MsgType.GCCoinTaskEventRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGCoinOpenBoxRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGCoinOpenBoxRqst.__index = MsgType.CGCoinOpenBoxRqst

function MsgType.CGCoinOpenBoxRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGCoinOpenBoxRqst:GetCmd()
    return MsgTypeCmd.CG_CoinOpenBoxRqst
end
function MsgType.CGCoinOpenBoxRqst:GetUrl()
    return "CGCoinOpenBoxRqst"
end
function MsgType.CGCoinOpenBoxRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGCoinOpenBoxRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGCoinOpenBoxRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCCoinOpenBoxRspd = {
    msgSeq = 0,
    errorCode = 0,
    coinNum = ""
}
MsgType.GCCoinOpenBoxRspd.__index = MsgType.GCCoinOpenBoxRspd

function MsgType.GCCoinOpenBoxRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCCoinOpenBoxRspd:GetCmd()
    return MsgTypeCmd.GC_CoinOpenBoxRspd
end
function MsgType.GCCoinOpenBoxRspd:GetUrl()
    return "GCCoinOpenBoxRspd"
end
function MsgType.GCCoinOpenBoxRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.coinNum = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.coinNum = tostring(data.d)
    end
    return self
end


MsgType.GMPingRqst = {
    msgSeq = 0,
    ping = 0,
    admin = ""
}
MsgType.GMPingRqst.__index = MsgType.GMPingRqst

function MsgType.GMPingRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMPingRqst:GetCmd()
    return MsgTypeCmd.GM_PingRqst
end
function MsgType.GMPingRqst:GetUrl()
    return "GMPingRqst"
end
function MsgType.GMPingRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ping = 0
    self.admin = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.ping = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.admin = tostring(data.d)
    end
    return self
end


MsgType.MonitorWork = {
    serverType = "",
    groupID = 0,
    serverID = 0,
    status = 0,
    pid = 0,
    onlineNum = 0,
    startTime = "",
    startTimes = 0
}
MsgType.MonitorWork.__index = MsgType.MonitorWork

function MsgType.MonitorWork:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorWork:Encode()
    local tb = {}
    if nil ~= self.serverType and string.len(self.serverType) > 0 then
        tb.b = self.serverType
    end
    if nil ~= self.groupID and 0 ~= self.groupID then
        tb.c = self.groupID
    end
    if nil ~= self.serverID and 0 ~= self.serverID then
        tb.d = self.serverID
    end
    if nil ~= self.status and 0 ~= self.status then
        tb.e = self.status
    end
    if nil ~= self.pid and 0 ~= self.pid then
        tb.f = self.pid
    end
    if nil ~= self.onlineNum and 0 ~= self.onlineNum then
        tb.g = self.onlineNum
    end
    if nil ~= self.startTime and string.len(self.startTime) > 0 then
        tb.h = self.startTime
    end
    if nil ~= self.startTimes and 0 ~= self.startTimes then
        tb.i = self.startTimes
    end
    return tb
end

function MsgType.MonitorWork:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.serverType = ""
    self.groupID = 0
    self.serverID = 0
    self.status = 0
    self.pid = 0
    self.onlineNum = 0
    self.startTime = ""
    self.startTimes = 0
    if nil ~= data.b then
        self.serverType = tostring(data.b)
    end
    if nil ~= data.c then
        self.groupID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.serverID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.status = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.pid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.onlineNum = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.startTime = tostring(data.h)
    end
    if nil ~= data.i then
        self.startTimes = tonumber(data.i) or 0
    end
    return self
end

function MsgType.MonitorWork:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MonitorData = {
    msgSeq = 0,
    name = "",
    path = "",
    serverConfig = "",
    onlineNum = 0,
    workList = {} -- array of MsgType.MonitorWork
}
MsgType.MonitorData.__index = MsgType.MonitorData

function MsgType.MonitorData:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MonitorData:GetCmd()
    return MsgTypeCmd.MG_PingRspd
end
function MsgType.MonitorData:GetUrl()
    return "MonitorData"
end
function MsgType.MonitorData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.name = ""
    self.path = ""
    self.serverConfig = ""
    self.onlineNum = 0
    self.workList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.name = tostring(data.c)
    end
    if nil ~= data.d then
        self.path = tostring(data.d)
    end
    if nil ~= data.e then
        self.serverConfig = tostring(data.e)
    end
    if nil ~= data.f then
        self.onlineNum = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpWorkListObj = MsgType.MonitorWork:New()
            tmpWorkListObj:Decode(data.g[i])
            self.workList[i] = tmpWorkListObj
        end
    end
    return self
end


MsgType.MGPingRspd = {
    msgSeq = 0,
    pong = 0,
    onlineNum = 0,
    monitorList = {} -- array of MsgType.MonitorData
}
MsgType.MGPingRspd.__index = MsgType.MGPingRspd

function MsgType.MGPingRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGPingRspd:GetCmd()
    return MsgTypeCmd.MG_PingRspd
end
function MsgType.MGPingRspd:GetUrl()
    return "MGPingRspd"
end
function MsgType.MGPingRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.pong = 0
    self.onlineNum = 0
    self.monitorList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.pong = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.onlineNum = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpMonitorListObj = MsgType.MonitorData:New()
            tmpMonitorListObj:Decode(data.e[i])
            self.monitorList[i] = tmpMonitorListObj
        end
    end
    return self
end


MsgType.GMOneItem = {
    itemType = 0,
    count = 0
}
MsgType.GMOneItem.__index = MsgType.GMOneItem

function MsgType.GMOneItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GMOneItem:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.GMOneItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.GMOneItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GMAddItemRqst = {
    msgSeq = 0,
    groupID = 0,
    roleUIDList = {}, -- array of number
    itemList = {} -- array of MsgType.GMOneItem
}
MsgType.GMAddItemRqst.__index = MsgType.GMAddItemRqst

function MsgType.GMAddItemRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMAddItemRqst:GetCmd()
    return MsgTypeCmd.GM_AddItemRqst
end
function MsgType.GMAddItemRqst:GetUrl()
    return "GMAddItemRqst"
end
function MsgType.GMAddItemRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupID = 0
    self.roleUIDList = {}
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupID = tonumber(data.c) or 0
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.roleUIDList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpItemListObj = MsgType.GMOneItem:New()
            tmpItemListObj:Decode(data.e[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.MGAddItemRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGAddItemRspd.__index = MsgType.MGAddItemRspd

function MsgType.MGAddItemRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGAddItemRspd:GetCmd()
    return MsgTypeCmd.MG_AddItemRspd
end
function MsgType.MGAddItemRspd:GetUrl()
    return "MGAddItemRspd"
end
function MsgType.MGAddItemRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.CItemInMailAttachment = {
    itemType = 0,
    count = 0
}
MsgType.CItemInMailAttachment.__index = MsgType.CItemInMailAttachment

function MsgType.CItemInMailAttachment:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CItemInMailAttachment:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    return tb
end

function MsgType.CItemInMailAttachment:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.itemType = 0
    self.count = 0
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    return self
end

function MsgType.CItemInMailAttachment:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GMSendMailRqst = {
    msgSeq = 0,
    groupID = 0,
    mailReason = 0,
    mailTitle = "",
    mailContent = "",
    roleUIDList = {}, -- array of number
    itemList = {} -- array of MsgType.CItemInMailAttachment
}
MsgType.GMSendMailRqst.__index = MsgType.GMSendMailRqst

function MsgType.GMSendMailRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMSendMailRqst:GetCmd()
    return MsgTypeCmd.GM_SendMailRqst
end
function MsgType.GMSendMailRqst:GetUrl()
    return "GMSendMailRqst"
end
function MsgType.GMSendMailRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupID = 0
    self.mailReason = 0
    self.mailTitle = ""
    self.mailContent = ""
    self.roleUIDList = {}
    self.itemList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.mailReason = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.mailTitle = tostring(data.e)
    end
    if nil ~= data.f then
        self.mailContent = tostring(data.f)
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.roleUIDList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpItemListObj = MsgType.CItemInMailAttachment:New()
            tmpItemListObj:Decode(data.h[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.MGSendMailRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGSendMailRspd.__index = MsgType.MGSendMailRspd

function MsgType.MGSendMailRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGSendMailRspd:GetCmd()
    return MsgTypeCmd.MG_SendMailRspd
end
function MsgType.MGSendMailRspd:GetUrl()
    return "MGSendMailRspd"
end
function MsgType.MGSendMailRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMQueryServerConfigRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.GMQueryServerConfigRqst.__index = MsgType.GMQueryServerConfigRqst

function MsgType.GMQueryServerConfigRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMQueryServerConfigRqst:GetCmd()
    return MsgTypeCmd.GM_QueryServerConfigRqst
end
function MsgType.GMQueryServerConfigRqst:GetUrl()
    return "GMQueryServerConfigRqst"
end
function MsgType.GMQueryServerConfigRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.MGQueryServerConfigRspd = {
    msgSeq = 0,
    serverConfig = ""
}
MsgType.MGQueryServerConfigRspd.__index = MsgType.MGQueryServerConfigRspd

function MsgType.MGQueryServerConfigRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGQueryServerConfigRspd:GetCmd()
    return MsgTypeCmd.MG_QueryServerConfigRspd
end
function MsgType.MGQueryServerConfigRspd:GetUrl()
    return "MGQueryServerConfigRspd"
end
function MsgType.MGQueryServerConfigRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.serverConfig = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.serverConfig = tostring(data.c)
    end
    return self
end


MsgType.EMonitorOptType = {
    AddServer = 1,
    DelServer = 2,
    StartServer = 3,
    StopServer = 4
}

MsgType.MonitorOptData = {
    monitorPath = "",
    serverType = "",
    groupID = 0,
    serverID = 0
}
MsgType.MonitorOptData.__index = MsgType.MonitorOptData

function MsgType.MonitorOptData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorOptData:Encode()
    local tb = {}
    if nil ~= self.monitorPath and string.len(self.monitorPath) > 0 then
        tb.b = self.monitorPath
    end
    if nil ~= self.serverType and string.len(self.serverType) > 0 then
        tb.c = self.serverType
    end
    if nil ~= self.groupID and 0 ~= self.groupID then
        tb.d = self.groupID
    end
    if nil ~= self.serverID and 0 ~= self.serverID then
        tb.e = self.serverID
    end
    return tb
end

function MsgType.MonitorOptData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.monitorPath = ""
    self.serverType = ""
    self.groupID = 0
    self.serverID = 0
    if nil ~= data.b then
        self.monitorPath = tostring(data.b)
    end
    if nil ~= data.c then
        self.serverType = tostring(data.c)
    end
    if nil ~= data.d then
        self.groupID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.serverID = tonumber(data.e) or 0
    end
    return self
end

function MsgType.MonitorOptData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GMMonitorOptRqst = {
    msgSeq = 0,
    optType = 0, --enum EMonitorOptType
    serverList = {} -- array of MsgType.MonitorOptData
}
MsgType.GMMonitorOptRqst.__index = MsgType.GMMonitorOptRqst

function MsgType.GMMonitorOptRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMMonitorOptRqst:GetCmd()
    return MsgTypeCmd.GM_MonitorOptRqst
end
function MsgType.GMMonitorOptRqst:GetUrl()
    return "GMMonitorOptRqst"
end
function MsgType.GMMonitorOptRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.optType = 0
    self.serverList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.optType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpServerListObj = MsgType.MonitorOptData:New()
            tmpServerListObj:Decode(data.d[i])
            self.serverList[i] = tmpServerListObj
        end
    end
    return self
end


MsgType.MGMonitorOptRspd = {
    msgSeq = 0,
    isSuccess = 0
}
MsgType.MGMonitorOptRspd.__index = MsgType.MGMonitorOptRspd

function MsgType.MGMonitorOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGMonitorOptRspd:GetCmd()
    return MsgTypeCmd.MG_MonitorOptRspd
end
function MsgType.MGMonitorOptRspd:GetUrl()
    return "MGMonitorOptRspd"
end
function MsgType.MGMonitorOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    return self
end


MsgType.GMMonitorMachineStatusRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.GMMonitorMachineStatusRqst.__index = MsgType.GMMonitorMachineStatusRqst

function MsgType.GMMonitorMachineStatusRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMMonitorMachineStatusRqst:GetCmd()
    return MsgTypeCmd.GM_MonitorMachineStatusRqst
end
function MsgType.GMMonitorMachineStatusRqst:GetUrl()
    return "GMMonitorMachineStatusRqst"
end
function MsgType.GMMonitorMachineStatusRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.MonitorCommonStatus = {
    loadAverage = "",
    processTotal = "",
    processRunning = "",
    processSleeping = "",
    processStopped = "",
    processZombie = ""
}
MsgType.MonitorCommonStatus.__index = MsgType.MonitorCommonStatus

function MsgType.MonitorCommonStatus:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorCommonStatus:Encode()
    local tb = {}
    if nil ~= self.loadAverage and string.len(self.loadAverage) > 0 then
        tb.b = self.loadAverage
    end
    if nil ~= self.processTotal and string.len(self.processTotal) > 0 then
        tb.c = self.processTotal
    end
    if nil ~= self.processRunning and string.len(self.processRunning) > 0 then
        tb.d = self.processRunning
    end
    if nil ~= self.processSleeping and string.len(self.processSleeping) > 0 then
        tb.e = self.processSleeping
    end
    if nil ~= self.processStopped and string.len(self.processStopped) > 0 then
        tb.f = self.processStopped
    end
    if nil ~= self.processZombie and string.len(self.processZombie) > 0 then
        tb.g = self.processZombie
    end
    return tb
end

function MsgType.MonitorCommonStatus:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.loadAverage = ""
    self.processTotal = ""
    self.processRunning = ""
    self.processSleeping = ""
    self.processStopped = ""
    self.processZombie = ""
    if nil ~= data.b then
        self.loadAverage = tostring(data.b)
    end
    if nil ~= data.c then
        self.processTotal = tostring(data.c)
    end
    if nil ~= data.d then
        self.processRunning = tostring(data.d)
    end
    if nil ~= data.e then
        self.processSleeping = tostring(data.e)
    end
    if nil ~= data.f then
        self.processStopped = tostring(data.f)
    end
    if nil ~= data.g then
        self.processZombie = tostring(data.g)
    end
    return self
end

function MsgType.MonitorCommonStatus:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MonitorCpuStatus = {
    idle = ""
}
MsgType.MonitorCpuStatus.__index = MsgType.MonitorCpuStatus

function MsgType.MonitorCpuStatus:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorCpuStatus:Encode()
    local tb = {}
    if nil ~= self.idle and string.len(self.idle) > 0 then
        tb.b = self.idle
    end
    return tb
end

function MsgType.MonitorCpuStatus:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.idle = ""
    if nil ~= data.b then
        self.idle = tostring(data.b)
    end
    return self
end

function MsgType.MonitorCpuStatus:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MonitorMemStatus = {
    total = "",
    free = ""
}
MsgType.MonitorMemStatus.__index = MsgType.MonitorMemStatus

function MsgType.MonitorMemStatus:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorMemStatus:Encode()
    local tb = {}
    if nil ~= self.total and string.len(self.total) > 0 then
        tb.b = self.total
    end
    if nil ~= self.free and string.len(self.free) > 0 then
        tb.c = self.free
    end
    return tb
end

function MsgType.MonitorMemStatus:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.total = ""
    self.free = ""
    if nil ~= data.b then
        self.total = tostring(data.b)
    end
    if nil ~= data.c then
        self.free = tostring(data.c)
    end
    return self
end

function MsgType.MonitorMemStatus:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MonitorIoStatus = {
    read = "",
    write = ""
}
MsgType.MonitorIoStatus.__index = MsgType.MonitorIoStatus

function MsgType.MonitorIoStatus:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MonitorIoStatus:Encode()
    local tb = {}
    if nil ~= self.read and string.len(self.read) > 0 then
        tb.b = self.read
    end
    if nil ~= self.write and string.len(self.write) > 0 then
        tb.c = self.write
    end
    return tb
end

function MsgType.MonitorIoStatus:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.read = ""
    self.write = ""
    if nil ~= data.b then
        self.read = tostring(data.b)
    end
    if nil ~= data.c then
        self.write = tostring(data.c)
    end
    return self
end

function MsgType.MonitorIoStatus:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MGMonitorMachineStatusRspd = {
    msgSeq = 0,
    common = {},
    cpu = {},
    mem = {},
    io = {}
}
MsgType.MGMonitorMachineStatusRspd.__index = MsgType.MGMonitorMachineStatusRspd
setmetatable(MsgType.MGMonitorMachineStatusRspd.common, MsgType.MonitorCommonStatus)
setmetatable(MsgType.MGMonitorMachineStatusRspd.cpu, MsgType.MonitorCpuStatus)
setmetatable(MsgType.MGMonitorMachineStatusRspd.mem, MsgType.MonitorMemStatus)
setmetatable(MsgType.MGMonitorMachineStatusRspd.io, MsgType.MonitorIoStatus)

function MsgType.MGMonitorMachineStatusRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGMonitorMachineStatusRspd:GetCmd()
    return MsgTypeCmd.MG_MonitorMachineStatusRspd
end
function MsgType.MGMonitorMachineStatusRspd:GetUrl()
    return "MGMonitorMachineStatusRspd"
end
function MsgType.MGMonitorMachineStatusRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.common = MsgType.MonitorCommonStatus:New()
    self.cpu = MsgType.MonitorCpuStatus:New()
    self.mem = MsgType.MonitorMemStatus:New()
    self.io = MsgType.MonitorIoStatus:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.common:Decode(data.c)
    end
    if nil ~= data.d then
        self.cpu:Decode(data.d)
    end
    if nil ~= data.e then
        self.mem:Decode(data.e)
    end
    if nil ~= data.f then
        self.io:Decode(data.f)
    end
    return self
end


MsgType.GMReloadCsvRqst = {
    msgSeq = 0,
    index = 0,
    groupid = 0,
    updateid = ""
}
MsgType.GMReloadCsvRqst.__index = MsgType.GMReloadCsvRqst

function MsgType.GMReloadCsvRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMReloadCsvRqst:GetCmd()
    return MsgTypeCmd.GM_ReloadCsvRqst
end
function MsgType.GMReloadCsvRqst:GetUrl()
    return "GMReloadCsvRqst"
end
function MsgType.GMReloadCsvRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.index = 0
    self.groupid = 0
    self.updateid = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.index = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.groupid = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.updateid = tostring(data.e)
    end
    return self
end


MsgType.GMLoadCsvResultRqst = {
    msgSeq = 0,
    updateid = ""
}
MsgType.GMLoadCsvResultRqst.__index = MsgType.GMLoadCsvResultRqst

function MsgType.GMLoadCsvResultRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMLoadCsvResultRqst:GetCmd()
    return MsgTypeCmd.GM_LoadCsvResultRqst
end
function MsgType.GMLoadCsvResultRqst:GetUrl()
    return "GMLoadCsvResultRqst"
end
function MsgType.GMLoadCsvResultRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.updateid = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.updateid = tostring(data.c)
    end
    return self
end


MsgType.LoadResult = {
    msgSeq = 0,
    groupid = 0,
    serverid = 0,
    servertype = "",
    status = ""
}
MsgType.LoadResult.__index = MsgType.LoadResult

function MsgType.LoadResult:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.LoadResult:GetCmd()
    return MsgTypeCmd.MG_LoadCsvResultRspd
end
function MsgType.LoadResult:GetUrl()
    return "LoadResult"
end
function MsgType.LoadResult:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupid = 0
    self.serverid = 0
    self.servertype = ""
    self.status = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupid = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.serverid = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.servertype = tostring(data.e)
    end
    if nil ~= data.f then
        self.status = tostring(data.f)
    end
    return self
end


MsgType.MGLoadResultRspd = {
    msgSeq = 0,
    loadResultList = {} -- array of MsgType.LoadResult
}
MsgType.MGLoadResultRspd.__index = MsgType.MGLoadResultRspd

function MsgType.MGLoadResultRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGLoadResultRspd:GetCmd()
    return MsgTypeCmd.MG_LoadCsvResultRspd
end
function MsgType.MGLoadResultRspd:GetUrl()
    return "MGLoadResultRspd"
end
function MsgType.MGLoadResultRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.loadResultList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpLoadResultListObj = MsgType.LoadResult:New()
            tmpLoadResultListObj:Decode(data.c[i])
            self.loadResultList[i] = tmpLoadResultListObj
        end
    end
    return self
end


MsgType.MGReloadCsvRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGReloadCsvRspd.__index = MsgType.MGReloadCsvRspd

function MsgType.MGReloadCsvRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGReloadCsvRspd:GetCmd()
    return MsgTypeCmd.MG_ReloadCsvRspd
end
function MsgType.MGReloadCsvRspd:GetUrl()
    return "MGReloadCsvRspd"
end
function MsgType.MGReloadCsvRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMMonifyPayOrderRqst = {
    msgSeq = 0,
    groupID = 0,
    flag = 0,
    orderID = ""
}
MsgType.GMMonifyPayOrderRqst.__index = MsgType.GMMonifyPayOrderRqst

function MsgType.GMMonifyPayOrderRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMMonifyPayOrderRqst:GetCmd()
    return MsgTypeCmd.GM_MonifyPayOrderRqst
end
function MsgType.GMMonifyPayOrderRqst:GetUrl()
    return "GMMonifyPayOrderRqst"
end
function MsgType.GMMonifyPayOrderRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupID = 0
    self.flag = 0
    self.orderID = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.flag = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.orderID = tostring(data.e)
    end
    return self
end


MsgType.MGMonifyPayOrderRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGMonifyPayOrderRspd.__index = MsgType.MGMonifyPayOrderRspd

function MsgType.MGMonifyPayOrderRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGMonifyPayOrderRspd:GetCmd()
    return MsgTypeCmd.MG_MonifyPayOrderRspd
end
function MsgType.MGMonifyPayOrderRspd:GetUrl()
    return "MGMonifyPayOrderRspd"
end
function MsgType.MGMonifyPayOrderRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMQueryActivityRqst = {
    msgSeq = 0,
    activityType = 0
}
MsgType.GMQueryActivityRqst.__index = MsgType.GMQueryActivityRqst

function MsgType.GMQueryActivityRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMQueryActivityRqst:GetCmd()
    return MsgTypeCmd.GM_QueryActivityRqst
end
function MsgType.GMQueryActivityRqst:GetUrl()
    return "GMQueryActivityRqst"
end
function MsgType.GMQueryActivityRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.activityType = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.activityType = tonumber(data.c) or 0
    end
    return self
end


MsgType.GMActivityInfo = {
    activityType = 0,
    activityID = 0,
    startTime = 0,
    endTime = 0,
    level = 0,
    modifyTime = 0,
    money = 0,
    moneyType = 0,
    buyTimes = 0,
    itemList = {}, -- array of MsgType.ItemInPayList
    extNum1 = 0,
    extNum2 = 0,
    extData = ""
}
MsgType.GMActivityInfo.__index = MsgType.GMActivityInfo

function MsgType.GMActivityInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GMActivityInfo:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:encode()
    end
    return tb
end
function MsgType.GMActivityInfo:Encode()
    local tb = {}
    if nil ~= self.activityType and 0 ~= self.activityType then
        tb.b = self.activityType
    end
    if nil ~= self.activityID and 0 ~= self.activityID then
        tb.c = self.activityID
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.d = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.e = self.endTime
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.f = self.level
    end
    if nil ~= self.modifyTime and 0 ~= self.modifyTime then
        tb.g = self.modifyTime
    end
    if nil ~= self.money and 0 ~= self.money then
        tb.h = self.money
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.i = self.moneyType
    end
    if nil ~= self.buyTimes and 0 ~= self.buyTimes then
        tb.j = self.buyTimes
    end
    tb.k = self:_itemListEncode()
    if nil ~= self.extNum1 and 0 ~= self.extNum1 then
        tb.l = self.extNum1
    end
    if nil ~= self.extNum2 and 0 ~= self.extNum2 then
        tb.m = self.extNum2
    end
    if nil ~= self.extData and string.len(self.extData) > 0 then
        tb.n = self.extData
    end
    return tb
end

function MsgType.GMActivityInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.activityType = 0
    self.activityID = 0
    self.startTime = 0
    self.endTime = 0
    self.level = 0
    self.modifyTime = 0
    self.money = 0
    self.moneyType = 0
    self.buyTimes = 0
    self.itemList = {}
    self.extNum1 = 0
    self.extNum2 = 0
    self.extData = ""
    if nil ~= data.b then
        self.activityType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.activityID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.startTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.endTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.level = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.modifyTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.money = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.moneyType = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.buyTimes = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpItemListObj = MsgType.ItemInPayList:New()
            tmpItemListObj:Decode(data.k[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.l then
        self.extNum1 = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.extNum2 = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.extData = tostring(data.n)
    end
    return self
end

function MsgType.GMActivityInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.MGQueryActivityRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0,
    activityList = {} -- array of MsgType.GMActivityInfo
}
MsgType.MGQueryActivityRspd.__index = MsgType.MGQueryActivityRspd

function MsgType.MGQueryActivityRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGQueryActivityRspd:GetCmd()
    return MsgTypeCmd.MG_QueryActivityRspd
end
function MsgType.MGQueryActivityRspd:GetUrl()
    return "MGQueryActivityRspd"
end
function MsgType.MGQueryActivityRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    self.activityList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpActivityListObj = MsgType.GMActivityInfo:New()
            tmpActivityListObj:Decode(data.e[i])
            self.activityList[i] = tmpActivityListObj
        end
    end
    return self
end


MsgType.GMQueryActivityIsAllCloseRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.GMQueryActivityIsAllCloseRqst.__index = MsgType.GMQueryActivityIsAllCloseRqst

function MsgType.GMQueryActivityIsAllCloseRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMQueryActivityIsAllCloseRqst:GetCmd()
    return MsgTypeCmd.GM_QueryActivityIsAllCloseRqst
end
function MsgType.GMQueryActivityIsAllCloseRqst:GetUrl()
    return "GMQueryActivityIsAllCloseRqst"
end
function MsgType.GMQueryActivityIsAllCloseRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.MGQueryActivityIsAllCloseRspd = {
    msgSeq = 0,
    isAllClose = false
}
MsgType.MGQueryActivityIsAllCloseRspd.__index = MsgType.MGQueryActivityIsAllCloseRspd

function MsgType.MGQueryActivityIsAllCloseRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGQueryActivityIsAllCloseRspd:GetCmd()
    return MsgTypeCmd.MG_QueryActivityIsAllCloseRspd
end
function MsgType.MGQueryActivityIsAllCloseRspd:GetUrl()
    return "MGQueryActivityIsAllCloseRspd"
end
function MsgType.MGQueryActivityIsAllCloseRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isAllClose = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isAllClose = data.c
    end
    return self
end


MsgType.GMActivityOneKeyCloseRqst = {
    msgSeq = 0,
    isCloseAll = 0
}
MsgType.GMActivityOneKeyCloseRqst.__index = MsgType.GMActivityOneKeyCloseRqst

function MsgType.GMActivityOneKeyCloseRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMActivityOneKeyCloseRqst:GetCmd()
    return MsgTypeCmd.GM_ActivityOneKeyCloseRqst
end
function MsgType.GMActivityOneKeyCloseRqst:GetUrl()
    return "GMActivityOneKeyCloseRqst"
end
function MsgType.GMActivityOneKeyCloseRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isCloseAll = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isCloseAll = tonumber(data.c) or 0
    end
    return self
end


MsgType.MGActivityOneKeyCloseRspd = {
    msgSeq = 0,
    isAllClose = false
}
MsgType.MGActivityOneKeyCloseRspd.__index = MsgType.MGActivityOneKeyCloseRspd

function MsgType.MGActivityOneKeyCloseRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGActivityOneKeyCloseRspd:GetCmd()
    return MsgTypeCmd.MG_ActivityOneKeyCloseRspd
end
function MsgType.MGActivityOneKeyCloseRspd:GetUrl()
    return "MGActivityOneKeyCloseRspd"
end
function MsgType.MGActivityOneKeyCloseRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isAllClose = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isAllClose = data.c
    end
    return self
end


MsgType.GMModifyActivityRqst = {
    msgSeq = 0,
    modifyActivity = {}
}
MsgType.GMModifyActivityRqst.__index = MsgType.GMModifyActivityRqst
setmetatable(MsgType.GMModifyActivityRqst.modifyActivity, MsgType.GMActivityInfo)

function MsgType.GMModifyActivityRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMModifyActivityRqst:GetCmd()
    return MsgTypeCmd.GM_ModifyActivityRqst
end
function MsgType.GMModifyActivityRqst:GetUrl()
    return "GMModifyActivityRqst"
end
function MsgType.GMModifyActivityRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.modifyActivity = MsgType.GMActivityInfo:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.modifyActivity:Decode(data.c)
    end
    return self
end


MsgType.MGModifyActivityRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGModifyActivityRspd.__index = MsgType.MGModifyActivityRspd

function MsgType.MGModifyActivityRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGModifyActivityRspd:GetCmd()
    return MsgTypeCmd.MG_ModifyActivityRspd
end
function MsgType.MGModifyActivityRspd:GetUrl()
    return "MGModifyActivityRspd"
end
function MsgType.MGModifyActivityRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMLockPlayerRqst = {
    msgSeq = 0,
    groupID = 0,
    roleUID = 0,
    isLock = 0,
    lockTime = 0
}
MsgType.GMLockPlayerRqst.__index = MsgType.GMLockPlayerRqst

function MsgType.GMLockPlayerRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMLockPlayerRqst:GetCmd()
    return MsgTypeCmd.GM_LockPlayerRqst
end
function MsgType.GMLockPlayerRqst:GetUrl()
    return "GMLockPlayerRqst"
end
function MsgType.GMLockPlayerRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupID = 0
    self.roleUID = 0
    self.isLock = 0
    self.lockTime = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isLock = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.lockTime = tonumber(data.f) or 0
    end
    return self
end


MsgType.MGLockPlayerRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.MGLockPlayerRspd.__index = MsgType.MGLockPlayerRspd

function MsgType.MGLockPlayerRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGLockPlayerRspd:GetCmd()
    return MsgTypeCmd.MG_LockPlayerRspd
end
function MsgType.MGLockPlayerRspd:GetUrl()
    return "MGLockPlayerRspd"
end
function MsgType.MGLockPlayerRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMEGetNoticeRqst = {
    msgSeq = 0,
    saveType = 0
}
MsgType.GMEGetNoticeRqst.__index = MsgType.GMEGetNoticeRqst

function MsgType.GMEGetNoticeRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMEGetNoticeRqst:GetCmd()
    return MsgTypeCmd.GME_GetNoticeRqst
end
function MsgType.GMEGetNoticeRqst:GetUrl()
    return "GMEGetNoticeRqst"
end
function MsgType.GMEGetNoticeRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.saveType = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.saveType = tonumber(data.c) or 0
    end
    return self
end


MsgType.EGMGetNoticeRspd = {
    msgSeq = 0,
    isSuccess = false,
    saveType = 0,
    notice = {},
    previewList = {} -- array of MsgType.PreviewDataInDB
}
MsgType.EGMGetNoticeRspd.__index = MsgType.EGMGetNoticeRspd
setmetatable(MsgType.EGMGetNoticeRspd.notice, MsgType.NoticeDataInDB)

function MsgType.EGMGetNoticeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.EGMGetNoticeRspd:GetCmd()
    return MsgTypeCmd.EGM_GetNoticeRspd
end
function MsgType.EGMGetNoticeRspd:GetUrl()
    return "EGMGetNoticeRspd"
end
function MsgType.EGMGetNoticeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.saveType = 0
    self.notice = MsgType.NoticeDataInDB:New()
    self.previewList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.saveType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.notice:Decode(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPreviewListObj = MsgType.PreviewDataInDB:New()
            tmpPreviewListObj:Decode(data.f[i])
            self.previewList[i] = tmpPreviewListObj
        end
    end
    return self
end


MsgType.GMESaveNoticeRqst = {
    msgSeq = 0,
    saveType = 0,
    opType = 0,
    notice = {},
    preview = {}
}
MsgType.GMESaveNoticeRqst.__index = MsgType.GMESaveNoticeRqst
setmetatable(MsgType.GMESaveNoticeRqst.notice, MsgType.NoticeDataInDB)
setmetatable(MsgType.GMESaveNoticeRqst.preview, MsgType.PreviewDataInDB)

function MsgType.GMESaveNoticeRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMESaveNoticeRqst:GetCmd()
    return MsgTypeCmd.GME_SaveNoticeRqst
end
function MsgType.GMESaveNoticeRqst:GetUrl()
    return "GMESaveNoticeRqst"
end
function MsgType.GMESaveNoticeRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.saveType = 0
    self.opType = 0
    self.notice = MsgType.NoticeDataInDB:New()
    self.preview = MsgType.PreviewDataInDB:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.saveType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.opType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.notice:Decode(data.e)
    end
    if nil ~= data.f then
        self.preview:Decode(data.f)
    end
    return self
end


MsgType.EGMSaveNoticeRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.EGMSaveNoticeRspd.__index = MsgType.EGMSaveNoticeRspd

function MsgType.EGMSaveNoticeRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.EGMSaveNoticeRspd:GetCmd()
    return MsgTypeCmd.EGM_SaveNoticeRspd
end
function MsgType.EGMSaveNoticeRspd:GetUrl()
    return "EGMSaveNoticeRspd"
end
function MsgType.EGMSaveNoticeRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.GMUgcComLevelListRqst = {
    msgSeq = 0,
    groupId = 0
}
MsgType.GMUgcComLevelListRqst.__index = MsgType.GMUgcComLevelListRqst

function MsgType.GMUgcComLevelListRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMUgcComLevelListRqst:GetCmd()
    return MsgTypeCmd.GM_UgcComLevelListRqst
end
function MsgType.GMUgcComLevelListRqst:GetUrl()
    return "GMUgcComLevelListRqst"
end
function MsgType.GMUgcComLevelListRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupId = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupId = tonumber(data.c) or 0
    end
    return self
end


MsgType.MGUgcComLevelListRspd = {
    msgSeq = 0,
    status = 0,
    levelList = {} -- array of MsgType.LevelInfo
}
MsgType.MGUgcComLevelListRspd.__index = MsgType.MGUgcComLevelListRspd

function MsgType.MGUgcComLevelListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGUgcComLevelListRspd:GetCmd()
    return MsgTypeCmd.MG_UgcComLevelListRspd
end
function MsgType.MGUgcComLevelListRspd:GetUrl()
    return "MGUgcComLevelListRspd"
end
function MsgType.MGUgcComLevelListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.status = 0
    self.levelList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.status = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpLevelListObj = MsgType.LevelInfo:New()
            tmpLevelListObj:Decode(data.d[i])
            self.levelList[i] = tmpLevelListObj
        end
    end
    return self
end


MsgType.GMOptUgcComLevelRqst = {
    msgSeq = 0,
    groupId = 0,
    type = 0,
    levelId = 0,
    language = ""
}
MsgType.GMOptUgcComLevelRqst.__index = MsgType.GMOptUgcComLevelRqst

function MsgType.GMOptUgcComLevelRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMOptUgcComLevelRqst:GetCmd()
    return MsgTypeCmd.GM_OptUgcComLevelRqst
end
function MsgType.GMOptUgcComLevelRqst:GetUrl()
    return "GMOptUgcComLevelRqst"
end
function MsgType.GMOptUgcComLevelRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.groupId = 0
    self.type = 0
    self.levelId = 0
    self.language = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.groupId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.type = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.levelId = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.language = tostring(data.f)
    end
    return self
end


MsgType.MGOptUgcComLevelRspd = {
    msgSeq = 0,
    isSuccess = 0
}
MsgType.MGOptUgcComLevelRspd.__index = MsgType.MGOptUgcComLevelRspd

function MsgType.MGOptUgcComLevelRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.MGOptUgcComLevelRspd:GetCmd()
    return MsgTypeCmd.GM_OptUgcComLevelRspd
end
function MsgType.MGOptUgcComLevelRspd:GetUrl()
    return "MGOptUgcComLevelRspd"
end
function MsgType.MGOptUgcComLevelRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = tonumber(data.c) or 0
    end
    return self
end


MsgType.WKTestRqst = {
    msgSeq = 0,
    modifyActivity = {}
}
MsgType.WKTestRqst.__index = MsgType.WKTestRqst
setmetatable(MsgType.WKTestRqst.modifyActivity, MsgType.GMActivityInfo)

function MsgType.WKTestRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKTestRqst:GetCmd()
    return MsgTypeCmd.WK_TestRqst
end
function MsgType.WKTestRqst:GetUrl()
    return "WKTestRqst"
end
function MsgType.WKTestRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.modifyActivity = MsgType.GMActivityInfo:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.modifyActivity:Decode(data.c)
    end
    return self
end


MsgType.KWTestRspd = {
    msgSeq = 0,
    isSuccess = false,
    errorCode = 0
}
MsgType.KWTestRspd.__index = MsgType.KWTestRspd

function MsgType.KWTestRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWTestRspd:GetCmd()
    return MsgTypeCmd.KW_TestRspd
end
function MsgType.KWTestRspd:GetUrl()
    return "KWTestRspd"
end
function MsgType.KWTestRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.errorCode = tonumber(data.d) or 0
    end
    return self
end


MsgType.WKQueryBalanceRqst = {
    msgSeq = 0,
    account = "",
    roleUID = 0
}
MsgType.WKQueryBalanceRqst.__index = MsgType.WKQueryBalanceRqst

function MsgType.WKQueryBalanceRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKQueryBalanceRqst:GetCmd()
    return MsgTypeCmd.WK_QueryBalanceRqst
end
function MsgType.WKQueryBalanceRqst:GetUrl()
    return "WKQueryBalanceRqst"
end
function MsgType.WKQueryBalanceRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.roleUID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    return self
end


MsgType.KWQueryBalanceRspd = {
    msgSeq = 0,
    isSuccess = false,
    balance = ""
}
MsgType.KWQueryBalanceRspd.__index = MsgType.KWQueryBalanceRspd

function MsgType.KWQueryBalanceRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWQueryBalanceRspd:GetCmd()
    return MsgTypeCmd.KW_QueryBalanceRspd
end
function MsgType.KWQueryBalanceRspd:GetUrl()
    return "KWQueryBalanceRspd"
end
function MsgType.KWQueryBalanceRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.balance = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.balance = tostring(data.d)
    end
    return self
end


MsgType.WKQueryCoinActivityRqst = {
    msgSeq = 0,
    account = "",
    roleUID = 0
}
MsgType.WKQueryCoinActivityRqst.__index = MsgType.WKQueryCoinActivityRqst

function MsgType.WKQueryCoinActivityRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKQueryCoinActivityRqst:GetCmd()
    return MsgTypeCmd.WK_QueryCoinActivityRqst
end
function MsgType.WKQueryCoinActivityRqst:GetUrl()
    return "WKQueryCoinActivityRqst"
end
function MsgType.WKQueryCoinActivityRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.roleUID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    return self
end


MsgType.KWQueryCoinActivityRspd = {
    msgSeq = 0,
    isSuccess = false,
    activityInfo = {}
}
MsgType.KWQueryCoinActivityRspd.__index = MsgType.KWQueryCoinActivityRspd
setmetatable(MsgType.KWQueryCoinActivityRspd.activityInfo, MsgType.LinkActivityInfo)

function MsgType.KWQueryCoinActivityRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWQueryCoinActivityRspd:GetCmd()
    return MsgTypeCmd.KW_QueryCoinActivityRspd
end
function MsgType.KWQueryCoinActivityRspd:GetUrl()
    return "KWQueryCoinActivityRspd"
end
function MsgType.KWQueryCoinActivityRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.activityInfo = MsgType.LinkActivityInfo:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.activityInfo:Decode(data.d)
    end
    return self
end


MsgType.WKRewardCoinRqst = {
    msgSeq = 0,
    account = "",
    roleUID = 0,
    roleName = ""
}
MsgType.WKRewardCoinRqst.__index = MsgType.WKRewardCoinRqst

function MsgType.WKRewardCoinRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKRewardCoinRqst:GetCmd()
    return MsgTypeCmd.WK_RewardCoinRqst
end
function MsgType.WKRewardCoinRqst:GetUrl()
    return "WKRewardCoinRqst"
end
function MsgType.WKRewardCoinRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.roleUID = 0
    self.roleName = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.roleName = tostring(data.e)
    end
    return self
end


MsgType.KWRewardCoinRspd = {
    msgSeq = 0,
    isSuccess = false,
    rewardCount = "",
    balance = ""
}
MsgType.KWRewardCoinRspd.__index = MsgType.KWRewardCoinRspd

function MsgType.KWRewardCoinRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWRewardCoinRspd:GetCmd()
    return MsgTypeCmd.KW_RewardCoinRspd
end
function MsgType.KWRewardCoinRspd:GetUrl()
    return "KWRewardCoinRspd"
end
function MsgType.KWRewardCoinRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.rewardCount = ""
    self.balance = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.rewardCount = tostring(data.d)
    end
    if nil ~= data.e then
        self.balance = tostring(data.e)
    end
    return self
end


MsgType.KKActivityDataChgRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.KKActivityDataChgRqst.__index = MsgType.KKActivityDataChgRqst

function MsgType.KKActivityDataChgRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KKActivityDataChgRqst:GetCmd()
    return MsgTypeCmd.KK_ActivityDataChgRqst
end
function MsgType.KKActivityDataChgRqst:GetUrl()
    return "KKActivityDataChgRqst"
end
function MsgType.KKActivityDataChgRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.KKActivityDataChgRspd = {
    msgSeq = 0,
    isSuccess = false
}
MsgType.KKActivityDataChgRspd.__index = MsgType.KKActivityDataChgRspd

function MsgType.KKActivityDataChgRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KKActivityDataChgRspd:GetCmd()
    return MsgTypeCmd.KK_ActivityDataChgRspd
end
function MsgType.KKActivityDataChgRspd:GetUrl()
    return "KKActivityDataChgRspd"
end
function MsgType.KKActivityDataChgRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    return self
end


MsgType.KERegisterCountRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.KERegisterCountRqst.__index = MsgType.KERegisterCountRqst

function MsgType.KERegisterCountRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KERegisterCountRqst:GetCmd()
    return MsgTypeCmd.KE_RegisterCountRqst
end
function MsgType.KERegisterCountRqst:GetUrl()
    return "KERegisterCountRqst"
end
function MsgType.KERegisterCountRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.EKRegisterCountRspd = {
    msgSeq = 0,
    isSuccess = false,
    registerCount = 0
}
MsgType.EKRegisterCountRspd.__index = MsgType.EKRegisterCountRspd

function MsgType.EKRegisterCountRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.EKRegisterCountRspd:GetCmd()
    return MsgTypeCmd.EK_RegisterCountRspd
end
function MsgType.EKRegisterCountRspd:GetUrl()
    return "EKRegisterCountRspd"
end
function MsgType.EKRegisterCountRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.registerCount = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.registerCount = tonumber(data.d) or 0
    end
    return self
end


MsgType.WKQueryChainAddressRqst = {
    msgSeq = 0,
    account = "",
    roleUID = 0,
    platformUUID = ""
}
MsgType.WKQueryChainAddressRqst.__index = MsgType.WKQueryChainAddressRqst

function MsgType.WKQueryChainAddressRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKQueryChainAddressRqst:GetCmd()
    return MsgTypeCmd.WK_QueryChainAddressRqst
end
function MsgType.WKQueryChainAddressRqst:GetUrl()
    return "WKQueryChainAddressRqst"
end
function MsgType.WKQueryChainAddressRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.roleUID = 0
    self.platformUUID = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.platformUUID = tostring(data.e)
    end
    return self
end


MsgType.KWQueryChainAddressRspd = {
    msgSeq = 0,
    isSuccess = false,
    address = "",
    bindAddress = ""
}
MsgType.KWQueryChainAddressRspd.__index = MsgType.KWQueryChainAddressRspd

function MsgType.KWQueryChainAddressRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWQueryChainAddressRspd:GetCmd()
    return MsgTypeCmd.KW_QueryChainAddressRspd
end
function MsgType.KWQueryChainAddressRspd:GetUrl()
    return "KWQueryChainAddressRspd"
end
function MsgType.KWQueryChainAddressRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.address = ""
    self.bindAddress = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.address = tostring(data.d)
    end
    if nil ~= data.e then
        self.bindAddress = tostring(data.e)
    end
    return self
end


MsgType.GMKQueryContractInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.GMKQueryContractInfoRqst.__index = MsgType.GMKQueryContractInfoRqst

function MsgType.GMKQueryContractInfoRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GMKQueryContractInfoRqst:GetCmd()
    return MsgTypeCmd.GMK_QueryContractInfoRqst
end
function MsgType.GMKQueryContractInfoRqst:GetUrl()
    return "GMKQueryContractInfoRqst"
end
function MsgType.GMKQueryContractInfoRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.nouse = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.nouse = tonumber(data.c) or 0
    end
    return self
end


MsgType.KGMQueryContractInfoRspd = {
    msgSeq = 0,
    isSuccess = false,
    defaultAccountBalance = "",
    blockInfo = "",
    name = "",
    symbol = "",
    decimals = 0,
    totalSupply = 0
}
MsgType.KGMQueryContractInfoRspd.__index = MsgType.KGMQueryContractInfoRspd

function MsgType.KGMQueryContractInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KGMQueryContractInfoRspd:GetCmd()
    return MsgTypeCmd.KGM_QueryContractInfoRspd
end
function MsgType.KGMQueryContractInfoRspd:GetUrl()
    return "KGMQueryContractInfoRspd"
end
function MsgType.KGMQueryContractInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.defaultAccountBalance = ""
    self.blockInfo = ""
    self.name = ""
    self.symbol = ""
    self.decimals = 0
    self.totalSupply = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.defaultAccountBalance = tostring(data.d)
    end
    if nil ~= data.e then
        self.blockInfo = tostring(data.e)
    end
    if nil ~= data.f then
        self.name = tostring(data.f)
    end
    if nil ~= data.g then
        self.symbol = tostring(data.g)
    end
    if nil ~= data.h then
        self.decimals = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.totalSupply = tonumber(data.i) or 0
    end
    return self
end


MsgType.WKBindChainAddressRqst = {
    msgSeq = 0,
    account = "",
    roleUID = 0,
    platformUUID = "",
    address = ""
}
MsgType.WKBindChainAddressRqst.__index = MsgType.WKBindChainAddressRqst

function MsgType.WKBindChainAddressRqst:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.WKBindChainAddressRqst:GetCmd()
    return MsgTypeCmd.WK_BindChainAddressRqst
end
function MsgType.WKBindChainAddressRqst:GetUrl()
    return "WKBindChainAddressRqst"
end
function MsgType.WKBindChainAddressRqst:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.roleUID = 0
    self.platformUUID = ""
    self.address = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.account = tostring(data.c)
    end
    if nil ~= data.d then
        self.roleUID = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.platformUUID = tostring(data.e)
    end
    if nil ~= data.f then
        self.address = tostring(data.f)
    end
    return self
end


MsgType.KWBindChainAddressRspd = {
    msgSeq = 0,
    isSuccess = false,
    account = "",
    roleUID = 0,
    address = ""
}
MsgType.KWBindChainAddressRspd.__index = MsgType.KWBindChainAddressRspd

function MsgType.KWBindChainAddressRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.KWBindChainAddressRspd:GetCmd()
    return MsgTypeCmd.KW_BindChainAddressRspd
end
function MsgType.KWBindChainAddressRspd:GetUrl()
    return "KWBindChainAddressRspd"
end
function MsgType.KWBindChainAddressRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isSuccess = false
    self.account = ""
    self.roleUID = 0
    self.address = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.isSuccess = data.c
    end
    if nil ~= data.d then
        self.account = tostring(data.d)
    end
    if nil ~= data.e then
        self.roleUID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.address = tostring(data.f)
    end
    return self
end


MsgType.OfflineData = {
    eventType = 0, --enum EOfflineType
    mapType = 0, --enum EMapEnterType
    eventTime = 0,
    validCode = "",
    levelid = 0,
    usedItemList = {}, -- array of MsgType.ItemDisplayerInfo
    buyItemList = {}, -- array of MsgType.ItemDisplayerInfo
    rewardList = {}, -- array of MsgType.ItemDisplayerInfo
    gameResult = false,
    oldGoldNum = 0,
    newGoldNum = 0,
    oldAPNum = 0,
    newAPNum = 0,
    remainStep = 0
}
MsgType.OfflineData.__index = MsgType.OfflineData

function MsgType.OfflineData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OfflineData:_usedItemListEncode()
    local tb = {}
    for i=1, #self.usedItemList do
        tb[i] = self.usedItemList[i]:encode()
    end
    return tb
end
function MsgType.OfflineData:_buyItemListEncode()
    local tb = {}
    for i=1, #self.buyItemList do
        tb[i] = self.buyItemList[i]:encode()
    end
    return tb
end
function MsgType.OfflineData:_rewardListEncode()
    local tb = {}
    for i=1, #self.rewardList do
        tb[i] = self.rewardList[i]:encode()
    end
    return tb
end
function MsgType.OfflineData:Encode()
    local tb = {}
    if nil ~= self.eventType and 0 ~= self.eventType then
        tb.b = self.eventType
    end
    if nil ~= self.mapType and 0 ~= self.mapType then
        tb.c = self.mapType
    end
    if nil ~= self.eventTime and 0 ~= self.eventTime then
        tb.d = self.eventTime
    end
    if nil ~= self.validCode and string.len(self.validCode) > 0 then
        tb.e = self.validCode
    end
    if nil ~= self.levelid and 0 ~= self.levelid then
        tb.f = self.levelid
    end
    tb.g = self:_usedItemListEncode()
    tb.h = self:_buyItemListEncode()
    tb.i = self:_rewardListEncode()
    if self.gameResult then
        tb.j = self.gameResult
    end
    if nil ~= self.oldGoldNum and 0 ~= self.oldGoldNum then
        tb.k = self.oldGoldNum
    end
    if nil ~= self.newGoldNum and 0 ~= self.newGoldNum then
        tb.l = self.newGoldNum
    end
    if nil ~= self.oldAPNum and 0 ~= self.oldAPNum then
        tb.m = self.oldAPNum
    end
    if nil ~= self.newAPNum and 0 ~= self.newAPNum then
        tb.n = self.newAPNum
    end
    if nil ~= self.remainStep and 0 ~= self.remainStep then
        tb.o = self.remainStep
    end
    return tb
end

function MsgType.OfflineData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.eventType = 0
    self.mapType = 0
    self.eventTime = 0
    self.validCode = ""
    self.levelid = 0
    self.usedItemList = {}
    self.buyItemList = {}
    self.rewardList = {}
    self.gameResult = false
    self.oldGoldNum = 0
    self.newGoldNum = 0
    self.oldAPNum = 0
    self.newAPNum = 0
    self.remainStep = 0
    if nil ~= data.b then
        self.eventType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.mapType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.eventTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.validCode = tostring(data.e)
    end
    if nil ~= data.f then
        self.levelid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpUsedItemListObj = MsgType.ItemDisplayerInfo:New()
            tmpUsedItemListObj:Decode(data.g[i])
            self.usedItemList[i] = tmpUsedItemListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpBuyItemListObj = MsgType.ItemDisplayerInfo:New()
            tmpBuyItemListObj:Decode(data.h[i])
            self.buyItemList[i] = tmpBuyItemListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        self.gameResult = data.j
    end
    if nil ~= data.k then
        self.oldGoldNum = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.newGoldNum = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.oldAPNum = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.newAPNum = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.remainStep = tonumber(data.o) or 0
    end
    return self
end

function MsgType.OfflineData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGOfflinePlayRqst = {
    msgSeq = 0,
    offlineList = {}, -- array of MsgType.OfflineData
    actionPoint = 0,
    remainTime = 0
}
MsgType.CGOfflinePlayRqst.__index = MsgType.CGOfflinePlayRqst

function MsgType.CGOfflinePlayRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGOfflinePlayRqst:GetCmd()
    return MsgTypeCmd.CG_OfflinePlayRqst
end
function MsgType.CGOfflinePlayRqst:GetUrl()
    return "CGOfflinePlayRqst"
end
function MsgType.CGOfflinePlayRqst:_offlineListEncode()
    local tb = {}
    for i=1, #self.offlineList do
        tb[i] = self.offlineList[i]:encode()
    end
    return tb
end
function MsgType.CGOfflinePlayRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self:_offlineListEncode()
    if nil ~= self.actionPoint and 0 ~= self.actionPoint then
        tb.d = self.actionPoint
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.e = self.remainTime
    end
    return tb
end

function MsgType.CGOfflinePlayRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGOfflinePlayRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCOfflinePlayRspd = {
    msgSeq = 0,
    errorCode = 0,
    goldNum = 0,
    starNum = 0,
    actionPointData = {}
}
MsgType.GCOfflinePlayRspd.__index = MsgType.GCOfflinePlayRspd
setmetatable(MsgType.GCOfflinePlayRspd.actionPointData, MsgType.ActionPointDataClient)

function MsgType.GCOfflinePlayRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCOfflinePlayRspd:GetCmd()
    return MsgTypeCmd.GC_OfflinePlayRspd
end
function MsgType.GCOfflinePlayRspd:GetUrl()
    return "GCOfflinePlayRspd"
end
function MsgType.GCOfflinePlayRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.goldNum = 0
    self.starNum = 0
    self.actionPointData = MsgType.ActionPointDataClient:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.goldNum = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.starNum = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.actionPointData:Decode(data.f)
    end
    return self
end


MsgType.TeachInDB = {
    teachID = 0,
    addTime = 0
}
MsgType.TeachInDB.__index = MsgType.TeachInDB

function MsgType.TeachInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.TeachInDB:Encode()
    local tb = {}
    if nil ~= self.teachID and 0 ~= self.teachID then
        tb.b = self.teachID
    end
    if nil ~= self.addTime and 0 ~= self.addTime then
        tb.c = self.addTime
    end
    return tb
end

function MsgType.TeachInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.teachID = 0
    self.addTime = 0
    if nil ~= data.b then
        self.teachID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.addTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.TeachInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.TeachDataInDB = {
}

MsgType.CGTeachStartRqst = {
    msgSeq = 0,
    teachID = 0
}
MsgType.CGTeachStartRqst.__index = MsgType.CGTeachStartRqst

function MsgType.CGTeachStartRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGTeachStartRqst:GetCmd()
    return MsgTypeCmd.CG_TeachStartRqst
end
function MsgType.CGTeachStartRqst:GetUrl()
    return "CGTeachStartRqst"
end
function MsgType.CGTeachStartRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.teachID and 0 ~= self.teachID then
        tb.c = self.teachID
    end
    return tb
end

function MsgType.CGTeachStartRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGTeachStartRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCTeachStartRspd = {
    msgSeq = 0,
    errorCode = 0,
    teachID = 0
}
MsgType.GCTeachStartRspd.__index = MsgType.GCTeachStartRspd

function MsgType.GCTeachStartRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCTeachStartRspd:GetCmd()
    return MsgTypeCmd.GC_TeachStartRspd
end
function MsgType.GCTeachStartRspd:GetUrl()
    return "GCTeachStartRspd"
end
function MsgType.GCTeachStartRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.teachID = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.teachID = tonumber(data.d) or 0
    end
    return self
end


MsgType.InviteInDB = {
    roleUID = 0,
    roleName = ""
}
MsgType.InviteInDB.__index = MsgType.InviteInDB

function MsgType.InviteInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.InviteInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    return tb
end

function MsgType.InviteInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.roleName = ""
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    return self
end

function MsgType.InviteInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.InviteDataInDB = {
    inviterList = {} -- array of MsgType.InviteInDB
}
MsgType.InviteDataInDB.__index = MsgType.InviteDataInDB

function MsgType.InviteDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.InviteDataInDB:_inviterListEncode()
    local tb = {}
    for i=1, #self.inviterList do
        tb[i] = self.inviterList[i]:encode()
    end
    return tb
end
function MsgType.InviteDataInDB:Encode()
    local tb = {}
    tb.b = self:_inviterListEncode()
    return tb
end

function MsgType.InviteDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.inviterList = {}
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpInviterListObj = MsgType.InviteInDB:New()
            tmpInviterListObj:Decode(data.b[i])
            self.inviterList[i] = tmpInviterListObj
        end
    end
    return self
end

function MsgType.InviteDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.BeInviterData = {
    beInviterUUID = ""
}
MsgType.BeInviterData.__index = MsgType.BeInviterData

function MsgType.BeInviterData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BeInviterData:Encode()
    local tb = {}
    if nil ~= self.beInviterUUID and string.len(self.beInviterUUID) > 0 then
        tb.b = self.beInviterUUID
    end
    return tb
end

function MsgType.BeInviterData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.beInviterUUID = ""
    if nil ~= data.b then
        self.beInviterUUID = tostring(data.b)
    end
    return self
end

function MsgType.BeInviterData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGInviteFriendRqst = {
    msgSeq = 0,
    beInviterList = {} -- array of MsgType.BeInviterData
}
MsgType.CGInviteFriendRqst.__index = MsgType.CGInviteFriendRqst

function MsgType.CGInviteFriendRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGInviteFriendRqst:GetCmd()
    return MsgTypeCmd.CG_InviteFriendRqst
end
function MsgType.CGInviteFriendRqst:GetUrl()
    return "CGInviteFriendRqst"
end
function MsgType.CGInviteFriendRqst:_beInviterListEncode()
    local tb = {}
    for i=1, #self.beInviterList do
        tb[i] = self.beInviterList[i]:encode()
    end
    return tb
end
function MsgType.CGInviteFriendRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self:_beInviterListEncode()
    return tb
end

function MsgType.CGInviteFriendRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGInviteFriendRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCInviteFriendRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCInviteFriendRspd.__index = MsgType.GCInviteFriendRspd

function MsgType.GCInviteFriendRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCInviteFriendRspd:GetCmd()
    return MsgTypeCmd.GC_InviteFriendRspd
end
function MsgType.GCInviteFriendRspd:GetUrl()
    return "GCInviteFriendRspd"
end
function MsgType.GCInviteFriendRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.EUgcLevelStatus = {
    EUgcLevelStatus_None = 0,
    EUgcLevelStatus_Online = 1,
    EUgcLevelStatus_Offline = 2,
    EUgcLevelStatus_Deleted = 3,
    EUgcLevelStatus_Guide = 4
}

MsgType.EUgcLevelBigTab = {
    EUgcLevelBigTab_ElementNum = 1,
    EUgcLevelBigTab_ElementType = 2,
    EUgcLevelBigTab_TgtType = 3,
    EUgcLevelBigTab_Star = 4,
    EUgcLevelBigTab_Difficult = 5
}

MsgType.EUgcLevelDifficult = {
    EUgcLevelDifficult_Common = 1,
    EUgcLevelDifficult_Nomal = 1,
    EUgcLevelDifficult_Hard = 1
}

MsgType.UgcLevelInDB = {
    ugcLevelID = "",
    ownerRoleUID = 0,
    createTime = 0,
    ugcLevelStatus = 0, --enum EUgcLevelStatus
    lastModifyTime = 0,
    onlineTime = 0,
    offlineTime = 0,
    ugcLevelName = "",
    limit = 0,
    like = 0,
    collect = 0,
    star = 0,
    pushCount = 0,
    playCount = 0,
    passCount = 0,
    quitCount = 0,
    targets = "",
    attributes = "",
    isPassed = 0,
    tabList = {} -- array of number
}
MsgType.UgcLevelInDB.__index = MsgType.UgcLevelInDB

function MsgType.UgcLevelInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevelInDB:Encode()
    local tb = {}
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.b = self.ugcLevelID
    end
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.c = self.ownerRoleUID
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.d = self.createTime
    end
    if nil ~= self.ugcLevelStatus and 0 ~= self.ugcLevelStatus then
        tb.e = self.ugcLevelStatus
    end
    if nil ~= self.lastModifyTime and 0 ~= self.lastModifyTime then
        tb.f = self.lastModifyTime
    end
    if nil ~= self.onlineTime and 0 ~= self.onlineTime then
        tb.g = self.onlineTime
    end
    if nil ~= self.offlineTime and 0 ~= self.offlineTime then
        tb.h = self.offlineTime
    end
    if nil ~= self.ugcLevelName and string.len(self.ugcLevelName) > 0 then
        tb.i = self.ugcLevelName
    end
    if nil ~= self.limit and 0 ~= self.limit then
        tb.j = self.limit
    end
    if nil ~= self.like and 0 ~= self.like then
        tb.k = self.like
    end
    if nil ~= self.collect and 0 ~= self.collect then
        tb.l = self.collect
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.m = self.star
    end
    if nil ~= self.pushCount and 0 ~= self.pushCount then
        tb.n = self.pushCount
    end
    if nil ~= self.playCount and 0 ~= self.playCount then
        tb.o = self.playCount
    end
    if nil ~= self.passCount and 0 ~= self.passCount then
        tb.p = self.passCount
    end
    if nil ~= self.quitCount and 0 ~= self.quitCount then
        tb.q = self.quitCount
    end
    if nil ~= self.targets and string.len(self.targets) > 0 then
        tb.r = self.targets
    end
    if nil ~= self.attributes and string.len(self.attributes) > 0 then
        tb.s = self.attributes
    end
    if nil ~= self.isPassed and 0 ~= self.isPassed then
        tb.t = self.isPassed
    end
    if nil ~= self.tabList and string.len(self.tabList) > 0 then
        tb.u = self.tabList
    end
    return tb
end

function MsgType.UgcLevelInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ugcLevelID = ""
    self.ownerRoleUID = 0
    self.createTime = 0
    self.ugcLevelStatus = 0
    self.lastModifyTime = 0
    self.onlineTime = 0
    self.offlineTime = 0
    self.ugcLevelName = ""
    self.limit = 0
    self.like = 0
    self.collect = 0
    self.star = 0
    self.pushCount = 0
    self.playCount = 0
    self.passCount = 0
    self.quitCount = 0
    self.targets = ""
    self.attributes = ""
    self.isPassed = 0
    self.tabList = {}
    if nil ~= data.b then
        self.ugcLevelID = tostring(data.b)
    end
    if nil ~= data.c then
        self.ownerRoleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.createTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.ugcLevelStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.lastModifyTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.onlineTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.offlineTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.ugcLevelName = tostring(data.i)
    end
    if nil ~= data.j then
        self.limit = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.like = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.collect = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.star = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.pushCount = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.playCount = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.passCount = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.quitCount = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.targets = tostring(data.r)
    end
    if nil ~= data.s then
        self.attributes = tostring(data.s)
    end
    if nil ~= data.t then
        self.isPassed = tonumber(data.t) or 0
    end
    if nil ~= data.u and #data.u > 0 then
        for i=1, #data.u do
            self.tabList[i] = tonumber(data.e[i] )
        end
    end
    return self
end

function MsgType.UgcLevelInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UgcLevelPushData = {
    pushPool = 0,
    pushLevel = 0,
    pushNum = 0
}
MsgType.UgcLevelPushData.__index = MsgType.UgcLevelPushData

function MsgType.UgcLevelPushData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevelPushData:Encode()
    local tb = {}
    if nil ~= self.pushPool and 0 ~= self.pushPool then
        tb.b = self.pushPool
    end
    if nil ~= self.pushLevel and 0 ~= self.pushLevel then
        tb.c = self.pushLevel
    end
    if nil ~= self.pushNum and 0 ~= self.pushNum then
        tb.d = self.pushNum
    end
    return tb
end

function MsgType.UgcLevelPushData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.pushPool = 0
    self.pushLevel = 0
    self.pushNum = 0
    if nil ~= data.b then
        self.pushPool = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.pushLevel = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.pushNum = tonumber(data.d) or 0
    end
    return self
end

function MsgType.UgcLevelPushData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelFightData = {
    insID = "",
    enterTime = 0,
    enterID = "",
    isCostAp = 0,
    isEnd = 0,
    buyStepCount = 0,
    costItems = {}, -- array of MsgType.ItemDisplayerInfo
    buyItems = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.PlayerUgcLevelFightData.__index = MsgType.PlayerUgcLevelFightData

function MsgType.PlayerUgcLevelFightData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelFightData:_costItemsEncode()
    local tb = {}
    for i=1, #self.costItems do
        tb[i] = self.costItems[i]:encode()
    end
    return tb
end
function MsgType.PlayerUgcLevelFightData:_buyItemsEncode()
    local tb = {}
    for i=1, #self.buyItems do
        tb[i] = self.buyItems[i]:encode()
    end
    return tb
end
function MsgType.PlayerUgcLevelFightData:Encode()
    local tb = {}
    if nil ~= self.insID and string.len(self.insID) > 0 then
        tb.b = self.insID
    end
    if nil ~= self.enterTime and 0 ~= self.enterTime then
        tb.c = self.enterTime
    end
    if nil ~= self.enterID and string.len(self.enterID) > 0 then
        tb.d = self.enterID
    end
    if nil ~= self.isCostAp and 0 ~= self.isCostAp then
        tb.e = self.isCostAp
    end
    if nil ~= self.isEnd and 0 ~= self.isEnd then
        tb.f = self.isEnd
    end
    if nil ~= self.buyStepCount and 0 ~= self.buyStepCount then
        tb.g = self.buyStepCount
    end
    tb.h = self:_costItemsEncode()
    tb.i = self:_buyItemsEncode()
    return tb
end

function MsgType.PlayerUgcLevelFightData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.insID = ""
    self.enterTime = 0
    self.enterID = ""
    self.isCostAp = 0
    self.isEnd = 0
    self.buyStepCount = 0
    self.costItems = {}
    self.buyItems = {}
    if nil ~= data.b then
        self.insID = tostring(data.b)
    end
    if nil ~= data.c then
        self.enterTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.enterID = tostring(data.d)
    end
    if nil ~= data.e then
        self.isCostAp = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isEnd = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.buyStepCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpCostItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpCostItemsObj:Decode(data.h[i])
            self.costItems[i] = tmpCostItemsObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpBuyItemsObj = MsgType.ItemDisplayerInfo:New()
            tmpBuyItemsObj:Decode(data.i[i])
            self.buyItems[i] = tmpBuyItemsObj
        end
    end
    return self
end

function MsgType.PlayerUgcLevelFightData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelTab2InterestValue = {
    bigTab = 0, --enum EUgcLevelBigTab
    smallTab = 0,
    interest = 0
}
MsgType.PlayerUgcLevelTab2InterestValue.__index = MsgType.PlayerUgcLevelTab2InterestValue

function MsgType.PlayerUgcLevelTab2InterestValue:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelTab2InterestValue:Encode()
    local tb = {}
    if nil ~= self.bigTab and 0 ~= self.bigTab then
        tb.b = self.bigTab
    end
    if nil ~= self.smallTab and 0 ~= self.smallTab then
        tb.c = self.smallTab
    end
    if nil ~= self.interest and 0 ~= self.interest then
        tb.d = self.interest
    end
    return tb
end

function MsgType.PlayerUgcLevelTab2InterestValue:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.bigTab = 0
    self.smallTab = 0
    self.interest = 0
    if nil ~= data.b then
        self.bigTab = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.smallTab = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.interest = tonumber(data.d) or 0
    end
    return self
end

function MsgType.PlayerUgcLevelTab2InterestValue:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelInterestData = {
    interestValueList = {} -- array of MsgType.PlayerUgcLevelTab2InterestValue
}
MsgType.PlayerUgcLevelInterestData.__index = MsgType.PlayerUgcLevelInterestData

function MsgType.PlayerUgcLevelInterestData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelInterestData:_interestValueListEncode()
    local tb = {}
    for i=1, #self.interestValueList do
        tb[i] = self.interestValueList[i]:encode()
    end
    return tb
end
function MsgType.PlayerUgcLevelInterestData:Encode()
    local tb = {}
    tb.b = self:_interestValueListEncode()
    return tb
end

function MsgType.PlayerUgcLevelInterestData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.interestValueList = {}
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpInterestValueListObj = MsgType.PlayerUgcLevelTab2InterestValue:New()
            tmpInterestValueListObj:Decode(data.b[i])
            self.interestValueList[i] = tmpInterestValueListObj
        end
    end
    return self
end

function MsgType.PlayerUgcLevelInterestData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelNewerData = {
    isPassNewerTest = 0,
    newerTestLoop = 0,
    newerTestBigTab = 0,
    isInitLevel = 0
}
MsgType.PlayerUgcLevelNewerData.__index = MsgType.PlayerUgcLevelNewerData

function MsgType.PlayerUgcLevelNewerData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelNewerData:Encode()
    local tb = {}
    if nil ~= self.isPassNewerTest and 0 ~= self.isPassNewerTest then
        tb.b = self.isPassNewerTest
    end
    if nil ~= self.newerTestLoop and 0 ~= self.newerTestLoop then
        tb.c = self.newerTestLoop
    end
    if nil ~= self.newerTestBigTab and 0 ~= self.newerTestBigTab then
        tb.d = self.newerTestBigTab
    end
    if nil ~= self.isInitLevel and 0 ~= self.isInitLevel then
        tb.e = self.isInitLevel
    end
    return tb
end

function MsgType.PlayerUgcLevelNewerData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.isPassNewerTest = 0
    self.newerTestLoop = 0
    self.newerTestBigTab = 0
    self.isInitLevel = 0
    if nil ~= data.b then
        self.isPassNewerTest = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.newerTestLoop = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.newerTestBigTab = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isInitLevel = tonumber(data.e) or 0
    end
    return self
end

function MsgType.PlayerUgcLevelNewerData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelDataInDB = {
    newerData = {},
    buyOnLineSpaceNum = 0,
    fightData = {},
    interestData = {},
    weightList = {}, -- array of number
    elementList = {}, -- array of MsgType.ElementData
    historyList = {} -- array of MsgType.ElementData
}
MsgType.PlayerUgcLevelDataInDB.__index = MsgType.PlayerUgcLevelDataInDB
setmetatable(MsgType.PlayerUgcLevelDataInDB.newerData, MsgType.PlayerUgcLevelNewerData)
setmetatable(MsgType.PlayerUgcLevelDataInDB.fightData, MsgType.PlayerUgcLevelFightData)
setmetatable(MsgType.PlayerUgcLevelDataInDB.interestData, MsgType.PlayerUgcLevelInterestData)

function MsgType.PlayerUgcLevelDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelDataInDB:_elementListEncode()
    local tb = {}
    for i=1, #self.elementList do
        tb[i] = self.elementList[i]:encode()
    end
    return tb
end
function MsgType.PlayerUgcLevelDataInDB:_historyListEncode()
    local tb = {}
    for i=1, #self.historyList do
        tb[i] = self.historyList[i]:encode()
    end
    return tb
end
function MsgType.PlayerUgcLevelDataInDB:Encode()
    local tb = {}
    tb.b = self.newerData:Encode()
    if nil ~= self.buyOnLineSpaceNum and 0 ~= self.buyOnLineSpaceNum then
        tb.c = self.buyOnLineSpaceNum
    end
    tb.d = self.fightData:Encode()
    tb.e = self.interestData:Encode()
    if nil ~= self.weightList and string.len(self.weightList) > 0 then
        tb.f = self.weightList
    end
    tb.g = self:_elementListEncode()
    tb.h = self:_historyListEncode()
    return tb
end

function MsgType.PlayerUgcLevelDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.newerData = MsgType.PlayerUgcLevelNewerData:New()
    self.buyOnLineSpaceNum = 0
    self.fightData = MsgType.PlayerUgcLevelFightData:New()
    self.interestData = MsgType.PlayerUgcLevelInterestData:New()
    self.weightList = {}
    self.elementList = {}
    self.historyList = {}
    if nil ~= data.b then
        self.newerData:Decode(data.b)
    end
    if nil ~= data.c then
        self.buyOnLineSpaceNum = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.fightData:Decode(data.d)
    end
    if nil ~= data.e then
        self.interestData:Decode(data.e)
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.weightList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpElementListObj = MsgType.ElementData:New()
            tmpElementListObj:Decode(data.g[i])
            self.elementList[i] = tmpElementListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpHistoryListObj = MsgType.ElementData:New()
            tmpHistoryListObj:Decode(data.h[i])
            self.historyList[i] = tmpHistoryListObj
        end
    end
    return self
end

function MsgType.PlayerUgcLevelDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerUgcLevelHistoryInDB = {
    passTime = 0,
    star = 0
}
MsgType.PlayerUgcLevelHistoryInDB.__index = MsgType.PlayerUgcLevelHistoryInDB

function MsgType.PlayerUgcLevelHistoryInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerUgcLevelHistoryInDB:Encode()
    local tb = {}
    if nil ~= self.passTime and 0 ~= self.passTime then
        tb.b = self.passTime
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.c = self.star
    end
    return tb
end

function MsgType.PlayerUgcLevelHistoryInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.passTime = 0
    self.star = 0
    if nil ~= data.b then
        self.passTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.star = tonumber(data.c) or 0
    end
    return self
end

function MsgType.PlayerUgcLevelHistoryInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UgcLevelPassHistoryInDB = {
    roleUID = 0,
    passTime = 0,
    star = 0
}
MsgType.UgcLevelPassHistoryInDB.__index = MsgType.UgcLevelPassHistoryInDB

function MsgType.UgcLevelPassHistoryInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevelPassHistoryInDB:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.passTime and 0 ~= self.passTime then
        tb.c = self.passTime
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.d = self.star
    end
    return tb
end

function MsgType.UgcLevelPassHistoryInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.passTime = 0
    self.star = 0
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.passTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.star = tonumber(data.d) or 0
    end
    return self
end

function MsgType.UgcLevelPassHistoryInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EUgcLevelOptType = {
    EUgcLevelOptType_Create = 1,
    EUgcLevelOptType_Edit = 2,
    EUgcLevelOptType_Delete = 3,
    EUgcLevelOptType_Like = 4,
    EUgcLevelOptType_Collect = 5,
    EUgcLevelOptType_Upload = 6,
    EUgcLevelOptType_Down = 7,
    EUgcLevelOptType_BuyFactory = 8,
    EUgcLevelOptType_Star = 9,
    EUgcLevelOptType_QueryUploadCost = 10,
    EUgcLevelOptType_Rename = 11,
    EUgcLevelOptType_Follow = 12,
    EUgcLevelOptType_CancelFollow = 13
}

MsgType.EUgcLevelErrorCode = {
    EUgcLevelErrorCode_Success = 3900,
    EUgcLevelErrorCode_Failed = 3901,
    EUgcLevelErrorCode_LevelOffline = 3902,
    EUgcLevelErrorCode_OnlineLimit = 3903,
    EUgcLevelErrorCode_UgcGoldNotEnough = 3904,
    EUgcLevelErrorCode_LevelNotExist = 3905,
    EUgcLevelErrorCode_ApNotEnough = 3906
}

MsgType.UgcLevel = {
    ugcLevelID = "",
    ownerRoleUID = 0,
    ownerRoleName = "",
    ownerPortraitID = 0,
    createTime = 0,
    ugcLevelStatus = 0, --enum EUgcLevelStatus
    lastModifyTime = 0,
    onlineTime = 0,
    offlineTime = 0,
    ugcLevelName = "",
    targets = "",
    limit = 0,
    like = 0,
    collect = 0,
    star = 0,
    playCount = 0,
    passRate = 0,
    isPlayed = 0,
    isPassed = 0,
    tab = 0,
    isFollowed = 0
}
MsgType.UgcLevel.__index = MsgType.UgcLevel

function MsgType.UgcLevel:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevel:Encode()
    local tb = {}
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.b = self.ugcLevelID
    end
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.c = self.ownerRoleUID
    end
    if nil ~= self.ownerRoleName and string.len(self.ownerRoleName) > 0 then
        tb.d = self.ownerRoleName
    end
    if nil ~= self.ownerPortraitID and 0 ~= self.ownerPortraitID then
        tb.e = self.ownerPortraitID
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.f = self.createTime
    end
    if nil ~= self.ugcLevelStatus and 0 ~= self.ugcLevelStatus then
        tb.g = self.ugcLevelStatus
    end
    if nil ~= self.lastModifyTime and 0 ~= self.lastModifyTime then
        tb.h = self.lastModifyTime
    end
    if nil ~= self.onlineTime and 0 ~= self.onlineTime then
        tb.i = self.onlineTime
    end
    if nil ~= self.offlineTime and 0 ~= self.offlineTime then
        tb.j = self.offlineTime
    end
    if nil ~= self.ugcLevelName and string.len(self.ugcLevelName) > 0 then
        tb.k = self.ugcLevelName
    end
    if nil ~= self.targets and string.len(self.targets) > 0 then
        tb.l = self.targets
    end
    if nil ~= self.limit and 0 ~= self.limit then
        tb.m = self.limit
    end
    if nil ~= self.like and 0 ~= self.like then
        tb.n = self.like
    end
    if nil ~= self.collect and 0 ~= self.collect then
        tb.o = self.collect
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.p = self.star
    end
    if nil ~= self.playCount and 0 ~= self.playCount then
        tb.q = self.playCount
    end
    if nil ~= self.passRate and 0 ~= self.passRate then
        tb.r = self.passRate
    end
    if nil ~= self.isPlayed and 0 ~= self.isPlayed then
        tb.s = self.isPlayed
    end
    if nil ~= self.isPassed and 0 ~= self.isPassed then
        tb.t = self.isPassed
    end
    if nil ~= self.tab and 0 ~= self.tab then
        tb.u = self.tab
    end
    if nil ~= self.isFollowed and 0 ~= self.isFollowed then
        tb.v = self.isFollowed
    end
    return tb
end

function MsgType.UgcLevel:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ugcLevelID = ""
    self.ownerRoleUID = 0
    self.ownerRoleName = ""
    self.ownerPortraitID = 0
    self.createTime = 0
    self.ugcLevelStatus = 0
    self.lastModifyTime = 0
    self.onlineTime = 0
    self.offlineTime = 0
    self.ugcLevelName = ""
    self.targets = ""
    self.limit = 0
    self.like = 0
    self.collect = 0
    self.star = 0
    self.playCount = 0
    self.passRate = 0
    self.isPlayed = 0
    self.isPassed = 0
    self.tab = 0
    self.isFollowed = 0
    if nil ~= data.b then
        self.ugcLevelID = tostring(data.b)
    end
    if nil ~= data.c then
        self.ownerRoleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ownerRoleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.ownerPortraitID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.createTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.ugcLevelStatus = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.lastModifyTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.onlineTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.offlineTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.ugcLevelName = tostring(data.k)
    end
    if nil ~= data.l then
        self.targets = tostring(data.l)
    end
    if nil ~= data.m then
        self.limit = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.like = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.collect = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.star = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.playCount = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.passRate = tonumber(data.r) or 0
    end
    if nil ~= data.s then
        self.isPlayed = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        self.isPassed = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.tab = tonumber(data.u) or 0
    end
    if nil ~= data.v then
        self.isFollowed = tonumber(data.v) or 0
    end
    return self
end

function MsgType.UgcLevel:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UgcLevelIDWrapper = {
    ugcLevelID = ""
}
MsgType.UgcLevelIDWrapper.__index = MsgType.UgcLevelIDWrapper

function MsgType.UgcLevelIDWrapper:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevelIDWrapper:Encode()
    local tb = {}
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.b = self.ugcLevelID
    end
    return tb
end

function MsgType.UgcLevelIDWrapper:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ugcLevelID = ""
    if nil ~= data.b then
        self.ugcLevelID = tostring(data.b)
    end
    return self
end

function MsgType.UgcLevelIDWrapper:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.UgcLevelDetail = {
    ugcLevelID = "",
    ugcLevel = {},
    ugcLevelData = ""
}
MsgType.UgcLevelDetail.__index = MsgType.UgcLevelDetail
setmetatable(MsgType.UgcLevelDetail.ugcLevel, MsgType.UgcLevel)

function MsgType.UgcLevelDetail:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UgcLevelDetail:Encode()
    local tb = {}
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.b = self.ugcLevelID
    end
    tb.c = self.ugcLevel:Encode()
    if nil ~= self.ugcLevelData and string.len(self.ugcLevelData) > 0 then
        tb.d = self.ugcLevelData
    end
    return tb
end

function MsgType.UgcLevelDetail:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ugcLevelID = ""
    self.ugcLevel = MsgType.UgcLevel:New()
    self.ugcLevelData = ""
    if nil ~= data.b then
        self.ugcLevelID = tostring(data.b)
    end
    if nil ~= data.c then
        self.ugcLevel:Decode(data.c)
    end
    if nil ~= data.d then
        self.ugcLevelData = tostring(data.d)
    end
    return self
end

function MsgType.UgcLevelDetail:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGUgcLevelOptRqst = {
    msgSeq = 0,
    optType = 0, --enum EUgcLevelOptType
    ugcLevelID = "",
    ugcLevelName = "",
    ugcLevelData = "",
    statusType = 0, --enum EUgcLevelStatus
    star = 0,
    tab = 0,
    ownerRoleUID = 0
}
MsgType.CGUgcLevelOptRqst.__index = MsgType.CGUgcLevelOptRqst

function MsgType.CGUgcLevelOptRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelOptRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelOptRqst
end
function MsgType.CGUgcLevelOptRqst:GetUrl()
    return "CGUgcLevelOptRqst"
end
function MsgType.CGUgcLevelOptRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.optType and 0 ~= self.optType then
        tb.c = self.optType
    end
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.d = self.ugcLevelID
    end
    if nil ~= self.ugcLevelName and string.len(self.ugcLevelName) > 0 then
        tb.e = self.ugcLevelName
    end
    if nil ~= self.ugcLevelData and string.len(self.ugcLevelData) > 0 then
        tb.f = self.ugcLevelData
    end
    if nil ~= self.statusType and 0 ~= self.statusType then
        tb.g = self.statusType
    end
    if nil ~= self.star and 0 ~= self.star then
        tb.h = self.star
    end
    if nil ~= self.tab and 0 ~= self.tab then
        tb.i = self.tab
    end
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.j = self.ownerRoleUID
    end
    return tb
end

function MsgType.CGUgcLevelOptRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelOptRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelOptRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    optType = 0, --enum EUgcLevelOptType
    ugcLevelID = "",
    ugcLevelName = "",
    uploadCost = 0
}
MsgType.GCUgcLevelOptRspd.__index = MsgType.GCUgcLevelOptRspd

function MsgType.GCUgcLevelOptRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelOptRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelOptRspd
end
function MsgType.GCUgcLevelOptRspd:GetUrl()
    return "GCUgcLevelOptRspd"
end
function MsgType.GCUgcLevelOptRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.optType = 0
    self.ugcLevelID = ""
    self.ugcLevelName = ""
    self.uploadCost = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.optType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.ugcLevelID = tostring(data.e)
    end
    if nil ~= data.f then
        self.ugcLevelName = tostring(data.f)
    end
    if nil ~= data.g then
        self.uploadCost = tonumber(data.g) or 0
    end
    return self
end


MsgType.CGUgcGetCreatorInfoRqst = {
    msgSeq = 0,
    ownerRoleUID = 0
}
MsgType.CGUgcGetCreatorInfoRqst.__index = MsgType.CGUgcGetCreatorInfoRqst

function MsgType.CGUgcGetCreatorInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcGetCreatorInfoRqst:GetCmd()
    return MsgTypeCmd.CG_UgcGetCreatorInfoRqst
end
function MsgType.CGUgcGetCreatorInfoRqst:GetUrl()
    return "CGUgcGetCreatorInfoRqst"
end
function MsgType.CGUgcGetCreatorInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.c = self.ownerRoleUID
    end
    return tb
end

function MsgType.CGUgcGetCreatorInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcGetCreatorInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcGetCreatorInfoRspd = {
    msgSeq = 0,
    ownerRoleUID = 0,
    ownerRoleName = "",
    ownerPortraitID = 0,
    followCount = 0,
    fansCount = 0,
    wPoint = 0,
    bPoint = 0,
    introduction = "",
    total = 0,
    isFollowed = 0
}
MsgType.GCUgcGetCreatorInfoRspd.__index = MsgType.GCUgcGetCreatorInfoRspd

function MsgType.GCUgcGetCreatorInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcGetCreatorInfoRspd:GetCmd()
    return MsgTypeCmd.GC_UgcGetCreatorInfoRspd
end
function MsgType.GCUgcGetCreatorInfoRspd:GetUrl()
    return "GCUgcGetCreatorInfoRspd"
end
function MsgType.GCUgcGetCreatorInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.ownerRoleUID = 0
    self.ownerRoleName = ""
    self.ownerPortraitID = 0
    self.followCount = 0
    self.fansCount = 0
    self.wPoint = 0
    self.bPoint = 0
    self.introduction = ""
    self.total = 0
    self.isFollowed = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.ownerRoleUID = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ownerRoleName = tostring(data.d)
    end
    if nil ~= data.e then
        self.ownerPortraitID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.followCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.fansCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.wPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.bPoint = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.introduction = tostring(data.j)
    end
    if nil ~= data.k then
        self.total = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.isFollowed = tonumber(data.l) or 0
    end
    return self
end


MsgType.EUgcEditIntrErrorCode = {
    EUgcEditIntrErrorCode_Success = 4000,
    EUgcEditIntrErrorCode_Failed = 4001
}

MsgType.CGUgcEditIntrRqst = {
    msgSeq = 0,
    introduction = ""
}
MsgType.CGUgcEditIntrRqst.__index = MsgType.CGUgcEditIntrRqst

function MsgType.CGUgcEditIntrRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcEditIntrRqst:GetCmd()
    return MsgTypeCmd.CG_UgcEditIntrRqst
end
function MsgType.CGUgcEditIntrRqst:GetUrl()
    return "CGUgcEditIntrRqst"
end
function MsgType.CGUgcEditIntrRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.introduction and string.len(self.introduction) > 0 then
        tb.c = self.introduction
    end
    return tb
end

function MsgType.CGUgcEditIntrRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcEditIntrRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcEditIntrRspd = {
    msgSeq = 0,
    errorCode = 0 --enum EUgcEditIntrErrorCode
}
MsgType.GCUgcEditIntrRspd.__index = MsgType.GCUgcEditIntrRspd

function MsgType.GCUgcEditIntrRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcEditIntrRspd:GetCmd()
    return MsgTypeCmd.GC_UgcEditIntrRspd
end
function MsgType.GCUgcEditIntrRspd:GetUrl()
    return "GCUgcEditIntrRspd"
end
function MsgType.GCUgcEditIntrRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGUgcGetOwnerLevelRqst = {
    msgSeq = 0,
    ownerRoleUID = 0,
    clientIndex = 0
}
MsgType.CGUgcGetOwnerLevelRqst.__index = MsgType.CGUgcGetOwnerLevelRqst

function MsgType.CGUgcGetOwnerLevelRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcGetOwnerLevelRqst:GetCmd()
    return MsgTypeCmd.CG_UgcGetOwnerLevelRqst
end
function MsgType.CGUgcGetOwnerLevelRqst:GetUrl()
    return "CGUgcGetOwnerLevelRqst"
end
function MsgType.CGUgcGetOwnerLevelRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ownerRoleUID and 0 ~= self.ownerRoleUID then
        tb.c = self.ownerRoleUID
    end
    if nil ~= self.clientIndex and 0 ~= self.clientIndex then
        tb.d = self.clientIndex
    end
    return tb
end

function MsgType.CGUgcGetOwnerLevelRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcGetOwnerLevelRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcGetOwnerLevelRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    clientIndex = 0,
    ugcLevelDataList = {} -- array of MsgType.UgcLevelDetail
}
MsgType.GCUgcGetOwnerLevelRspd.__index = MsgType.GCUgcGetOwnerLevelRspd

function MsgType.GCUgcGetOwnerLevelRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcGetOwnerLevelRspd:GetCmd()
    return MsgTypeCmd.GC_UgcGetOwnerLevelRspd
end
function MsgType.GCUgcGetOwnerLevelRspd:GetUrl()
    return "GCUgcGetOwnerLevelRspd"
end
function MsgType.GCUgcGetOwnerLevelRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.clientIndex = 0
    self.ugcLevelDataList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.clientIndex = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpUgcLevelDataListObj = MsgType.UgcLevelDetail:New()
            tmpUgcLevelDataListObj:Decode(data.e[i])
            self.ugcLevelDataList[i] = tmpUgcLevelDataListObj
        end
    end
    return self
end


MsgType.CGUgcLevelGetListRqst = {
    msgSeq = 0,
    statusType = 0, --enum EUgcLevelStatus
    page = 0,
    rows = 0,
    total = 0
}
MsgType.CGUgcLevelGetListRqst.__index = MsgType.CGUgcLevelGetListRqst

function MsgType.CGUgcLevelGetListRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelGetListRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelGetListRqst
end
function MsgType.CGUgcLevelGetListRqst:GetUrl()
    return "CGUgcLevelGetListRqst"
end
function MsgType.CGUgcLevelGetListRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.statusType and 0 ~= self.statusType then
        tb.c = self.statusType
    end
    if nil ~= self.page and 0 ~= self.page then
        tb.d = self.page
    end
    if nil ~= self.rows and 0 ~= self.rows then
        tb.e = self.rows
    end
    if nil ~= self.total and 0 ~= self.total then
        tb.f = self.total
    end
    return tb
end

function MsgType.CGUgcLevelGetListRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelGetListRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelGetListRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    statusType = 0, --enum EUgcLevelStatus
    page = 0,
    rows = 0,
    total = 0,
    levelList = {} -- array of MsgType.UgcLevelDetail
}
MsgType.GCUgcLevelGetListRspd.__index = MsgType.GCUgcLevelGetListRspd

function MsgType.GCUgcLevelGetListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelGetListRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelGetListRspd
end
function MsgType.GCUgcLevelGetListRspd:GetUrl()
    return "GCUgcLevelGetListRspd"
end
function MsgType.GCUgcLevelGetListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.statusType = 0
    self.page = 0
    self.rows = 0
    self.total = 0
    self.levelList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.statusType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.page = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rows = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.total = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpLevelListObj = MsgType.UgcLevelDetail:New()
            tmpLevelListObj:Decode(data.h[i])
            self.levelList[i] = tmpLevelListObj
        end
    end
    return self
end


MsgType.CGUgcLevelGetDetailRqst = {
    msgSeq = 0,
    ugcLevelIDList = {}
}
MsgType.CGUgcLevelGetDetailRqst.__index = MsgType.CGUgcLevelGetDetailRqst

function MsgType.CGUgcLevelGetDetailRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelGetDetailRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelGetDetailRqst
end
function MsgType.CGUgcLevelGetDetailRqst:GetUrl()
    return "CGUgcLevelGetDetailRqst"
end
function MsgType.CGUgcLevelGetDetailRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ugcLevelIDList and string.len(self.ugcLevelIDList) > 0 then
        tb.c = self.ugcLevelIDList
    end
    return tb
end

function MsgType.CGUgcLevelGetDetailRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelGetDetailRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelGetDetailRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelDataList = {} -- array of MsgType.UgcLevelDetail
}
MsgType.GCUgcLevelGetDetailRspd.__index = MsgType.GCUgcLevelGetDetailRspd

function MsgType.GCUgcLevelGetDetailRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelGetDetailRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelGetDetailRspd
end
function MsgType.GCUgcLevelGetDetailRspd:GetUrl()
    return "GCUgcLevelGetDetailRspd"
end
function MsgType.GCUgcLevelGetDetailRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelDataList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpUgcLevelDataListObj = MsgType.UgcLevelDetail:New()
            tmpUgcLevelDataListObj:Decode(data.d[i])
            self.ugcLevelDataList[i] = tmpUgcLevelDataListObj
        end
    end
    return self
end


MsgType.CGUgcLevelPlayStartRqst = {
    msgSeq = 0,
    ugcLevelID = "",
    selectItemList = ""
}
MsgType.CGUgcLevelPlayStartRqst.__index = MsgType.CGUgcLevelPlayStartRqst

function MsgType.CGUgcLevelPlayStartRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelPlayStartRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelPlayStartRqst
end
function MsgType.CGUgcLevelPlayStartRqst:GetUrl()
    return "CGUgcLevelPlayStartRqst"
end
function MsgType.CGUgcLevelPlayStartRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.c = self.ugcLevelID
    end
    if nil ~= self.selectItemList and string.len(self.selectItemList) > 0 then
        tb.d = self.selectItemList
    end
    return tb
end

function MsgType.CGUgcLevelPlayStartRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelPlayStartRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelPlayStartRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelID = "",
    selectItemList = ""
}
MsgType.GCUgcLevelPlayStartRspd.__index = MsgType.GCUgcLevelPlayStartRspd

function MsgType.GCUgcLevelPlayStartRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelPlayStartRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelPlayStartRspd
end
function MsgType.GCUgcLevelPlayStartRspd:GetUrl()
    return "GCUgcLevelPlayStartRspd"
end
function MsgType.GCUgcLevelPlayStartRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelID = ""
    self.selectItemList = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ugcLevelID = tostring(data.d)
    end
    if nil ~= data.e then
        self.selectItemList = tostring(data.e)
    end
    return self
end


MsgType.CGUgcLevelPlayEndRqst = {
    msgSeq = 0,
    ugcLevelID = "",
    singleCopyCalcType = 0, --enum ESingleCopyCalcType
    resultInfo = {},
    chkData = {}
}
MsgType.CGUgcLevelPlayEndRqst.__index = MsgType.CGUgcLevelPlayEndRqst
setmetatable(MsgType.CGUgcLevelPlayEndRqst.resultInfo, MsgType.SingleCopyResultInfo)
setmetatable(MsgType.CGUgcLevelPlayEndRqst.chkData, MsgType.LevelCheckData)

function MsgType.CGUgcLevelPlayEndRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelPlayEndRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelPlayEndRqst
end
function MsgType.CGUgcLevelPlayEndRqst:GetUrl()
    return "CGUgcLevelPlayEndRqst"
end
function MsgType.CGUgcLevelPlayEndRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.c = self.ugcLevelID
    end
    if nil ~= self.singleCopyCalcType and 0 ~= self.singleCopyCalcType then
        tb.d = self.singleCopyCalcType
    end
    tb.e = self.resultInfo:Encode()
    tb.f = self.chkData:Encode()
    return tb
end

function MsgType.CGUgcLevelPlayEndRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelPlayEndRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelPlayEndRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelID = "",
    rewards = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCUgcLevelPlayEndRspd.__index = MsgType.GCUgcLevelPlayEndRspd

function MsgType.GCUgcLevelPlayEndRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelPlayEndRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelPlayEndRspd
end
function MsgType.GCUgcLevelPlayEndRspd:GetUrl()
    return "GCUgcLevelPlayEndRspd"
end
function MsgType.GCUgcLevelPlayEndRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelID = ""
    self.rewards = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ugcLevelID = tostring(data.d)
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRewardsObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardsObj:Decode(data.e[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    return self
end


MsgType.CGUgcLevelMatchRqst = {
    msgSeq = 0,
    clientIndex = 0
}
MsgType.CGUgcLevelMatchRqst.__index = MsgType.CGUgcLevelMatchRqst

function MsgType.CGUgcLevelMatchRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelMatchRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelMatchRqst
end
function MsgType.CGUgcLevelMatchRqst:GetUrl()
    return "CGUgcLevelMatchRqst"
end
function MsgType.CGUgcLevelMatchRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.clientIndex and 0 ~= self.clientIndex then
        tb.c = self.clientIndex
    end
    return tb
end

function MsgType.CGUgcLevelMatchRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelMatchRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelMatchRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelDataList = {}, -- array of MsgType.UgcLevelDetail
    clientIndex = 0
}
MsgType.GCUgcLevelMatchRspd.__index = MsgType.GCUgcLevelMatchRspd

function MsgType.GCUgcLevelMatchRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelMatchRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelMatchRspd
end
function MsgType.GCUgcLevelMatchRspd:GetUrl()
    return "GCUgcLevelMatchRspd"
end
function MsgType.GCUgcLevelMatchRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelDataList = {}
    self.clientIndex = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpUgcLevelDataListObj = MsgType.UgcLevelDetail:New()
            tmpUgcLevelDataListObj:Decode(data.d[i])
            self.ugcLevelDataList[i] = tmpUgcLevelDataListObj
        end
    end
    if nil ~= data.e then
        self.clientIndex = tonumber(data.e) or 0
    end
    return self
end


MsgType.CGUgcLevelSearchRqst = {
    msgSeq = 0,
    ugcLevelID = ""
}
MsgType.CGUgcLevelSearchRqst.__index = MsgType.CGUgcLevelSearchRqst

function MsgType.CGUgcLevelSearchRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelSearchRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelSearchRqst
end
function MsgType.CGUgcLevelSearchRqst:GetUrl()
    return "CGUgcLevelSearchRqst"
end
function MsgType.CGUgcLevelSearchRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.c = self.ugcLevelID
    end
    return tb
end

function MsgType.CGUgcLevelSearchRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelSearchRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelSearchRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelData = {}
}
MsgType.GCUgcLevelSearchRspd.__index = MsgType.GCUgcLevelSearchRspd
setmetatable(MsgType.GCUgcLevelSearchRspd.ugcLevelData, MsgType.UgcLevelDetail)

function MsgType.GCUgcLevelSearchRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelSearchRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelSearchRspd
end
function MsgType.GCUgcLevelSearchRspd:GetUrl()
    return "GCUgcLevelSearchRspd"
end
function MsgType.GCUgcLevelSearchRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelData = MsgType.UgcLevelDetail:New()
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ugcLevelData:Decode(data.d)
    end
    return self
end


MsgType.CGUgcLevelSelfTestRqst = {
    msgSeq = 0,
    ugcLevelID = "",
    chkData = {}
}
MsgType.CGUgcLevelSelfTestRqst.__index = MsgType.CGUgcLevelSelfTestRqst
setmetatable(MsgType.CGUgcLevelSelfTestRqst.chkData, MsgType.LevelCheckData)

function MsgType.CGUgcLevelSelfTestRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGUgcLevelSelfTestRqst:GetCmd()
    return MsgTypeCmd.CG_UgcLevelSelfTestRqst
end
function MsgType.CGUgcLevelSelfTestRqst:GetUrl()
    return "CGUgcLevelSelfTestRqst"
end
function MsgType.CGUgcLevelSelfTestRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.ugcLevelID and string.len(self.ugcLevelID) > 0 then
        tb.c = self.ugcLevelID
    end
    tb.d = self.chkData:Encode()
    return tb
end

function MsgType.CGUgcLevelSelfTestRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGUgcLevelSelfTestRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCUgcLevelSelfTestRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelID = ""
}
MsgType.GCUgcLevelSelfTestRspd.__index = MsgType.GCUgcLevelSelfTestRspd

function MsgType.GCUgcLevelSelfTestRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelSelfTestRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelSelfTestRspd
end
function MsgType.GCUgcLevelSelfTestRspd:GetUrl()
    return "GCUgcLevelSelfTestRspd"
end
function MsgType.GCUgcLevelSelfTestRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelID = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ugcLevelID = tostring(data.d)
    end
    return self
end


MsgType.WeightData = {
    id = 0,
    weight = 0
}
MsgType.WeightData.__index = MsgType.WeightData

function MsgType.WeightData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WeightData:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.weight and 0 ~= self.weight then
        tb.c = self.weight
    end
    return tb
end

function MsgType.WeightData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.id = 0
    self.weight = 0
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.weight = tonumber(data.c) or 0
    end
    return self
end

function MsgType.WeightData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ElementData = {
    attributeID = 0,
    matchNum = 0
}
MsgType.ElementData.__index = MsgType.ElementData

function MsgType.ElementData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ElementData:Encode()
    local tb = {}
    if nil ~= self.attributeID and 0 ~= self.attributeID then
        tb.b = self.attributeID
    end
    if nil ~= self.matchNum and 0 ~= self.matchNum then
        tb.c = self.matchNum
    end
    return tb
end

function MsgType.ElementData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.attributeID = 0
    self.matchNum = 0
    if nil ~= data.b then
        self.attributeID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.matchNum = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ElementData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GCUgcLevelCountInitRspd = {
    msgSeq = 0,
    weightList = {}, -- array of MsgType.WeightData
    elementList = {}, -- array of MsgType.ElementData
    historyList = {} -- array of MsgType.ElementData
}
MsgType.GCUgcLevelCountInitRspd.__index = MsgType.GCUgcLevelCountInitRspd

function MsgType.GCUgcLevelCountInitRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelCountInitRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelCountInitRspd
end
function MsgType.GCUgcLevelCountInitRspd:GetUrl()
    return "GCUgcLevelCountInitRspd"
end
function MsgType.GCUgcLevelCountInitRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.weightList = {}
    self.elementList = {}
    self.historyList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpWeightListObj = MsgType.WeightData:New()
            tmpWeightListObj:Decode(data.c[i])
            self.weightList[i] = tmpWeightListObj
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpElementListObj = MsgType.ElementData:New()
            tmpElementListObj:Decode(data.d[i])
            self.elementList[i] = tmpElementListObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpHistoryListObj = MsgType.ElementData:New()
            tmpHistoryListObj:Decode(data.e[i])
            self.historyList[i] = tmpHistoryListObj
        end
    end
    return self
end


MsgType.GCUgcLevelCountMatchRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    ugcLevelID = "",
    matchID = 0,
    matchString = "",
    weightList = {}, -- array of MsgType.WeightData
    elementList = {}, -- array of MsgType.ElementData
    historyList = {} -- array of MsgType.ElementData
}
MsgType.GCUgcLevelCountMatchRspd.__index = MsgType.GCUgcLevelCountMatchRspd

function MsgType.GCUgcLevelCountMatchRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcLevelCountMatchRspd:GetCmd()
    return MsgTypeCmd.GC_UgcLevelCountMatchRspd
end
function MsgType.GCUgcLevelCountMatchRspd:GetUrl()
    return "GCUgcLevelCountMatchRspd"
end
function MsgType.GCUgcLevelCountMatchRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.ugcLevelID = ""
    self.matchID = 0
    self.matchString = ""
    self.weightList = {}
    self.elementList = {}
    self.historyList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.ugcLevelID = tostring(data.d)
    end
    if nil ~= data.e then
        self.matchID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.matchString = tostring(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpWeightListObj = MsgType.WeightData:New()
            tmpWeightListObj:Decode(data.g[i])
            self.weightList[i] = tmpWeightListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpElementListObj = MsgType.ElementData:New()
            tmpElementListObj:Decode(data.h[i])
            self.elementList[i] = tmpElementListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpHistoryListObj = MsgType.ElementData:New()
            tmpHistoryListObj:Decode(data.i[i])
            self.historyList[i] = tmpHistoryListObj
        end
    end
    return self
end


MsgType.EEveryDayTaskType = {
    EEveryDayTaskType_PassLevel = 1,
    EEveryDayTaskType_PassUgcLevel = 2,
    EEveryDayTaskType_UploadUgcLevel = 3,
    EEveryDayTaskType_Share = 4,
    EEveryDayTaskType_Invitation = 5,
    EEveryDayTaskType_SendAp = 6,
    EEveryDayTaskType_Login = 7,
    EEveryDayTaskType_Turntable = 8,
    EEveryDayTaskType_LevelCostItem = 9,
    EEveryDayTaskType_Ad = 10
}

MsgType.EveryDayTaskInDB = {
    taskID = 0,
    progress = 0,
    isRewarded = 0
}
MsgType.EveryDayTaskInDB.__index = MsgType.EveryDayTaskInDB

function MsgType.EveryDayTaskInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EveryDayTaskInDB:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.progress and 0 ~= self.progress then
        tb.c = self.progress
    end
    if nil ~= self.isRewarded and 0 ~= self.isRewarded then
        tb.d = self.isRewarded
    end
    return tb
end

function MsgType.EveryDayTaskInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.progress = 0
    self.isRewarded = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.progress = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isRewarded = tonumber(data.d) or 0
    end
    return self
end

function MsgType.EveryDayTaskInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.PlayerEveryDayTaskDataInDB = {
    refreshTime = 0,
    mark = 0,
    rewardFlag = 0,
    taskList = {} -- array of MsgType.EveryDayTaskInDB
}
MsgType.PlayerEveryDayTaskDataInDB.__index = MsgType.PlayerEveryDayTaskDataInDB

function MsgType.PlayerEveryDayTaskDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerEveryDayTaskDataInDB:_taskListEncode()
    local tb = {}
    for i=1, #self.taskList do
        tb[i] = self.taskList[i]:encode()
    end
    return tb
end
function MsgType.PlayerEveryDayTaskDataInDB:Encode()
    local tb = {}
    if nil ~= self.refreshTime and 0 ~= self.refreshTime then
        tb.b = self.refreshTime
    end
    if nil ~= self.mark and 0 ~= self.mark then
        tb.c = self.mark
    end
    if nil ~= self.rewardFlag and 0 ~= self.rewardFlag then
        tb.d = self.rewardFlag
    end
    tb.e = self:_taskListEncode()
    return tb
end

function MsgType.PlayerEveryDayTaskDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.refreshTime = 0
    self.mark = 0
    self.rewardFlag = 0
    self.taskList = {}
    if nil ~= data.b then
        self.refreshTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.mark = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardFlag = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpTaskListObj = MsgType.EveryDayTaskInDB:New()
            tmpTaskListObj:Decode(data.e[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end

function MsgType.PlayerEveryDayTaskDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EveryDayTask = {
    taskID = 0,
    target = 0,
    progress = 0,
    mark = 0
}
MsgType.EveryDayTask.__index = MsgType.EveryDayTask

function MsgType.EveryDayTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EveryDayTask:Encode()
    local tb = {}
    if nil ~= self.taskID and 0 ~= self.taskID then
        tb.b = self.taskID
    end
    if nil ~= self.target and 0 ~= self.target then
        tb.c = self.target
    end
    if nil ~= self.progress and 0 ~= self.progress then
        tb.d = self.progress
    end
    if nil ~= self.mark and 0 ~= self.mark then
        tb.e = self.mark
    end
    return tb
end

function MsgType.EveryDayTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.taskID = 0
    self.target = 0
    self.progress = 0
    self.mark = 0
    if nil ~= data.b then
        self.taskID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.target = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.progress = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.mark = tonumber(data.e) or 0
    end
    return self
end

function MsgType.EveryDayTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EveryDayBox = {
    rewardID = 0,
    mark = 0,
    isRewarded = 0
}
MsgType.EveryDayBox.__index = MsgType.EveryDayBox

function MsgType.EveryDayBox:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EveryDayBox:Encode()
    local tb = {}
    if nil ~= self.rewardID and 0 ~= self.rewardID then
        tb.b = self.rewardID
    end
    if nil ~= self.mark and 0 ~= self.mark then
        tb.c = self.mark
    end
    if nil ~= self.isRewarded and 0 ~= self.isRewarded then
        tb.d = self.isRewarded
    end
    return tb
end

function MsgType.EveryDayBox:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.rewardID = 0
    self.mark = 0
    self.isRewarded = 0
    if nil ~= data.b then
        self.rewardID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.mark = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isRewarded = tonumber(data.d) or 0
    end
    return self
end

function MsgType.EveryDayBox:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGEveryDayTaskInfoRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGEveryDayTaskInfoRqst.__index = MsgType.CGEveryDayTaskInfoRqst

function MsgType.CGEveryDayTaskInfoRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEveryDayTaskInfoRqst:GetCmd()
    return MsgTypeCmd.CG_EveryDayTaskInfoRqst
end
function MsgType.CGEveryDayTaskInfoRqst:GetUrl()
    return "CGEveryDayTaskInfoRqst"
end
function MsgType.CGEveryDayTaskInfoRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGEveryDayTaskInfoRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEveryDayTaskInfoRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEveryDayTaskInfoRspd = {
    msgSeq = 0,
    errorCode = 0,
    taskList = {}, -- array of MsgType.EveryDayTask
    boxList = {}, -- array of MsgType.EveryDayBox
    totalMark = 0,
    maxMark = 0
}
MsgType.GCEveryDayTaskInfoRspd.__index = MsgType.GCEveryDayTaskInfoRspd

function MsgType.GCEveryDayTaskInfoRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEveryDayTaskInfoRspd:GetCmd()
    return MsgTypeCmd.GC_EveryDayTaskInfoRspd
end
function MsgType.GCEveryDayTaskInfoRspd:GetUrl()
    return "GCEveryDayTaskInfoRspd"
end
function MsgType.GCEveryDayTaskInfoRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.taskList = {}
    self.boxList = {}
    self.totalMark = 0
    self.maxMark = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpTaskListObj = MsgType.EveryDayTask:New()
            tmpTaskListObj:Decode(data.d[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpBoxListObj = MsgType.EveryDayBox:New()
            tmpBoxListObj:Decode(data.e[i])
            self.boxList[i] = tmpBoxListObj
        end
    end
    if nil ~= data.f then
        self.totalMark = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.maxMark = tonumber(data.g) or 0
    end
    return self
end


MsgType.CGEveryDayTaskRewardRqst = {
    msgSeq = 0,
    rewardID = 0
}
MsgType.CGEveryDayTaskRewardRqst.__index = MsgType.CGEveryDayTaskRewardRqst

function MsgType.CGEveryDayTaskRewardRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEveryDayTaskRewardRqst:GetCmd()
    return MsgTypeCmd.CG_EveryDayTaskRewardRqst
end
function MsgType.CGEveryDayTaskRewardRqst:GetUrl()
    return "CGEveryDayTaskRewardRqst"
end
function MsgType.CGEveryDayTaskRewardRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rewardID and 0 ~= self.rewardID then
        tb.c = self.rewardID
    end
    return tb
end

function MsgType.CGEveryDayTaskRewardRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEveryDayTaskRewardRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEveryDayTaskRewardRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCEveryDayTaskRewardRspd.__index = MsgType.GCEveryDayTaskRewardRspd

function MsgType.GCEveryDayTaskRewardRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEveryDayTaskRewardRspd:GetCmd()
    return MsgTypeCmd.GC_EveryDayTaskRewardRspd
end
function MsgType.GCEveryDayTaskRewardRspd:GetUrl()
    return "GCEveryDayTaskRewardRspd"
end
function MsgType.GCEveryDayTaskRewardRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGEveryDayTaskEventRqst = {
    msgSeq = 0,
    eventType = 0
}
MsgType.CGEveryDayTaskEventRqst.__index = MsgType.CGEveryDayTaskEventRqst

function MsgType.CGEveryDayTaskEventRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGEveryDayTaskEventRqst:GetCmd()
    return MsgTypeCmd.CG_EveryDayTaskEventRqst
end
function MsgType.CGEveryDayTaskEventRqst:GetUrl()
    return "CGEveryDayTaskEventRqst"
end
function MsgType.CGEveryDayTaskEventRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.eventType and 0 ~= self.eventType then
        tb.c = self.eventType
    end
    return tb
end

function MsgType.CGEveryDayTaskEventRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGEveryDayTaskEventRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCEveryDayTaskEventRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCEveryDayTaskEventRspd.__index = MsgType.GCEveryDayTaskEventRspd

function MsgType.GCEveryDayTaskEventRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCEveryDayTaskEventRspd:GetCmd()
    return MsgTypeCmd.GC_EveryDayTaskEventRspd
end
function MsgType.GCEveryDayTaskEventRspd:GetUrl()
    return "GCEveryDayTaskEventRspd"
end
function MsgType.GCEveryDayTaskEventRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.EAdRewardType = {
    DoubleAchieveReward = 1,
    AddOneAction = 2,
    AddOneUgcAction = 3
}

MsgType.CGAdEndRqst = {
    msgSeq = 0,
    adType = 0,
    levelID = 0,
    rewards = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.CGAdEndRqst.__index = MsgType.CGAdEndRqst

function MsgType.CGAdEndRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGAdEndRqst:GetCmd()
    return MsgTypeCmd.CG_AdEndRqst
end
function MsgType.CGAdEndRqst:GetUrl()
    return "CGAdEndRqst"
end
function MsgType.CGAdEndRqst:_rewardsEncode()
    local tb = {}
    for i=1, #self.rewards do
        tb[i] = self.rewards[i]:encode()
    end
    return tb
end
function MsgType.CGAdEndRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.adType and 0 ~= self.adType then
        tb.c = self.adType
    end
    if nil ~= self.levelID and 0 ~= self.levelID then
        tb.d = self.levelID
    end
    tb.e = self:_rewardsEncode()
    return tb
end

function MsgType.CGAdEndRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGAdEndRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCAdEndRspd = {
    msgSeq = 0,
    errorCode = 0,
    adType = 0,
    levelID = 0,
    rewards = {} -- array of MsgType.ItemDisplayerInfo
}
MsgType.GCAdEndRspd.__index = MsgType.GCAdEndRspd

function MsgType.GCAdEndRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCAdEndRspd:GetCmd()
    return MsgTypeCmd.GC_AdEndRspd
end
function MsgType.GCAdEndRspd:GetUrl()
    return "GCAdEndRspd"
end
function MsgType.GCAdEndRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.adType = 0
    self.levelID = 0
    self.rewards = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.adType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.levelID = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardsObj = MsgType.ItemDisplayerInfo:New()
            tmpRewardsObj:Decode(data.f[i])
            self.rewards[i] = tmpRewardsObj
        end
    end
    return self
end


MsgType.PlayerDefineDataInDB = {
    data = ""
}
MsgType.PlayerDefineDataInDB.__index = MsgType.PlayerDefineDataInDB

function MsgType.PlayerDefineDataInDB:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PlayerDefineDataInDB:Encode()
    local tb = {}
    if nil ~= self.data and string.len(self.data) > 0 then
        tb.b = self.data
    end
    return tb
end

function MsgType.PlayerDefineDataInDB:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.data = ""
    if nil ~= data.b then
        self.data = tostring(data.b)
    end
    return self
end

function MsgType.PlayerDefineDataInDB:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.CGClientDefineSetRqst = {
    msgSeq = 0,
    data = ""
}
MsgType.CGClientDefineSetRqst.__index = MsgType.CGClientDefineSetRqst

function MsgType.CGClientDefineSetRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGClientDefineSetRqst:GetCmd()
    return MsgTypeCmd.CG_ClientDefineSetRqst
end
function MsgType.CGClientDefineSetRqst:GetUrl()
    return "CGClientDefineSetRqst"
end
function MsgType.CGClientDefineSetRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.data and string.len(self.data) > 0 then
        tb.c = self.data
    end
    return tb
end

function MsgType.CGClientDefineSetRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGClientDefineSetRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCClientDefineSetRspd = {
    msgSeq = 0,
    errorCode = 0
}
MsgType.GCClientDefineSetRspd.__index = MsgType.GCClientDefineSetRspd

function MsgType.GCClientDefineSetRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCClientDefineSetRspd:GetCmd()
    return MsgTypeCmd.GC_ClientDefineSetRspd
end
function MsgType.GCClientDefineSetRspd:GetUrl()
    return "GCClientDefineSetRspd"
end
function MsgType.GCClientDefineSetRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    return self
end


MsgType.CGClientDefineGetRqst = {
    msgSeq = 0,
    nouse = 0
}
MsgType.CGClientDefineGetRqst.__index = MsgType.CGClientDefineGetRqst

function MsgType.CGClientDefineGetRqst:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.CGClientDefineGetRqst:GetCmd()
    return MsgTypeCmd.CG_ClientDefineGetRqst
end
function MsgType.CGClientDefineGetRqst:GetUrl()
    return "CGClientDefineGetRqst"
end
function MsgType.CGClientDefineGetRqst:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nouse and 0 ~= self.nouse then
        tb.c = self.nouse
    end
    return tb
end

function MsgType.CGClientDefineGetRqst:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CGClientDefineGetRqst:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.MsgDispatcher.Instance:SendLuaMsg(self:GetUrl(), encodeJsonParams)
end


MsgType.GCClientDefineGetRspd = {
    msgSeq = 0,
    errorCode = 0,
    data = ""
}
MsgType.GCClientDefineGetRspd.__index = MsgType.GCClientDefineGetRspd

function MsgType.GCClientDefineGetRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCClientDefineGetRspd:GetCmd()
    return MsgTypeCmd.GC_ClientDefineGetRspd
end
function MsgType.GCClientDefineGetRspd:GetUrl()
    return "GCClientDefineGetRspd"
end
function MsgType.GCClientDefineGetRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.data = ""
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.data = tostring(data.d)
    end
    return self
end


MsgType.LevelInfo = {
    levelId = 0,
    language = ""
}
MsgType.LevelInfo.__index = MsgType.LevelInfo

function MsgType.LevelInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.LevelInfo:Encode()
    local tb = {}
    if nil ~= self.levelId and 0 ~= self.levelId then
        tb.b = self.levelId
    end
    if nil ~= self.language and string.len(self.language) > 0 then
        tb.c = self.language
    end
    return tb
end

function MsgType.LevelInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelId = 0
    self.language = ""
    if nil ~= data.b then
        self.levelId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.language = tostring(data.c)
    end
    return self
end

function MsgType.LevelInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ComLevelData = {
    levelId = 0,
    language = ""
}
MsgType.ComLevelData.__index = MsgType.ComLevelData

function MsgType.ComLevelData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ComLevelData:Encode()
    local tb = {}
    if nil ~= self.levelId and 0 ~= self.levelId then
        tb.b = self.levelId
    end
    if nil ~= self.language and string.len(self.language) > 0 then
        tb.c = self.language
    end
    return tb
end

function MsgType.ComLevelData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.levelId = 0
    self.language = ""
    if nil ~= data.b then
        self.levelId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.language = tostring(data.c)
    end
    return self
end

function MsgType.ComLevelData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.GCUgcComLevelListRspd = {
    msgSeq = 0,
    errorCode = 0, --enum EUgcLevelErrorCode
    comLevelList = {} -- array of MsgType.LevelInfo
}
MsgType.GCUgcComLevelListRspd.__index = MsgType.GCUgcComLevelListRspd

function MsgType.GCUgcComLevelListRspd:New(...)
    local tb = {}
    setmetatable(tb, self)
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        local data = args[2]
        if nil ~= data then
            tb:Decode(data)
        end
    end
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.GCUgcComLevelListRspd:GetCmd()
    return MsgTypeCmd.GC_UgcComLevelListRspd
end
function MsgType.GCUgcComLevelListRspd:GetUrl()
    return "GCUgcComLevelListRspd"
end
function MsgType.GCUgcComLevelListRspd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.errorCode = 0
    self.comLevelList = {}
    if nil ~= data._0 then 
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpComLevelListObj = MsgType.LevelInfo:New()
            tmpComLevelListObj:Decode(data.d[i])
            self.comLevelList[i] = tmpComLevelListObj
        end
    end
    return self
end


MsgType.EUserInfo = {
    account = "",
    bluxAddress = "",
    lastTime = "",
    lastIp = "",
    certified = 0,
    secret = ""
}
MsgType.EUserInfo.__index = MsgType.EUserInfo

function MsgType.EUserInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EUserInfo:Encode()
    local tb = {}
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.b = self.account
    end
    if nil ~= self.bluxAddress and string.len(self.bluxAddress) > 0 then
        tb.c = self.bluxAddress
    end
    if nil ~= self.lastTime and string.len(self.lastTime) > 0 then
        tb.d = self.lastTime
    end
    if nil ~= self.lastIp and string.len(self.lastIp) > 0 then
        tb.e = self.lastIp
    end
    if nil ~= self.certified and 0 ~= self.certified then
        tb.f = self.certified
    end
    if nil ~= self.secret and string.len(self.secret) > 0 then
        tb.g = self.secret
    end
    return tb
end

function MsgType.EUserInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.bluxAddress = ""
    self.lastTime = ""
    self.lastIp = ""
    self.certified = 0
    self.secret = ""
    if nil ~= data.b then
        self.account = tostring(data.b)
    end
    if nil ~= data.c then
        self.bluxAddress = tostring(data.c)
    end
    if nil ~= data.d then
        self.lastTime = tostring(data.d)
    end
    if nil ~= data.e then
        self.lastIp = tostring(data.e)
    end
    if nil ~= data.f then
        self.certified = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.secret = tostring(data.g)
    end
    return self
end

function MsgType.EUserInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.EAdmin = {
    account = "",
    pwd = "",
    lastTime = "",
    lastIp = ""
}
MsgType.EAdmin.__index = MsgType.EAdmin

function MsgType.EAdmin:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EAdmin:Encode()
    local tb = {}
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.b = self.account
    end
    if nil ~= self.pwd and string.len(self.pwd) > 0 then
        tb.c = self.pwd
    end
    if nil ~= self.lastTime and string.len(self.lastTime) > 0 then
        tb.d = self.lastTime
    end
    if nil ~= self.lastIp and string.len(self.lastIp) > 0 then
        tb.e = self.lastIp
    end
    return tb
end

function MsgType.EAdmin:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.pwd = ""
    self.lastTime = ""
    self.lastIp = ""
    if nil ~= data.b then
        self.account = tostring(data.b)
    end
    if nil ~= data.c then
        self.pwd = tostring(data.c)
    end
    if nil ~= data.d then
        self.lastTime = tostring(data.d)
    end
    if nil ~= data.e then
        self.lastIp = tostring(data.e)
    end
    return self
end

function MsgType.EAdmin:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.ExchangeStatus = {
    E_PENDING = 0,
    E_COMPLETE = 1,
    E_FAIL = 3
}

MsgType.F2BExchange = {
    account = "",
    createDate = "",
    finishDate = "",
    action = "",
    bluxAddress = "",
    status = 0, --enum ExchangeStatus
    txid = "",
    price = 0,
    amount = 0,
    total = 0,
    type = 0
}
MsgType.F2BExchange.__index = MsgType.F2BExchange

function MsgType.F2BExchange:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.F2BExchange:Encode()
    local tb = {}
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.b = self.account
    end
    if nil ~= self.createDate and string.len(self.createDate) > 0 then
        tb.c = self.createDate
    end
    if nil ~= self.finishDate and string.len(self.finishDate) > 0 then
        tb.d = self.finishDate
    end
    if nil ~= self.action and string.len(self.action) > 0 then
        tb.e = self.action
    end
    if nil ~= self.bluxAddress and string.len(self.bluxAddress) > 0 then
        tb.f = self.bluxAddress
    end
    if nil ~= self.status and 0 ~= self.status then
        tb.g = self.status
    end
    if nil ~= self.txid and string.len(self.txid) > 0 then
        tb.h = self.txid
    end
    if nil ~= self.price and 0 ~= self.price then
        tb.i = self.price
    end
    if nil ~= self.amount and 0 ~= self.amount then
        tb.j = self.amount
    end
    if nil ~= self.total and 0 ~= self.total then
        tb.k = self.total
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.l = self.type
    end
    return tb
end

function MsgType.F2BExchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.createDate = ""
    self.finishDate = ""
    self.action = ""
    self.bluxAddress = ""
    self.status = 0
    self.txid = ""
    self.price = 0
    self.amount = 0
    self.total = 0
    self.type = 0
    if nil ~= data.b then
        self.account = tostring(data.b)
    end
    if nil ~= data.c then
        self.createDate = tostring(data.c)
    end
    if nil ~= data.d then
        self.finishDate = tostring(data.d)
    end
    if nil ~= data.e then
        self.action = tostring(data.e)
    end
    if nil ~= data.f then
        self.bluxAddress = tostring(data.f)
    end
    if nil ~= data.g then
        self.status = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.txid = tostring(data.h)
    end
    if nil ~= data.i then
        self.price = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.amount = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.total = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.type = tonumber(data.l) or 0
    end
    return self
end

function MsgType.F2BExchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.B2PExchange = {
    account = "",
    createDate = "",
    finishDate = "",
    action = "",
    bluxAddress = "",
    paxWithdrawal = "",
    status = 0, --enum ExchangeStatus
    txid = "",
    price = 0,
    amount = 0,
    total = 0,
    type = 0
}
MsgType.B2PExchange.__index = MsgType.B2PExchange

function MsgType.B2PExchange:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.B2PExchange:Encode()
    local tb = {}
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.b = self.account
    end
    if nil ~= self.createDate and string.len(self.createDate) > 0 then
        tb.c = self.createDate
    end
    if nil ~= self.finishDate and string.len(self.finishDate) > 0 then
        tb.d = self.finishDate
    end
    if nil ~= self.action and string.len(self.action) > 0 then
        tb.e = self.action
    end
    if nil ~= self.bluxAddress and string.len(self.bluxAddress) > 0 then
        tb.f = self.bluxAddress
    end
    if nil ~= self.paxWithdrawal and string.len(self.paxWithdrawal) > 0 then
        tb.g = self.paxWithdrawal
    end
    if nil ~= self.status and 0 ~= self.status then
        tb.h = self.status
    end
    if nil ~= self.txid and string.len(self.txid) > 0 then
        tb.i = self.txid
    end
    if nil ~= self.price and 0 ~= self.price then
        tb.j = self.price
    end
    if nil ~= self.amount and 0 ~= self.amount then
        tb.k = self.amount
    end
    if nil ~= self.total and 0 ~= self.total then
        tb.l = self.total
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.m = self.type
    end
    return tb
end

function MsgType.B2PExchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.account = ""
    self.createDate = ""
    self.finishDate = ""
    self.action = ""
    self.bluxAddress = ""
    self.paxWithdrawal = ""
    self.status = 0
    self.txid = ""
    self.price = 0
    self.amount = 0
    self.total = 0
    self.type = 0
    if nil ~= data.b then
        self.account = tostring(data.b)
    end
    if nil ~= data.c then
        self.createDate = tostring(data.c)
    end
    if nil ~= data.d then
        self.finishDate = tostring(data.d)
    end
    if nil ~= data.e then
        self.action = tostring(data.e)
    end
    if nil ~= data.f then
        self.bluxAddress = tostring(data.f)
    end
    if nil ~= data.g then
        self.paxWithdrawal = tostring(data.g)
    end
    if nil ~= data.h then
        self.status = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.txid = tostring(data.i)
    end
    if nil ~= data.j then
        self.price = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.amount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.total = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.type = tonumber(data.m) or 0
    end
    return self
end

function MsgType.B2PExchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end


MsgType.FakerData = {
    roleUID = 0,
    roleName = "",
    portraitID = 0,
    fansList = {}, -- array of number
    followList = {}, -- array of number
    followCount = 0,
    fansCount = 0,
    workerPoint = 0, --enum EUgcLevelStatus
    builderPoint = 0, --enum EUgcLevelStatus
    introduction = ""
}
MsgType.FakerData.__index = MsgType.FakerData

function MsgType.FakerData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FakerData:Encode()
    local tb = {}
    if nil ~= self.roleUID and 0 ~= self.roleUID then
        tb.b = self.roleUID
    end
    if nil ~= self.roleName and string.len(self.roleName) > 0 then
        tb.c = self.roleName
    end
    if nil ~= self.portraitID and 0 ~= self.portraitID then
        tb.d = self.portraitID
    end
    if nil ~= self.fansList and string.len(self.fansList) > 0 then
        tb.e = self.fansList
    end
    if nil ~= self.followList and string.len(self.followList) > 0 then
        tb.f = self.followList
    end
    if nil ~= self.followCount and 0 ~= self.followCount then
        tb.g = self.followCount
    end
    if nil ~= self.fansCount and 0 ~= self.fansCount then
        tb.h = self.fansCount
    end
    if nil ~= self.workerPoint and 0 ~= self.workerPoint then
        tb.i = self.workerPoint
    end
    if nil ~= self.builderPoint and 0 ~= self.builderPoint then
        tb.j = self.builderPoint
    end
    if nil ~= self.introduction and string.len(self.introduction) > 0 then
        tb.k = self.introduction
    end
    return tb
end

function MsgType.FakerData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    self.roleUID = 0
    self.roleName = ""
    self.portraitID = 0
    self.fansList = {}
    self.followList = {}
    self.followCount = 0
    self.fansCount = 0
    self.workerPoint = 0
    self.builderPoint = 0
    self.introduction = ""
    if nil ~= data.b then
        self.roleUID = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.roleName = tostring(data.c)
    end
    if nil ~= data.d then
        self.portraitID = tonumber(data.d) or 0
    end
    if nil ~= data.e and #data.e > 0 then
        for i=1, #data.e do
            self.fansList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.followList[i] = tonumber(data.e[i] )
        end
    end
    if nil ~= data.g then
        self.followCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.fansCount = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.workerPoint = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.builderPoint = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.introduction = tostring(data.k)
    end
    return self
end

function MsgType.FakerData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

