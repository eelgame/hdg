---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by admin.
--- DateTime: 2019/1/7 16:46
---
require("UIPanel.Ugc.UI_UgcChess")
UI_UGCChessBoard=classUtlis()
function UI_UGCChessBoard:ctor(panel,callBackClick,callBackTouchBegin,callBackTouchEnd,callBackRollOver,callBackLongPress)
    self.panel=panel
    self.BottomSelect=callBackClick
    self.BottomTouchBegin=callBackTouchBegin
    self.BottomTouchEnd=callBackTouchEnd
    self.BottomRollOver=callBackRollOver
    self.LongPress=callBackLongPress
   -- self.bottomList=  panel:GetChild("GBlattice")
    self.ChessLayers={}
    for i = 1, 6 do
        self.ChessLayers[i]=  panel:GetChild("ChessLayer"..i)
    end
    self.panel.fairyBatching=true
    self.creating=false
end

function UI_UGCChessBoard:Dispose()
    self.panel=nil
    self.BottomSelect=nil
    self.BottomTouchBegin=nil
    self.BottomTouchEnd=nil
    self.BottomRollOver=nil
    self.LongPress=nil
    self.boardShowCallback=nil
    self.finishCallback=nil
    for i = 1, 6 do
        self.ChessLayers[i]= nil
    end
    self.ChessLayers=nil
    for i = 9,1,-1 do
     local  rList= self.slotsComList[i]
        if rList then
            for j = 1,11 do
                local item=self.slotsComList[i][j]
                if item then
                    item:Dispose()
                    self.slotsComList[i][j]=nil
                end
            end
        end
    end
    self.slotsComList=nil
    self.isDispose=true
end

function UI_UGCChessBoard:CreateSlots()
    for i = 1, 6 do
        self.ChessLayers[i]:RemoveChildrenToPool(0, self.ChessLayers[i]:GetChildren().Length)
    end
    self.slotsComList={}
    for i = 9,1,-1 do
        self.slotsComList[i]={}
        for j = 1,11 do
            local layerItems={}
            for i = 1, 6 do
                layerItems[i]= self.ChessLayers[i]:AddItemFromPool()
            end
            self.slotsComList[i][j]=UI_UgcChess.new(layerItems,j-1,i-1,
                    self.BottomSelect,self.BottomTouchBegin,self.BottomTouchEnd,self.BottomRollOver,self.LongPress)
            self.slotsComList[i][j]:SetSlots(self.slotsComList)
        end

    end
    self.creating =0
    self.isDispose=false
    return  self.slotsComList
end

function UI_UGCChessBoard:InitSlots(levelID,slotsProfile,width,height,finishCallback)
    self:CreateSlots()
    self:FlushInfo(levelID,slotsProfile,width,height,true,finishCallback,true)
    self:SetVisibleForce(true)
    return  self.slotsComList
end

function UI_UGCChessBoard:CreateBoardCoroutine(slotsItemsCfg,isCo,isEditor,levelID)
    self:SetVisibleForce(false)
    self.creating = self.creating+1
    yield_return(CS.WaitCoroutineDefine.WaitForEndOfFrame)
    local yList
    local item
    local itemCom
    if isCo then
        for i = 1,11 do
            if self.levelID==levelID and not self.isDispose then
                yList= slotsItemsCfg[i]
                for j = 1,9 do
                    if yList then
                        item=yList[j]
                    end
                    itemCom= self.slotsComList[j][i]
                    itemCom:Init(item,isEditor)
                end
                yield_return(CS.WaitCoroutineDefine.WaitForEndOfFrame)
            end

        end
    else
        for i = 1,11 do
            yList= slotsItemsCfg[i]
            for j = 1,9 do
                if yList then
                    item=yList[j]
                end
                if  self.slotsComList then
                    if self.levelID==levelID and not self.isDispose then
                        itemCom= self.slotsComList[j][i]
                        itemCom:Init(item,isEditor)
                        yield_return(CS.WaitCoroutineDefine.WaitForEndOfFrame)
                    end

                end
            end
        end
    end
    self.creating = self.creating-1
    if self and self.finishCallback then
        self.finishCallback()
    end
end

function UI_UGCChessBoard:FlushInfo(levelID,slotsItemsCfg,width,height,isSync,finishCallback,isCo,boardShowCallback)
    self.levelID=levelID
    self.boardShowCallback=boardShowCallback
    self.finishCallback=finishCallback
    local isEditor=UGCModel.getInstance().model:GetUGCEditorState()
    local item
    local itemCom
    for i = 1,11 do
        local yList= slotsItemsCfg[i]
        for j = 1,9 do
            itemCom= self.slotsComList[j][i]
            itemCom:Reset()
            if yList then
                item=yList[j]
            end
            if item and item.slotCfg and #item.slotCfg>0 then
                itemCom:SetSlotActive(true)
            else
                itemCom:SetSlotActive(false)
            end
        end
    end
     local fun =  function ()
        self:CreateBoardCoroutine(slotsItemsCfg,isCo,isEditor,levelID)
    end
    if isSync then
       -- self:CreateBoardCoroutine(slotsItemsCfg,isCo,isEditor)
        local co1 = coroutine.create(fun)
        assert(coroutine.resume(co1))
    else
        self.creating=0
        self:SetVisibleForce(false)
        for i = 1,11 do
            local yList= slotsItemsCfg[i]
            for j = 1,9 do
                if yList then
                    item=yList[j]
                end
                 itemCom= self.slotsComList[j][i]
                itemCom:Init(item,isEditor)
            end
        end
        if self and finishCallback then
            finishCallback()
        end
    end

end

function UI_UGCChessBoard:SetVisible(isVisible)
    if self.creating==0 then
        if  self.panel.displayObject and self.panel.visible~= isVisible then
            self.panel.visible=isVisible
            if   self.boardShowCallback then
                self.boardShowCallback(isVisible)
            end
        end
    end

end

function UI_UGCChessBoard:SetVisibleForce(isVisible)
    if   self.panel.displayObject then
        self.panel.visible=isVisible
        if   self.boardShowCallback then
            self.boardShowCallback(isVisible)
        end
    end

end

function UI_UGCChessBoard:ClearSlots()
    for i = 1, 6 do
        self.ChessLayers[i]:RemoveChildrenToPool(0, self.ChessLayers[i]:GetChildren().Length)
    end
end


