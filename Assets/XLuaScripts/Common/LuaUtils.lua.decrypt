---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yezhicong.
--- DateTime: 2018/7/30 19:51
---

local metetable =  require("Common/Metetable")

--List
List = {}
List.__index = List

function List:New(type)
    local o = {itemType = MyType(type)}
    setmetatable(o,self)
    return o
end

function List:Add(item)
    --assert(self.itemType ~= MyType(item),"列表参数类型错误 ")
    assert(equal(self.itemType,MyType(item)) ,"List Add: item type error! ")
    table.insert(self,item)
end

function List:Clear()
    local count = self:Count()
    for i = 1,count do
        table.remove(self)
    end
end

function List:Contains(item)
    if self.itemType ~= MyType(item) then
        return false
    end
    local count = self.Count()
    for i = 1, count do
        if self[i] == item then
            return true
        end
    end
    return false
end

function List:Count()
    return #self
end

--属性

--Dictionary,
--为了让lua的字典在C#侧都能直接由Table转成字典，所以这里的Keylist和类型我就把它设置到元表中，这样cast时就不会被映射出来      -yzc  2018/7/31
Dictionary = {}
--Dictionary.__index = Dictionary
function Dictionary:New(keytype,valuetype)
    local matetable = {keytype = MyType(keytype) ,valuetype = MyType(valuetype)}
    matetable.keylist = {}
    for i,v in pairs(self) do
        matetable[i] = v;
    end
    matetable.__index = matetable
    local o = {}
    setmetatable(o,matetable)
    return o
end

function Dictionary:Add(key,value)
    assert(equal(self.keytype,MyType(key)) and equal(self.valuetype,MyType(value)),"Dictionary Add: Key or Value error! ")
    assert(not self:ContainsKey(key),"字典中已经存在相同键")
    table.insert(self.keylist,key)
    self[key] = value
end

function Dictionary:ContainsKey(key)
    for i,v in ipairs(self.keylist) do
        if v == key then
            return true
        end
    end
    return false
end


--包含了C#类型和lua基础类型的类型获得
function MyType(t)
    --Xlua将C#类转为table
    if type(t) == "table" and t.UnderlyingSystemType ~= nil then
        return Split(tostring(t.UnderlyingSystemType),":")[1]
    end
    --Xlua将C#实例转化userdata
    if type(t) == "userdata" then
        return Split(tostring(t),":")[1]
    end
    --我自定义的类
    if type(t) == "table" and t.MyClassType ~= nil then
        return t.MyClassType
    end
    return type(t)
end

--主要是C#和lua的类型对应
function equal(a,b)

    if a == b then return true end

    local target = nil
    local lself = nil
    if a == "number" then target = b lself = "number" elseif b == "number" then target = a lself = "number" end
    if a == "string" then target = b lself = "string" elseif b == "string" then target = a lself = "string" end
    if target then
        if lself == "number" and (target == "System.Int32" or target == "System.Single" or target =="System.UInt32" or target =="System.Double" or target =="System.Byte") then return true end
        if lself == "string" and target == "System.String" then return true end
   end

    return false
end


--C#协程之Xlua作者的实现方式
local util = require 'xlua.util'
--local gameobject = CS.UnityEngine.GameObject('Coroutine_Runner')
--CS.UnityEngine.Object.DontDestroyOnLoad(gameobject)
--local cs_coroutine_runner = gameobject:AddComponent(typeof(CS.Coroutine_Runner))

local function async_yield_return(to_yield, cb)
    CS.XluaUtils.YieldAndCallback(to_yield, cb)
end

yield_return2 = util.async_to_sync(async_yield_return)

yield_return = require("Common/LuaToMonoCoroutine").yield_return
--自己的实现方式                                                                                                          ---2018/8/8
--lua的协程，特点在于resume和yield，开始执行和挂起时，每次重新从yield return开始执行时，重新传参，每次挂起时，通过yield返回参数
--C#的协程，每次yield时，会根据返回值返回当前迭代器，并等待返回时间计算完毕或者返回的迭代器完成，再次启动。对于协程的挂机和继续执行，unity是自己实现的，这部分也是
--lua需要实现最重要的地方

--TODO





--String
--对string的扩展，lua的string库和c#还是有蛮多区别的

--字符串通过分隔符分段                                                       yzc  -2018/8/8
function Split(str,separator)
    assert(type(str) == "string","luastring：参数错误，不是字符串类型")
    local result = {}
    while(string.find(str,separator,1,true) ~= nil)do
        table.insert(result,string.sub(str,1,string.find(str,separator,1,true)-1))
        str = string.sub(str,string.find(str,separator,1,true)+1)
    end
    table.insert(result,str)
    return result
end


-- Try-Catch          18/10/22

function try(block)
    local try = block[1]
    assert(try)

    local funcs = block[2]
    if funcs and block[3] then
        table.join2(funcs,block[2])
    end

    local ok,errors = pcall(try)
    if not ok then
        if funcs and funcs.catch then
            funcs.catch(errors)
        end
   end

    if funcs and funcs.finally then
        funcs.finally(ok,errors)
    end

    if ok then
        return errors
    end
end

